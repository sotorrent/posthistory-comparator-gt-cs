Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
108093680;34701679;39223;2;d4b589fe-94f5-4a22-85bd-944ab53d32bb;2016-01-10 03:19:58.0;"If the problem is specifically supposed to be about parsing, then awk might be a good option.&#xD;&#xA;&#xD;&#xA;However, if the problem is supposed to learn about the tools available to you, I would suggest:&#xD;&#xA;&#xD;&#xA;  * the **stat** tool prints particular pieces of information about a file (including size)&#xD;&#xA;  * the **sort** tool re-orders lines of input&#xD;&#xA;  * the **head** and **tail** tools print the first and last lines of input&#xD;&#xA;  * and your shell can also perform **pathname expansion** to list files matching a glob wildcard pattern like *\\*.txt*&#xD;&#xA;&#xD;&#xA;___&#xD;&#xA;&#xD;&#xA;Imagine a directory with some files of various sizes:&#xD;&#xA;&#xD;&#xA;<pre>&#xD;&#xA;  10000000 sound/concert.wav&#xD;&#xA;   1000000 sound/song.wav&#xD;&#xA;    100000 sound/ding.wav&#xD;&#xA;</pre>&#xD;&#xA;&#xD;&#xA;You can use **pathname expansion** to find their names:&#xD;&#xA;&#xD;&#xA;    $ echo sound/*&#xD;&#xA;    sound/concert.wav sound/ding.wav sound/song.wav&#xD;&#xA;&#xD;&#xA;___&#xD;&#xA;&#xD;&#xA;You can use **stat** to turn a name into a si**z**e:&#xD;&#xA;&#xD;&#xA;    $ stat -f 'This one is %z bytes long.' sound/ding.wav&#xD;&#xA;    This one is 100000 bytes long.&#xD;&#xA;&#xD;&#xA;Like most Unix tools, `stat` works the same whether you provide it one argument or several:&#xD;&#xA;&#xD;&#xA;    $ stat -f 'This one is %z bytes long.' sound/concert.wav sound/ding.wav sound/song.wav&#xD;&#xA;    This one is 10000000 bytes long.&#xD;&#xA;    This one is 100000 bytes long.&#xD;&#xA;    This one is 1000000 bytes long.&#xD;&#xA;&#xD;&#xA;(Check `man stat` for reference about `%z` and what else you can print. The file's **N**ame is particularly useful.)&#xD;&#xA;&#xD;&#xA;___&#xD;&#xA;&#xD;&#xA;It's much easier to find the biggest item in a sorted list than an unsorted list.&#xD;&#xA;&#xD;&#xA;Try finding the highest two items in this unsorted list:&#xD;&#xA;>! 1234 5325 3243 4389 5894 245 2004 45901 3940 3255&#xD;&#xA;&#xD;&#xA;Then for comparison, try to find the highest two items in this sorted list:&#xD;&#xA;>! 245 1234 2004 3243 3255 3940 4389 5325 5894 45901&#xD;&#xA;&#xD;&#xA;The Unix **sort** utility takes lines of input and outputs them from lowest to highest (or in reverse order with `sort -r`).&#xD;&#xA;&#xD;&#xA;It defaults to sorting character-by-character, which is great for words (""apple"" comes before ""balloon"") but not so great for numbers (""10"" comes before ""9""). You can activate **n**umeric sorting with `sort -n`.&#xD;&#xA;___&#xD;&#xA;&#xD;&#xA;Once you have a sorted list of lines, you can print the first lines with the **head** tool, or print the last lines using the **tail** tool.&#xD;&#xA;&#xD;&#xA;The first two items of the (already-sorted) list of words for spell-checking:&#xD;&#xA;    $ head -n 2 /usr/share/dict/words&#xD;&#xA;    A&#xD;&#xA;    a&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    $ tail -n 2 /usr/share/dict/words&#xD;&#xA;    Zyzomys&#xD;&#xA;    Zyzzogeton&#xD;&#xA;&#xD;&#xA;___&#xD;&#xA;&#xD;&#xA;With those pieces, you can assemble a solution to the problem ""find the five biggest files across dir1, dir2, dir3"":&#xD;&#xA;&#xD;&#xA;>!     stat -f '%z %N' dir1/* dir2/* dir3/* |  &#xD;&#xA;>!         sort -n |  &#xD;&#xA;>!         tail -n 5  &#xD;&#xA;&#xD;&#xA;Or a solution to ""find the biggest file in each of dir1, dir, dir3, dir4, dir5"":&#xD;&#xA;&#xD;&#xA;>!     for dir in dir1 dir2 dir3 dir4 dir5; do  &#xD;&#xA;>!         stat -f '%z %N' ""$dir""/* |  &#xD;&#xA;>!             sort -n |  &#xD;&#xA;>!             tail -n 1  &#xD;&#xA;";;
108250962;34701679;39223;5;facfd291-9f26-4797-9b7c-5cd9d2584908;2016-01-12 11:06:19.0;"If the problem is specifically supposed to be about parsing, then awk might be a good option (although `ls` output is challenging to parse reliably). Likewise, if the problem is about working with arrays, then your solution should focus on those.&#xD;&#xA;&#xD;&#xA;However, if the problem is there to encourage learning about the tools available to you, I would suggest:&#xD;&#xA;&#xD;&#xA;  * the **stat** tool prints particular pieces of information about a file (including size)&#xD;&#xA;  * the **sort** tool re-orders lines of input&#xD;&#xA;  * the **head** and **tail** tools print the first and last lines of input&#xD;&#xA;  * and your shell can also perform **pathname expansion** to list files matching a glob wildcard pattern like *\\*.txt*&#xD;&#xA;&#xD;&#xA;___&#xD;&#xA;&#xD;&#xA;Imagine a directory with some files of various sizes:&#xD;&#xA;&#xD;&#xA;<pre>&#xD;&#xA;  10000000 sound/concert.wav&#xD;&#xA;   1000000 sound/song.wav&#xD;&#xA;    100000 sound/ding.wav&#xD;&#xA;</pre>&#xD;&#xA;&#xD;&#xA;You can use **pathname expansion** to find their names:&#xD;&#xA;&#xD;&#xA;    $ echo sound/*&#xD;&#xA;    sound/concert.wav sound/ding.wav sound/song.wav&#xD;&#xA;&#xD;&#xA;___&#xD;&#xA;&#xD;&#xA;You can use **stat** to turn a name into a si**z**e:&#xD;&#xA;&#xD;&#xA;    $ stat -f 'This one is %z bytes long.' sound/ding.wav&#xD;&#xA;    This one is 100000 bytes long.&#xD;&#xA;&#xD;&#xA;Like most Unix tools, `stat` works the same whether you provide it one argument or several:&#xD;&#xA;&#xD;&#xA;    $ stat -f 'This one is %z bytes long.' sound/concert.wav sound/ding.wav sound/song.wav&#xD;&#xA;    This one is 10000000 bytes long.&#xD;&#xA;    This one is 100000 bytes long.&#xD;&#xA;    This one is 1000000 bytes long.&#xD;&#xA;&#xD;&#xA;(Check `man stat` for reference about `%z` and what else you can print. The file's **N**ame is particularly useful.)&#xD;&#xA;&#xD;&#xA;___&#xD;&#xA;&#xD;&#xA;Now you have a list of file sizes (and hopefully you've kept their names around too). How do you find which sizes are biggest?&#xD;&#xA;&#xD;&#xA;It's much easier to find the biggest item in a sorted list than an unsorted list. To get a feel for it, think about how you might find the highest two items in this unsorted list:&#xD;&#xA;> 1234 5325 3243 4389 5894 245 2004 45901 3940 3255&#xD;&#xA;&#xD;&#xA;Whereas if the list is sorted, you can find the biggest items very quickly indeed:&#xD;&#xA;> 245 1234 2004 3243 3255 3940 4389 5325 5894 45901&#xD;&#xA;&#xD;&#xA;The Unix **sort** utility takes lines of input and outputs them from lowest to highest (or in **r**everse order with `sort -r`).&#xD;&#xA;&#xD;&#xA;It defaults to sorting character-by-character, which is great for words (""apple"" comes before ""balloon"") but not so great for numbers (""10"" comes before ""9""). You can activate **n**umeric sorting with `sort -n`.&#xD;&#xA;___&#xD;&#xA;&#xD;&#xA;Once you have a sorted list of lines, you can print the first lines with the **head** tool, or print the last lines using the **tail** tool.&#xD;&#xA;&#xD;&#xA;The first two items of the (already-sorted) list of words for spell-checking:&#xD;&#xA;&#xD;&#xA;    $ head -n 2 /usr/share/dict/words&#xD;&#xA;    A&#xD;&#xA;    a&#xD;&#xA;&#xD;&#xA;The last two items:&#xD;&#xA;&#xD;&#xA;    $ tail -n 2 /usr/share/dict/words&#xD;&#xA;    Zyzomys&#xD;&#xA;    Zyzzogeton&#xD;&#xA;&#xD;&#xA;___&#xD;&#xA;&#xD;&#xA;With those pieces, you can assemble a solution to the problem ""find the five biggest files across dir1, dir2, dir3"":&#xD;&#xA;&#xD;&#xA;    stat -f '%z %N' dir1/* dir2/* dir3/* |  &#xD;&#xA;         sort -n |  &#xD;&#xA;         tail -n 5  &#xD;&#xA;&#xD;&#xA;Or a solution to ""find the biggest file in each of dir1, dir, dir3, dir4, dir5"":&#xD;&#xA;&#xD;&#xA;    for dir in dir1 dir2 dir3 dir4 dir5; do  &#xD;&#xA;        stat -f '%z %N' ""$dir""/* |  &#xD;&#xA;            sort -n |  &#xD;&#xA;            tail -n 1  &#xD;&#xA;    done&#xD;&#xA;&#xD;&#xA;";;removed spoiler tags (since a couple of people didn't think they helped), improved formatting, added a few explanatory words
