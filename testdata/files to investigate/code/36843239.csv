Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
116568169;36843239;4603670;2;8d9786eb-d786-423c-8291-dce936f2ff77;2016-04-25 14:18:42.0;"You have to create a message procedure then respond to key messages. For example&#xD;&#xA;&#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    		CreateWindow(L""childClassName"", L""child window"", &#xD;&#xA;    		    		WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, &#xD;&#xA;    		    		0, 0, 300, 200, hwnd, 0, 0, 0);&#xD;&#xA;    		break;&#xD;&#xA;    &#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;
116568611;36843239;4603670;5;96440106-bd13-45c3-ba7e-84b843af6289;2016-04-25 14:23:44.0;"You have to create a message procedure then respond to key messages. For example&#xD;&#xA;&#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    		CreateWindow(L""myChildClass"", L""child window"", &#xD;&#xA;    		    		WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, &#xD;&#xA;    		    		0, 0, 300, 200, hwnd, 0, 0, 0);&#xD;&#xA;    		break;&#xD;&#xA;    &#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Note that you have to register a second class name for ""myChildClass"" and then create a different message procedure for this child class. For example:&#xD;&#xA;&#xD;&#xA;	WNDCLASSEX wcex = { sizeof(WNDCLASSEX) };&#xD;&#xA;	wcex.style = CS_HREDRAW | CS_VREDRAW;&#xD;&#xA;	wcex.lpfnWndProc = ChildProc;&#xD;&#xA;	wcex.hInstance = hInstance;&#xD;&#xA;	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);&#xD;&#xA;	wcex.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);&#xD;&#xA;	wcex.lpszClassName = L""myChildClass"";&#xD;&#xA;	RegisterClassEx(&wcex);&#xD;&#xA;&#xD;&#xA;Then you add a separate function called `ChildProc` which is similar to `WndProc`&#xD;&#xA;";;added 547 characters in body
116569622;36843239;4603670;5;6b4a1d22-f0ac-4371-bbde-aa27dca2e66c;2016-04-25 14:34:19.0;"You have to create a message procedure then respond to key messages. For example&#xD;&#xA;&#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    		CreateWindow(L""myChildClass"", L""child window"", &#xD;&#xA;    		    		WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, &#xD;&#xA;    		    		0, 0, 300, 200, hwnd, 0, 0, 0);&#xD;&#xA;    		break;&#xD;&#xA;    &#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Note that you have to register a second class name for ""myChildClass"" and then create a different message procedure for this child class. For example:&#xD;&#xA;&#xD;&#xA;Then you add a separate function called `ChildProc` which is similar to `WndProc`. For example:&#xD;&#xA;&#xD;&#xA;    #define UNICODE&#xD;&#xA;    #include <Windows.h>&#xD;&#xA;    &#xD;&#xA;    LRESULT CALLBACK ChildProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    			CreateWindow(L""childClass"", L""childTitle"",     				&#xD;&#xA;    			WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, 100, 100, 300, 200, hwnd, 0, 0, 0);&#xD;&#xA;    		break;&#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, LPTSTR, int)&#xD;&#xA;    {&#xD;&#xA;    	WNDCLASSEX wcex = { sizeof(WNDCLASSEX) };&#xD;&#xA;    	wcex.style = CS_HREDRAW | CS_VREDRAW;&#xD;&#xA;    	wcex.lpfnWndProc = WndProc;&#xD;&#xA;    	wcex.hInstance = hInstance;&#xD;&#xA;    	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);&#xD;&#xA;    	wcex.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);&#xD;&#xA;    	wcex.lpszClassName = L""MainClass"";&#xD;&#xA;    	RegisterClassEx(&wcex);&#xD;&#xA;    &#xD;&#xA;    	wcex.lpszClassName = L""ChildClass"";&#xD;&#xA;    	wcex.lpfnWndProc = ChildProc;&#xD;&#xA;    	RegisterClassEx(&wcex);&#xD;&#xA;    &#xD;&#xA;    	CreateWindow(L""MainClass"", L""MainTitle"", WS_VISIBLE | WS_OVERLAPPEDWINDOW, &#xD;&#xA;    	0, 0, 600, 400, 0, 0, hInstance, 0);&#xD;&#xA;    &#xD;&#xA;    	MSG msg;&#xD;&#xA;    	while (GetMessage(&msg, NULL, 0, 0))&#xD;&#xA;    	{&#xD;&#xA;    		TranslateMessage(&msg);&#xD;&#xA;    		DispatchMessage(&msg);&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return (int)msg.wParam;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;";;added 1307 characters in body
116570628;36843239;4603670;5;e8c058b7-44c2-43f5-984b-dc2138380be7;2016-04-25 14:44:29.0;"You have to create a message procedure then respond to key messages. For example&#xD;&#xA;&#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    		CreateWindow(L""myChildClass"", L""child window"", &#xD;&#xA;    		    		WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, &#xD;&#xA;    		    		0, 0, 300, 200, hwnd, 0, 0, 0);&#xD;&#xA;    		break;&#xD;&#xA;    &#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Note that you have to register a second class name for ""myChildClass"" and then create a different message procedure for this child class. For example:&#xD;&#xA;&#xD;&#xA;Then you add a separate function called `ChildProc` which is similar to `WndProc`. For example:&#xD;&#xA;&#xD;&#xA;    #define UNICODE&#xD;&#xA;    #include <Windows.h>&#xD;&#xA;    &#xD;&#xA;    LRESULT CALLBACK ChildProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;        {&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    		{&#xD;&#xA;    			MessageBox(0, L""Test"", 0, 0);&#xD;&#xA;    			HINSTANCE hinstance = 0;&#xD;&#xA;    			CreateWindow(L""childClass"", L""childTitle"",     				&#xD;&#xA;    			WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, 100, 100, 300, 200, &#xD;&#xA;    			hwnd, 0, hinstance, 0);&#xD;&#xA;    		}&#xD;&#xA;    		break;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, LPTSTR, int)&#xD;&#xA;    {&#xD;&#xA;    	WNDCLASSEX wcex = { sizeof(WNDCLASSEX) };&#xD;&#xA;    	wcex.style = CS_HREDRAW | CS_VREDRAW;&#xD;&#xA;    	wcex.lpfnWndProc = WndProc;&#xD;&#xA;    	wcex.hInstance = hInstance;&#xD;&#xA;    	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);&#xD;&#xA;    	wcex.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);&#xD;&#xA;    	wcex.lpszClassName = L""MainClass"";&#xD;&#xA;    	RegisterClassEx(&wcex);&#xD;&#xA;    &#xD;&#xA;    	wcex.lpszClassName = L""ChildClass"";&#xD;&#xA;    	wcex.lpfnWndProc = ChildProc;&#xD;&#xA;    	RegisterClassEx(&wcex);&#xD;&#xA;    &#xD;&#xA;    	CreateWindow(L""MainClass"", L""MainTitle"", WS_VISIBLE | WS_OVERLAPPEDWINDOW, &#xD;&#xA;    	0, 0, 600, 400, 0, 0, hInstance, 0);&#xD;&#xA;    &#xD;&#xA;    	MSG msg;&#xD;&#xA;    	while (GetMessage(&msg, NULL, 0, 0))&#xD;&#xA;    	{&#xD;&#xA;    		TranslateMessage(&msg);&#xD;&#xA;    		DispatchMessage(&msg);&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return (int)msg.wParam;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;";;added 92 characters in body
116572093;36843239;4603670;5;d4be0d4e-e581-47ba-9d44-aa70d25d931c;2016-04-25 15:00:24.0;"You have to create a message procedure then respond to key messages. For example&#xD;&#xA;&#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    		CreateWindow(L""ChildClass"", L""Child window"", &#xD;&#xA;    		    		WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, &#xD;&#xA;    		    		0, 0, 300, 200, hwnd, 0, 0, 0);&#xD;&#xA;    		break;&#xD;&#xA;    &#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Note that you have to register a second class name for ""ChildClass"" and then create a different message procedure for this child class. For example:&#xD;&#xA;&#xD;&#xA;Then you add a separate function called `ChildProc` which is similar to `WndProc`. For example:&#xD;&#xA;&#xD;&#xA;    #define UNICODE&#xD;&#xA;    #include <Windows.h>&#xD;&#xA;    &#xD;&#xA;    HINSTANCE g_hinstance = 0;&#xD;&#xA;    &#xD;&#xA;    LRESULT CALLBACK ChildProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;    	{&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    		{&#xD;&#xA;    			if (!CreateWindow(L""ChildClass"", L""ChildTitle"",&#xD;&#xA;    				WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, 100, 100, 300, 200,&#xD;&#xA;    				hwnd, 0, g_hinstance, 0))&#xD;&#xA;    			{&#xD;&#xA;    				DWORD err = GetLastError();&#xD;&#xA;    				wchar_t buf[100];&#xD;&#xA;    				wsprintf(buf, L""%d\\n"", err);&#xD;&#xA;    				MessageBox(0, buf, 0, 0);&#xD;&#xA;    			}&#xD;&#xA;    		}&#xD;&#xA;    		break;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, LPTSTR, int)&#xD;&#xA;    {&#xD;&#xA;    	WNDCLASSEX wcex = { sizeof(WNDCLASSEX) };&#xD;&#xA;    	wcex.style = CS_HREDRAW | CS_VREDRAW;&#xD;&#xA;    	wcex.lpfnWndProc = WndProc;&#xD;&#xA;    	wcex.hInstance = hInstance;&#xD;&#xA;    	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);&#xD;&#xA;    	wcex.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);&#xD;&#xA;    	wcex.lpszClassName = L""MainClass"";&#xD;&#xA;    	RegisterClassEx(&wcex);&#xD;&#xA;    &#xD;&#xA;    	wcex.lpszClassName = L""ChildClass"";&#xD;&#xA;    	wcex.lpfnWndProc = ChildProc;&#xD;&#xA;    	RegisterClassEx(&wcex);&#xD;&#xA;    &#xD;&#xA;    	CreateWindow(L""MainClass"", L""MainTitle"", WS_VISIBLE | WS_OVERLAPPEDWINDOW,&#xD;&#xA;    		0, 0, 600, 400, 0, 0, hInstance, 0);&#xD;&#xA;    &#xD;&#xA;    	MSG msg;&#xD;&#xA;    	while (GetMessage(&msg, NULL, 0, 0))&#xD;&#xA;    	{&#xD;&#xA;    		TranslateMessage(&msg);&#xD;&#xA;    		DispatchMessage(&msg);&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return (int)msg.wParam;&#xD;&#xA;    }";;added 113 characters in body
116574304;36843239;4603670;5;af75e073-69da-4cfd-a825-adc0d0beed59;2016-04-25 15:25:30.0;"You have to create a message procedure then respond to key messages. For example&#xD;&#xA;&#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    		CreateWindow(L""ChildClass"", L""Child window"", &#xD;&#xA;    		    		WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, &#xD;&#xA;    		    		0, 0, 300, 200, hwnd, 0, 0, 0);&#xD;&#xA;    		break;&#xD;&#xA;    &#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Note that you have to register a second class name for ""ChildClass"" and then create a different message procedure for this child class. For example:&#xD;&#xA;&#xD;&#xA;Then you add a separate function called `ChildProc` which is similar to `WndProc`. For example:&#xD;&#xA;&#xD;&#xA;    #define UNICODE&#xD;&#xA;    #include <Windows.h>&#xD;&#xA;    &#xD;&#xA;    HINSTANCE g_hinstance = 0;&#xD;&#xA;    &#xD;&#xA;    LRESULT CALLBACK ChildProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;    	{&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    		{&#xD;&#xA;    			MessageBox(0, L""VK_F5 detected"", 0, 0);&#xD;&#xA;    			if (!CreateWindow(L""ChildClass"", L""ChildTitle"",&#xD;&#xA;    				WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, 100, 100, 300, 200,&#xD;&#xA;    				hwnd, 0, g_hinstance, 0))&#xD;&#xA;    			{&#xD;&#xA;    				DWORD err = GetLastError();&#xD;&#xA;    				wchar_t buf[100];&#xD;&#xA;    				wsprintf(buf, L""%d\\n"", err);&#xD;&#xA;    				MessageBox(0, buf, 0, 0);&#xD;&#xA;    			}&#xD;&#xA;    		}&#xD;&#xA;    		break;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, LPTSTR, int)&#xD;&#xA;    {&#xD;&#xA;    	WNDCLASSEX wcex = { sizeof(WNDCLASSEX) };&#xD;&#xA;    	wcex.style = CS_HREDRAW | CS_VREDRAW;&#xD;&#xA;    	wcex.lpfnWndProc = WndProc;&#xD;&#xA;    	wcex.hInstance = hInstance;&#xD;&#xA;    	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);&#xD;&#xA;    	wcex.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);&#xD;&#xA;    	wcex.lpszClassName = L""MainClass"";&#xD;&#xA;    	RegisterClassEx(&wcex);&#xD;&#xA;    &#xD;&#xA;    	wcex.lpszClassName = L""ChildClass"";&#xD;&#xA;    	wcex.lpfnWndProc = ChildProc;&#xD;&#xA;    	RegisterClassEx(&wcex);&#xD;&#xA;    &#xD;&#xA;    	CreateWindow(L""MainClass"", L""MainTitle"", WS_VISIBLE | WS_OVERLAPPEDWINDOW,&#xD;&#xA;    		0, 0, 600, 400, 0, 0, hInstance, 0);&#xD;&#xA;    &#xD;&#xA;    	MSG msg;&#xD;&#xA;    	while (GetMessage(&msg, NULL, 0, 0))&#xD;&#xA;    	{&#xD;&#xA;    		TranslateMessage(&msg);&#xD;&#xA;    		DispatchMessage(&msg);&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return (int)msg.wParam;&#xD;&#xA;    }";;added 48 characters in body
116574889;36843239;4603670;5;bad966be-28f3-4f2c-9be2-3f279dfd09d3;2016-04-25 15:32:11.0;"You have to create a message procedure then respond to key messages. For example&#xD;&#xA;&#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    		CreateWindow(L""ChildClass"", L""Child window"", &#xD;&#xA;    		    		WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, &#xD;&#xA;    		    		0, 0, 300, 200, hwnd, 0, 0, 0);&#xD;&#xA;    		break;&#xD;&#xA;    &#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Note that you have to register a second class name for ""ChildClass"" and then create a different message procedure for this child class. &#xD;&#xA;&#xD;&#xA;Then you add a separate function called `ChildProc` which is similar to `WndProc`. For example:&#xD;&#xA;&#xD;&#xA;    #define UNICODE&#xD;&#xA;    #include <Windows.h>&#xD;&#xA;    &#xD;&#xA;    HINSTANCE g_hinstance = 0;&#xD;&#xA;    &#xD;&#xA;    LRESULT CALLBACK ChildProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)&#xD;&#xA;    {&#xD;&#xA;    	switch (msg)&#xD;&#xA;    	{&#xD;&#xA;    	case WM_KEYDOWN:&#xD;&#xA;    	{&#xD;&#xA;    		if (wp == VK_F5)&#xD;&#xA;    		{&#xD;&#xA;    			MessageBox(0, L""VK_F5 detected"", 0, 0);&#xD;&#xA;    			if (!CreateWindow(L""ChildClass"", L""ChildTitle"",&#xD;&#xA;    				WS_VISIBLE | WS_POPUPWINDOW | WS_CAPTION, 100, 100, 300, 200,&#xD;&#xA;    				hwnd, 0, g_hinstance, 0))&#xD;&#xA;    			{&#xD;&#xA;    				DWORD err = GetLastError();&#xD;&#xA;    				wchar_t buf[100];&#xD;&#xA;    				wsprintf(buf, L""%d\\n"", err);&#xD;&#xA;    				MessageBox(0, buf, 0, 0);&#xD;&#xA;    			}&#xD;&#xA;    		}&#xD;&#xA;    		break;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	case WM_DESTROY:&#xD;&#xA;    		PostQuitMessage(0);&#xD;&#xA;    		return 0;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return DefWindowProc(hwnd, msg, wp, lp);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, LPTSTR, int)&#xD;&#xA;    {&#xD;&#xA;    	WNDCLASSEX wcex = { sizeof(WNDCLASSEX) };&#xD;&#xA;    	wcex.style = CS_HREDRAW | CS_VREDRAW;&#xD;&#xA;    	wcex.lpfnWndProc = WndProc;&#xD;&#xA;    	wcex.hInstance = hInstance;&#xD;&#xA;    	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);&#xD;&#xA;    	wcex.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);&#xD;&#xA;    	wcex.lpszClassName = L""MainClass"";&#xD;&#xA;    	RegisterClassEx(&wcex);&#xD;&#xA;    &#xD;&#xA;    	wcex.lpszClassName = L""ChildClass"";&#xD;&#xA;    	wcex.lpfnWndProc = ChildProc;&#xD;&#xA;    	RegisterClassEx(&wcex);&#xD;&#xA;    &#xD;&#xA;    	CreateWindow(L""MainClass"", L""MainTitle"", WS_VISIBLE | WS_OVERLAPPEDWINDOW,&#xD;&#xA;    		0, 0, 600, 400, 0, 0, hInstance, 0);&#xD;&#xA;    &#xD;&#xA;    	MSG msg;&#xD;&#xA;    	while (GetMessage(&msg, NULL, 0, 0))&#xD;&#xA;    	{&#xD;&#xA;    		TranslateMessage(&msg);&#xD;&#xA;    		DispatchMessage(&msg);&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return (int)msg.wParam;&#xD;&#xA;    }";;deleted 12 characters in body
