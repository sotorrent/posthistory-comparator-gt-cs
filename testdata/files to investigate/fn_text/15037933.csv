Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
36409159;15037933;1217178;2;a402e7eb-1987-47d1-8cab-26208366bc32;2013-02-23 06:44:08.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your code behave exactly as you requested:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that your code is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run your request handler multiple times in different threads at the same time. So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of its executor. The relevant part of the Docs is here: https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests (although doesn't really say anything more than what I put here, though).&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form **does not allow** you to create and use your own threads. So, the code you posted as a starting point is not supported. This, and the limit of 10 simultaneous threads that you mentioned, is a design-decision that allows Google to control the load on their servers (specifically the memory use of servlets) more easily.&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][1]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [2]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;
36409287;15037933;1217178;5;977cdac1-7a87-42a9-94bf-7e6ac7202593;2013-02-23 06:50:13.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your code behave exactly as you requested:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that your code is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run your request handler multiple times in different threads at the same time.&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of a separate thread. The relevant part of the Docs is here: https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests (although it doesn't really say much).&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form **does not allow** you to create and use **your own threads**. So, the code you posted as a starting point is actually not supported. This, and the limit of 10 simultaneous threads that you mentioned, is a design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][1]&#xD;&#xA; - [Dynamic Backend Instance Scaling][2]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [2]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;added 8 characters in body
36409438;15037933;1217178;5;c2f1020f-5868-4128-9aa4-68bd7d93931e;2013-02-23 06:58:57.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your servlets behave exactly as you want:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run your **all of your** request handlers multiple times in different threads at the same time (Note: It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!)&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of a separate thread. The relevant part of the Docs is here: https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests (although it doesn't really say much).&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form **does not allow** you to create and use **your own threads**. So, the code you posted as a starting point is actually not supported. This, and the limit of 10 simultaneous threads that you mentioned, is a design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][1]&#xD;&#xA; - [Dynamic Backend Instance Scaling][2]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [2]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;deleted 1 characters in body
36409625;15037933;1217178;5;beffdef4-5721-4811-b971-04dcde97ab61;2013-02-23 07:08:59.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your servlets behave exactly as you want:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run your **all of your** request handlers multiple times in different threads at the same time (Note: It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!)&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of a separate thread. The relevant part of the Docs is here: https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests (although it doesn't really say much).&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form **does not allow** you to create and use **your own threads** to accept requests. It only allows you to create threads **inside** your `doGet(...)` handler, using the `currentRequestThreadFactory()` method you mentioned, but only to do parallel processing for this one request and not to accept a second one in parallel (this happens *outside* `doGet()`).&#xD;&#xA;&#xD;&#xA;For frontend instances, any threads you create inside a `doGet()` call will get terminated immediately when your `doGet()` method returns. For backend instances, you are allowed to create threads that keep running, but since you are not allowed to open sockets for accepting requests inside these threads, these will still not help you with what you are looking for.&#xD;&#xA;&#xD;&#xA;You can find more details on what you *can* and *cannot* do inside an appengine servlet here:&#xD;&#xA;&#xD;&#xA;[The Java Servlet Environment - The Sandbox][1] (specifically the *Threads* section)&#xD;&#xA;&#xD;&#xA;BTW, the limit of 10 simultaneous servlet threads that you mentioned, is a design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][2]&#xD;&#xA; - [Dynamic Backend Instance Scaling][3]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][4]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://developers.google.com/appengine/docs/java/runtime#The_Sandbox&#xD;&#xA;  [2]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [4]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;added 743 characters in body
36409738;15037933;1217178;5;13e9f0ab-086c-4b52-b64a-33d135badd0f;2013-02-23 07:14:07.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your servlets behave exactly as you want:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run your **all of your** request handlers multiple times in different threads at the same time (Note: It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!)&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of a separate thread. The relevant part of the Docs is here: https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests (although it doesn't really say much).&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form **does not allow** you to create and use **your own threads** to accept requests. It only allows you to create threads **inside** your `doGet(...)` handler, using the `currentRequestThreadFactory()` method you mentioned, but only to do parallel processing for this one request and not to accept a second one in parallel (this happens *outside* `doGet()`).&#xD;&#xA;&#xD;&#xA;The name `currentRequestThreadFactory()` does not mean that it will return the `current` `Factory` of `RequestThreads`, i.e. threads that handle requests. It means that it returns a `Factory` that can create `Threads` inside the `currentRequest`. So, unfortunately it is actually not even allowed to use this ThreadFactory beyond the scope of the current `doGet()` execution, like you are doing by creating an Executor based on it and keeping it around in a class variable.&#xD;&#xA;&#xD;&#xA;For frontend instances, any threads you create inside a `doGet()` call will get terminated immediately when your `doGet()` method returns. For backend instances, you are allowed to create threads that keep running, but since you are not allowed to open sockets for accepting requests inside these threads, these will still not help you with what you are looking for.&#xD;&#xA;&#xD;&#xA;You can find more details on what you *can* and *cannot* do inside an appengine servlet here:&#xD;&#xA;&#xD;&#xA;[The Java Servlet Environment - The Sandbox][1] (specifically the *Threads* section)&#xD;&#xA;&#xD;&#xA;BTW, the limit of 10 simultaneous servlet threads that you mentioned, is a design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][2]&#xD;&#xA; - [Dynamic Backend Instance Scaling][3]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][4]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://developers.google.com/appengine/docs/java/runtime#The_Sandbox&#xD;&#xA;  [2]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [4]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;added 743 characters in body
36409897;15037933;1217178;5;fccc555f-b447-4e60-83f2-9be9503af3c9;2013-02-23 07:23:30.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your servlets behave exactly as you want:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run **all of your** request handlers multiple times in different threads at the same time (Note: It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!)&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of a separate thread.  Basically `doGet()` already **is** your `MyTask()`.&#xD;&#xA;&#xD;&#xA;The relevant part of the Docs is here (although it doesn't really say much): https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form **does not allow** you to create and use **your own threads** to accept requests. It only allows you to create threads **inside** your `doGet(...)` handler, using the `currentRequestThreadFactory()` method you mentioned, but only to do parallel processing for this one request and not to accept a second one in parallel (this happens *outside* `doGet()`).&#xD;&#xA;&#xD;&#xA;The name `currentRequestThreadFactory()` does not mean that it will return the `current` `Factory` of `RequestThreads`, i.e. threads that handle requests. It means that it returns a `Factory` that can create `Threads` inside the `currentRequest`. So, unfortunately it is actually not even allowed to use this ThreadFactory beyond the scope of the current `doGet()` execution, like you are doing by creating an Executor based on it and keeping it around in a class variable.&#xD;&#xA;&#xD;&#xA;For frontend instances, any threads you create inside a `doGet()` call will get terminated immediately when your `doGet()` method returns. For backend instances, you are allowed to create threads that keep running, but since you are not allowed to open sockets for accepting requests inside these threads, these will still not help you with what you are looking for.&#xD;&#xA;&#xD;&#xA;You can find more details on what you *can* and *cannot* do inside an appengine servlet here:&#xD;&#xA;&#xD;&#xA;[The Java Servlet Environment - The Sandbox][1] (specifically the *Threads* section)&#xD;&#xA;&#xD;&#xA;BTW, the limit of 10 simultaneous servlet threads that you mentioned, is a design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][2]&#xD;&#xA; - [Dynamic Backend Instance Scaling][3]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][4]&#xD;&#xA;&#xD;&#xA;*Aside:*&#xD;&#xA;&#xD;&#xA;This topic has been bugging the heck out of me, too, since I am a strong believer in ultra-lean servlet code, so my usual servlets could easily handle hundreds, if not thousands, of concurrent requests. Having to pay for more instances due to this arbitrary limit of 10 threads per instance is a little annoying to me to say the least. But reading over the links I posted above, it sounds like they are aware of this and are working on a better solution. So, let's see what announcements Google I/O 2013 will bring in May... :)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://developers.google.com/appengine/docs/java/runtime#The_Sandbox&#xD;&#xA;  [2]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [4]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;added 531 characters in body
36410022;15037933;1217178;5;f850ef68-7bd8-47cf-9c0c-afc760f1cf50;2013-02-23 07:30:25.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your servlets behave exactly as you want:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run **all of your** request handlers multiple times in different threads at the same time (Note: It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!)&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of a separate thread.  Basically `doGet()` already **is** your `MyTask()`.&#xD;&#xA;&#xD;&#xA;The relevant part of the Docs is here (although it doesn't really say much): https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form does not allow you to create and use your own threads to accept requests. It only allows you to create threads **inside** your `doGet(...)` handler, using the `currentRequestThreadFactory()` method you mentioned, but only to do parallel processing for this one request and not to accept a second one in parallel (this happens *outside* `doGet()`).&#xD;&#xA;&#xD;&#xA;The name `currentRequestThreadFactory()` does not mean that it will return the `current` `Factory` of `RequestThreads`, i.e. threads that handle requests. It means that it returns a `Factory` that can create `Threads` inside the `currentRequest`. So, unfortunately it is actually not even allowed to use this ThreadFactory beyond the scope of the current `doGet()` execution, like you are doing by creating an Executor based on it and keeping it around in a class variable.&#xD;&#xA;&#xD;&#xA;For frontend instances, any threads you create inside a `doGet()` call will get terminated immediately when your `doGet()` method returns. For backend instances, you are allowed to create threads that keep running, but since you are not allowed to open sockets for accepting requests inside these threads, these will still not allow you to manage the request handling yourself.&#xD;&#xA;&#xD;&#xA;You can find more details on what you *can* and *cannot* do inside an appengine servlet here:&#xD;&#xA;&#xD;&#xA;[The Java Servlet Environment - The Sandbox][1] (specifically the *Threads* section)&#xD;&#xA;&#xD;&#xA;BTW, the limit of 10 simultaneous servlet threads that you mentioned, is a design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][2]&#xD;&#xA; - [Dynamic Backend Instance Scaling][3]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][4]&#xD;&#xA;&#xD;&#xA;*Aside:*&#xD;&#xA;&#xD;&#xA;This topic has been bugging the heck out of me, too, since I am a strong believer in ultra-lean servlet code, so my usual servlets could easily handle hundreds, if not thousands, of concurrent requests. Having to pay for more instances due to this arbitrary limit of 10 threads per instance is a little annoying to me to say the least. But reading over the links I posted above, it sounds like they are aware of this and are working on a better solution. So, let's see what announcements Google I/O 2013 will bring in May... :)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://developers.google.com/appengine/docs/java/runtime#The_Sandbox&#xD;&#xA;  [2]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [4]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;added 11 characters in body
36410223;15037933;1217178;5;e1d9f7c4-74c2-4b97-b864-be8920963252;2013-02-23 07:39:47.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your servlets behave exactly as you want:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run **all** of your request handlers multiple times in different threads at the same time. Note: It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of a separate thread.  Basically `doGet()` already **is** your `MyTask()`.&#xD;&#xA;&#xD;&#xA;The relevant part of the Docs is here (although it doesn't really say much): https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form does not allow you to create and use your own threads to accept requests. It only allows you to create threads **inside** your `doGet(...)` handler, using the `currentRequestThreadFactory()` method you mentioned, but only to do parallel processing for this one request and not to accept a second one in parallel (this happens *outside* `doGet()`).&#xD;&#xA;&#xD;&#xA;The name `currentRequestThreadFactory()` does not mean that it will return the `current` `Factory` of `RequestThreads`, i.e. threads that handle requests. It means that it returns a `Factory` that can create `Threads` inside the `currentRequest`. So, unfortunately it is actually not even allowed to use this ThreadFactory beyond the scope of the current `doGet()` execution, like you are doing by creating an Executor based on it and keeping it around in a class variable.&#xD;&#xA;&#xD;&#xA;For frontend instances, any threads you create inside a `doGet()` call will get terminated immediately when your `doGet()` method returns. For backend instances, you are allowed to create threads that keep running, but since you are not allowed to open sockets for accepting requests inside these threads, these will still not allow you to manage the request handling yourself.&#xD;&#xA;&#xD;&#xA;You can find more details on what you *can* and *cannot* do inside an appengine servlet here:&#xD;&#xA;&#xD;&#xA;[The Java Servlet Environment - The Sandbox][1] (specifically the *Threads* section)&#xD;&#xA;&#xD;&#xA;BTW, the limit of 10 simultaneous servlet threads that you mentioned, is a design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][2]&#xD;&#xA; - [Dynamic Backend Instance Scaling][3]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][4]&#xD;&#xA;&#xD;&#xA;*Aside:*&#xD;&#xA;&#xD;&#xA;This topic has been bugging the heck out of me, too, since I am a strong believer in ultra-lean servlet code, so my usual servlets could easily handle hundreds, if not thousands, of concurrent requests. Having to pay for more instances due to this arbitrary limit of 10 threads per instance is a little annoying to me to say the least. But reading over the links I posted above, it sounds like they are aware of this and are working on a better solution. So, let's see what announcements Google I/O 2013 will bring in May... :)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://developers.google.com/appengine/docs/java/runtime#The_Sandbox&#xD;&#xA;  [2]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [4]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;deleted 1 characters in body
36410560;15037933;1217178;5;81d6d976-627d-4e01-80d4-9b811b9f62d3;2013-02-23 07:57:42.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your servlets behave exactly as you want:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run **all** of your request handlers multiple times in different threads at the same time. Note: It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of a separate thread.  Basically `doGet()` already **is** your `MyTask()`.&#xD;&#xA;&#xD;&#xA;The relevant part of the Docs is here (although it doesn't really say much): https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form does not allow you to create and use your own threads to accept requests. It only allows you to create threads **inside** your `doGet(...)` handler, using the `currentRequestThreadFactory()` method you mentioned, but only to do parallel processing for this one request and not to accept a second one in parallel (this happens *outside* `doGet()`).&#xD;&#xA;&#xD;&#xA;The name `currentRequestThreadFactory()` does not mean that it will return the `current` `Factory` of `RequestThreads`, i.e. threads that handle requests. It means that it returns a `Factory` that can create `Threads` inside the `currentRequest`. So, unfortunately it is actually not even allowed to use this ThreadFactory beyond the scope of the current `doGet()` execution, like you are doing by creating an Executor based on it and keeping it around in a class variable.&#xD;&#xA;&#xD;&#xA;For frontend instances, any threads you create inside a `doGet()` call will get terminated immediately when your `doGet()` method returns. For backend instances, you are allowed to create threads that keep running, but since you are not allowed to open sockets for accepting requests inside these threads, these will still not allow you to manage the request handling yourself.&#xD;&#xA;&#xD;&#xA;You can find more details on what you *can* and *cannot* do inside an appengine servlet here:&#xD;&#xA;&#xD;&#xA;[The Java Servlet Environment - The Sandbox][1] (specifically the *Threads* section)&#xD;&#xA;&#xD;&#xA;BTW, the limit of 10 simultaneous servlet threads that you mentioned, is a design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][2]&#xD;&#xA; - [Dynamic Backend Instance Scaling][3]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][4]&#xD;&#xA;&#xD;&#xA;*Aside:*&#xD;&#xA;&#xD;&#xA;This topic has been bugging the heck out of me, too, since I am a strong believer in ultra-lean servlet code, so my usual servlets could easily handle hundreds, if not thousands, of concurrent requests. Having to pay for more instances due to this arbitrary limit of 10 threads per instance is a little annoying to me to say the least. But reading over the links I posted above, it sounds like they are aware of this and are working on a better solution. So, let's see what announcements Google I/O 2013 will bring in May... :)&#xD;&#xA;&#xD;&#xA;**For completeness:**&#xD;&#xA;&#xD;&#xA;Since you asked for code based on your starting point, this should run, but it won't make a difference in terms of your code being able to handle multiple requests in parallel or not. That will be simply determined by the `<threadsafe>true</threadsafe>` in you appengine-web.xml.&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            ThreadFactory threadFactory = ThreadManager.currentRequestThreadFactory();&#xD;&#xA;            Executor executor = Executors.newCachedThreadPool(threadFactory);&#xD;&#xA;&#xD;&#xA;            MyResult result = executor.submit(new MyTask(request));&#xD;&#xA;&#xD;&#xA;            writeResponse(response, result.wait());&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;But, since you are already inside a separate thread that is specific to the request you are currently handling, you should save yourself the ""thread inside a thread"" that you would be creating, and simply do this instead:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            writeResponse(response, new MyTask(request).call());&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Or, even better, just move the code from MyTask.call into the doGet() method. ;)&#xD;&#xA;&#xD;&#xA;  [1]: https://developers.google.com/appengine/docs/java/runtime#The_Sandbox&#xD;&#xA;  [2]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [4]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;added 1122 characters in body
36441424;15037933;1217178;5;098ceef2-d66f-4f57-9a62-79453a63d8ff;2013-02-23 21:35:37.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your servlets behave exactly as you want:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run **all** of your request handlers multiple times in different threads at the same time. Note: It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of a separate thread.  Basically `doGet()` already **is** your `MyTask()`.&#xD;&#xA;&#xD;&#xA;The relevant part of the Docs is here (although it doesn't really say much): https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form does not allow you to create and use your own threads to accept requests. It only allows you to create threads **inside** your `doGet(...)` handler, using the `currentRequestThreadFactory()` method you mentioned, but only to do parallel processing for this one request and not to accept a second one in parallel (this happens *outside* `doGet()`).&#xD;&#xA;&#xD;&#xA;The name `currentRequestThreadFactory()` does not mean that it will return the `current` `Factory` of `RequestThreads`, i.e. threads that handle requests. It means that it returns a `Factory` that can create `Threads` inside the `currentRequest`. So, unfortunately it is actually not even allowed to use this ThreadFactory beyond the scope of the current `doGet()` execution, like you are doing by creating an Executor based on it and keeping it around in a class variable.&#xD;&#xA;&#xD;&#xA;For frontend instances, any threads you create inside a `doGet()` call will get terminated immediately when your `doGet()` method returns. For backend instances, you are allowed to create threads that keep running, but since you are not allowed to open sockets for accepting requests inside these threads, these will still not allow you to manage the request handling yourself.&#xD;&#xA;&#xD;&#xA;You can find more details on what you *can* and *cannot* do inside an appengine servlet here:&#xD;&#xA;&#xD;&#xA;[The Java Servlet Environment - The Sandbox][1] (specifically the *Threads* section)&#xD;&#xA;&#xD;&#xA;BTW, the limit of 10 simultaneous servlet threads that you mentioned, is a design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][2]&#xD;&#xA; - [Dynamic Backend Instance Scaling][3]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][4]&#xD;&#xA;&#xD;&#xA;*Aside:*&#xD;&#xA;&#xD;&#xA;This topic has been bugging the heck out of me, too, since I am a strong believer in ultra-lean servlet code, so my usual servlets could easily handle hundreds, if not thousands, of concurrent requests. Having to pay for more instances due to this arbitrary limit of 10 threads per instance is a little annoying to me to say the least. But reading over the links I posted above, it sounds like they are aware of this and are working on a better solution. So, let's see what announcements Google I/O 2013 will bring in May... :)&#xD;&#xA;&#xD;&#xA;**For completeness:**&#xD;&#xA;&#xD;&#xA;Since you are looking for a code example based on your starting point:&#xD;&#xA;&#xD;&#xA;The following should work, but it won't make a difference in terms of your code being able to handle multiple requests in parallel. That will be determined only by the `<threadsafe>true</threadsafe>` setting in you appengine-web.xml. So, technically, this code is just really inefficient and splits an essentially linear program flow across two threads. But here it is anyways:&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            ThreadFactory threadFactory = ThreadManager.currentRequestThreadFactory();&#xD;&#xA;            Executor executor = Executors.newCachedThreadPool(threadFactory);&#xD;&#xA;&#xD;&#xA;            MyResult result = executor.submit(new MyTask(request));&#xD;&#xA;&#xD;&#xA;            writeResponse(response, result.wait());&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Since you are already inside a separate thread that is specific to the request you are currently handling, you should definitely save yourself the ""thread inside a thread"" and simply do this instead:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            writeResponse(response, new MyTask(request).call());&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Or, even better, just move the code from MyTask.call into the doGet() method. ;)&#xD;&#xA;&#xD;&#xA;  [1]: https://developers.google.com/appengine/docs/java/runtime#The_Sandbox&#xD;&#xA;  [2]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [4]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;added 150 characters in body
36441583;15037933;1217178;5;a633854f-d819-4404-8579-11a56041add7;2013-02-23 21:41:13.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your servlets behave exactly as you want:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run **all** of your request handlers multiple times in different threads at the same time. Note: It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of a separate thread.  Basically `doGet()` already **is** your `MyTask()`.&#xD;&#xA;&#xD;&#xA;The relevant part of the Docs is here (although it doesn't really say much): https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form does not allow you to create and use your own threads to accept requests. It only allows you to create threads **inside** your `doGet(...)` handler, using the `currentRequestThreadFactory()` method you mentioned, but only to do parallel processing for this one request and not to accept a second one in parallel (this happens *outside* `doGet()`).&#xD;&#xA;&#xD;&#xA;The name `currentRequestThreadFactory()` does not mean that it will return the `current` `Factory` of `RequestThreads`, i.e. threads that handle requests. It means that it returns a `Factory` that can create `Threads` inside the `currentRequest`. So, unfortunately it is actually not even allowed to use this ThreadFactory beyond the scope of the current `doGet()` execution, like you are doing by creating an Executor based on it and keeping it around in a class variable.&#xD;&#xA;&#xD;&#xA;For frontend instances, any threads you create inside a `doGet()` call will get terminated immediately when your `doGet()` method returns. For backend instances, you are allowed to create threads that keep running, but since you are not allowed to open sockets for accepting requests inside these threads, these will still not allow you to manage the request handling yourself.&#xD;&#xA;&#xD;&#xA;You can find more details on what you *can* and *cannot* do inside an appengine servlet here:&#xD;&#xA;&#xD;&#xA;[The Java Servlet Environment - The Sandbox][1] (specifically the *Threads* section)&#xD;&#xA;&#xD;&#xA;BTW, the limit of 10 simultaneous servlet threads that you mentioned, is a design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][2]&#xD;&#xA; - [Dynamic Backend Instance Scaling][3]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][4]&#xD;&#xA;&#xD;&#xA;*Aside:*&#xD;&#xA;&#xD;&#xA;This topic has been bugging the heck out of me, too, since I am a strong believer in ultra-lean servlet code, so my usual servlets could easily handle hundreds, if not thousands, of concurrent requests. Having to pay for more instances due to this arbitrary limit of 10 threads per instance is a little annoying to me to say the least. But reading over the links I posted above, it sounds like they are aware of this and are working on a better solution. So, let's see what announcements Google I/O 2013 will bring in May... :)&#xD;&#xA;&#xD;&#xA;**For completeness:**&#xD;&#xA;&#xD;&#xA;Since you are looking for a code example based on your starting point:&#xD;&#xA;&#xD;&#xA;The following should work, but it won't make a difference in terms of your code being able to handle multiple requests in parallel. That will be determined only by the `<threadsafe>true</threadsafe>` setting in you appengine-web.xml. So, technically, this code is just really inefficient and splits an essentially linear program flow across two threads. But here it is anyways:&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            ThreadFactory threadFactory = ThreadManager.currentRequestThreadFactory();&#xD;&#xA;            Executor executor = Executors.newCachedThreadPool(threadFactory);&#xD;&#xA;&#xD;&#xA;            Future<MyResult> result = executor.submit(new MyTask(request));&#xD;&#xA;&#xD;&#xA;            writeResponse(response, result.get());&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Since you are already inside a separate thread that is specific to the request you are currently handling, you should definitely save yourself the ""thread inside a thread"" and simply do this instead:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            writeResponse(response, new MyTask(request).call());&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Or, even better, just move the code from MyTask.call into the doGet() method. ;)&#xD;&#xA;&#xD;&#xA;  [1]: https://developers.google.com/appengine/docs/java/runtime#The_Sandbox&#xD;&#xA;  [2]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [4]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;deleted 1 characters in body
36445479;15037933;1217178;5;b00c0d48-92cb-4a54-b65f-f072af139630;2013-02-24 00:44:18.0;"The good news is: This is VERY easy to achieve.&#xD;&#xA;&#xD;&#xA;The bad news is: This is VERY easy to achieve (and anything more complicated is disallowed).&#xD;&#xA;&#xD;&#xA;**First to the good news:**&#xD;&#xA;&#xD;&#xA;You need to do only two things to make your servlets behave exactly as you want:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)` method or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;Done. This will tell the appengine server that your code is thread-safe and that you are allowing it to run **all** of your request handlers multiple times in different threads at the same time. Note: It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the AppEngine server, and actually calls your `doGet(...)` method from inside the run method of a separate thread.  Basically `doGet()` already **is** your `MyTask()`.&#xD;&#xA;&#xD;&#xA;The relevant part of the Docs is here (although it doesn't really say much): https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests&#xD;&#xA;&#xD;&#xA;**Now to the bad news:**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form does not allow you to create and use your own threads to accept requests. It only allows you to create threads **inside** your `doGet(...)` handler, using the `currentRequestThreadFactory()` method you mentioned, but only to do parallel processing for this one request and not to accept a second one in parallel (this happens *outside* `doGet()`).&#xD;&#xA;&#xD;&#xA;The name `currentRequestThreadFactory()` does not mean that it will return the `current` `Factory` of `RequestThreads`, i.e. threads that handle requests. It means that it returns a `Factory` that can create `Threads` inside the `currentRequest`. So, unfortunately it is actually not even allowed to use this ThreadFactory beyond the scope of the current `doGet()` execution, like you are doing by creating an Executor based on it and keeping it around in a class variable.&#xD;&#xA;&#xD;&#xA;For frontend instances, any threads you create inside a `doGet()` call will get terminated immediately when your `doGet()` method returns. For backend instances, you are allowed to create threads that keep running, but since you are not allowed to open sockets for accepting requests inside these threads, these will still not allow you to manage the request handling yourself.&#xD;&#xA;&#xD;&#xA;You can find more details on what you *can* and *cannot* do inside an appengine servlet here:&#xD;&#xA;&#xD;&#xA;[The Java Servlet Environment - The Sandbox][1] (specifically the *Threads* section)&#xD;&#xA;&#xD;&#xA;BTW, the limit of 10 simultaneous servlet threads that you mentioned, is a design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][2]&#xD;&#xA; - [Dynamic Backend Instance Scaling][3]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][4]&#xD;&#xA;&#xD;&#xA;*Aside:*&#xD;&#xA;&#xD;&#xA;This topic has been bugging the heck out of me, too, since I am a strong believer in ultra-lean servlet code, so my usual servlets could easily handle hundreds, if not thousands, of concurrent requests. Having to pay for more instances due to this arbitrary limit of 10 threads per instance is a little annoying to me to say the least. But reading over the links I posted above, it sounds like they are aware of this and are working on a better solution. So, let's see what announcements Google I/O 2013 will bring in May... :)&#xD;&#xA;&#xD;&#xA;**For completeness:**&#xD;&#xA;&#xD;&#xA;Since you are looking for a code example based on your starting point:&#xD;&#xA;&#xD;&#xA;The following should work, but it won't make a difference in terms of your code being able to handle multiple requests in parallel. That will be determined solely by the `<threadsafe>true</threadsafe>` setting in you appengine-web.xml. So, technically, this code is just really inefficient and splits an essentially linear program flow across two threads. But here it is anyways:&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            ThreadFactory threadFactory = ThreadManager.currentRequestThreadFactory();&#xD;&#xA;            Executor executor = Executors.newCachedThreadPool(threadFactory);&#xD;&#xA;&#xD;&#xA;            Future<MyResult> result = executor.submit(new MyTask(request)); // Fires off request handling in a separate thread&#xD;&#xA;&#xD;&#xA;            writeResponse(response, result.get()); // Waits for thread to complete and builds response. After that, doGet() returns&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Since you are already inside a separate thread that is specific to the request you are currently handling, you should definitely save yourself the ""thread inside a thread"" and simply do this instead:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            writeResponse(response, new MyTask(request).call()); // Delegate request handling to MyTask object in current thread and write out returned response&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Or, even better, just move the code from MyTask.call into the doGet() method. ;)&#xD;&#xA;&#xD;&#xA;  [1]: https://developers.google.com/appengine/docs/java/runtime#The_Sandbox&#xD;&#xA;  [2]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [4]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;added 230 characters in body
36587876;15037933;1217178;5;465a3b4e-51eb-4886-9c10-07d8bfdbe7af;2013-02-26 21:04:58.0;"You implicitly asked two questions, so let me answer both:&#xD;&#xA;&#xD;&#xA;**1. How can I get my AppEngine Instance to handle multiple concurrent requests?**&#xD;&#xA;&#xD;&#xA;You really only need to do two things:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside **all** your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)`, `doPost(...)`, etc. methods or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;This will tell the AppEngine instance server framework that your code is thread-safe and that you are allowing it to call **all** of your request handlers multiple times in different threads to handle several requests the same time. Note: AFAIK, It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the server code of each AppEngine instance, and actually calls your `doGet(...)` method from inside the run method of a separate thread that AppEngine creates (or reuses) for each request.  Basically `doGet()` already **is** your `MyTask()`.&#xD;&#xA;&#xD;&#xA;The relevant part of the Docs is here (although it doesn't really say much): https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests&#xD;&#xA;&#xD;&#xA;**2. Is the posted code useful for this (or any other) purpose?**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form does not allow you to create and use your own threads to accept requests. It only allows you to create threads **inside** your `doGet(...)` handler, using the `currentRequestThreadFactory()` method you mentioned, but only to do parallel processing for this one request and not to accept a second one in parallel (this happens *outside* `doGet()`).&#xD;&#xA;&#xD;&#xA;The name `currentRequestThreadFactory()` might be a little misleading here. It does not mean that it will return the `current` `Factory` of `RequestThreads`, i.e. threads that handle requests. It means that it returns a `Factory` that can create `Threads` inside the `currentRequest`. So, unfortunately it is actually not even allowed to use the returned ThreadFactory beyond the scope of the current `doGet()` execution, like you are suggesting by creating an Executor based on it and keeping it around in a class variable.&#xD;&#xA;&#xD;&#xA;For frontend instances, any threads you create inside a `doGet()` call will get terminated immediately when your `doGet()` method returns. For backend instances, you are allowed to create threads that keep running, but since you are not allowed to open server sockets for accepting requests inside these threads, these will still not allow you to manage the request handling yourself.&#xD;&#xA;&#xD;&#xA;You can find more details on what you *can* and *cannot* do inside an appengine servlet here:&#xD;&#xA;&#xD;&#xA;[The Java Servlet Environment - The Sandbox][1] (specifically the *Threads* section)&#xD;&#xA;&#xD;&#xA;***For completeness, let's see how your code can be made ""legal"":***&#xD;&#xA;&#xD;&#xA;The following should work, but it won't make a difference in terms of your code being able to handle multiple requests in parallel. That will be determined solely by the `<threadsafe>true</threadsafe>` setting in you appengine-web.xml. So, technically, this code is just really inefficient and splits an essentially linear program flow across two threads. But here it is anyways:&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            ThreadFactory threadFactory = ThreadManager.currentRequestThreadFactory();&#xD;&#xA;            Executor executor = Executors.newCachedThreadPool(threadFactory);&#xD;&#xA;&#xD;&#xA;            Future<MyResult> result = executor.submit(new MyTask(request)); // Fires off request handling in a separate thread&#xD;&#xA;&#xD;&#xA;            writeResponse(response, result.get()); // Waits for thread to complete and builds response. After that, doGet() returns&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Since you are already inside a separate thread that is specific to the request you are currently handling, you should definitely save yourself the ""thread inside a thread"" and simply do this instead:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            writeResponse(response, new MyTask(request).call()); // Delegate request handling to MyTask object in current thread and write out returned response&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Or, even better, just move the code from MyTask.call into the doGet() method. ;)&#xD;&#xA;&#xD;&#xA;**Aside - Regarding the limit of 10 simultaneous servlet threads you mentioned:**&#xD;&#xA;&#xD;&#xA;This is a (temporary) design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][2]&#xD;&#xA; - [Dynamic Backend Instance Scaling][3]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][4]&#xD;&#xA;&#xD;&#xA;This topic has been bugging the heck out of me, too, since I am a strong believer in ultra-lean servlet code, so my usual servlets could easily handle hundreds, if not thousands, of concurrent requests. Having to pay for more instances due to this arbitrary limit of 10 threads per instance is a little annoying to me to say the least. But reading over the links I posted above, it sounds like they are aware of this and are working on a better solution. So, let's see what announcements Google I/O 2013 will bring in May... :)&#xD;&#xA;&#xD;&#xA;  [1]: https://developers.google.com/appengine/docs/java/runtime#The_Sandbox&#xD;&#xA;  [2]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [4]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;added 176 characters in body
36588234;15037933;1217178;5;a44b8cec-1dd9-4f0d-9a56-fd35982ef28f;2013-02-26 21:13:02.0;"You implicitly asked two questions, so let me answer both:&#xD;&#xA;&#xD;&#xA;**1. How can I get my AppEngine Instance to handle multiple concurrent requests?**&#xD;&#xA;&#xD;&#xA;You really only need to do two things:&#xD;&#xA;&#xD;&#xA; 1. Add the statement `<threadsafe>true</threadsafe>` to your `appengine-web.xml` file, which you can find in the `war\\WEB-INF` folder.&#xD;&#xA; 2. Make sure that the code inside **all** your request handlers is actually thread-safe, i.e. use only local variables in your `doGet(...)`, `doPost(...)`, etc. methods or make sure you synchronize all access to class or global variables.&#xD;&#xA;&#xD;&#xA;This will tell the AppEngine instance server framework that your code is thread-safe and that you are allowing it to call **all** of your request handlers multiple times in different threads to handle several requests at the same time. Note: AFAIK, It is not possible to set this one a per-servlet basis. So, **ALL** your servlets need to be thread-safe!&#xD;&#xA;&#xD;&#xA;So, in essence, the executor-code you posted is already included in the server code of each AppEngine instance, and actually calls your `doGet(...)` method from inside the run method of a separate thread that AppEngine creates (or reuses) for each request.  Basically `doGet()` already *is* your `MyTask()`.&#xD;&#xA;&#xD;&#xA;The relevant part of the Docs is here (although it doesn't really say much): https://developers.google.com/appengine/docs/java/config/appconfig#Using_Concurrent_Requests&#xD;&#xA;&#xD;&#xA;**2. Is the posted code useful for this (or any other) purpose?**&#xD;&#xA;&#xD;&#xA;AppEngine in its current form does not allow you to create and use your own threads to accept requests. It only allows you to create threads *inside* your `doGet(...)` handler, using the `currentRequestThreadFactory()` method you mentioned, but only to do parallel processing for this one request and not to accept a second one in parallel (this happens *outside* `doGet()`).&#xD;&#xA;&#xD;&#xA;The name `currentRequestThreadFactory()` might be a little misleading here. It does not mean that it will return the `current` `Factory` of `RequestThreads`, i.e. threads that handle requests. It means that it returns a `Factory` that can create `Threads` inside the `currentRequest`. So, unfortunately it is actually not even allowed to use the returned ThreadFactory beyond the scope of the current `doGet()` execution, like you are suggesting by creating an Executor based on it and keeping it around in a class variable.&#xD;&#xA;&#xD;&#xA;For frontend instances, any threads you create inside a `doGet()` call will get terminated immediately when your `doGet()` method returns. For backend instances, you are allowed to create threads that keep running, but since you are not allowed to open server sockets for accepting requests inside these threads, these will still not allow you to manage the request handling yourself.&#xD;&#xA;&#xD;&#xA;You can find more details on what you *can* and *cannot* do inside an appengine servlet here:&#xD;&#xA;&#xD;&#xA;[The Java Servlet Environment - The Sandbox][1] (specifically the *Threads* section)&#xD;&#xA;&#xD;&#xA;***For completeness, let's see how your code can be made ""legal"":***&#xD;&#xA;&#xD;&#xA;The following should work, but it won't make a difference in terms of your code being able to handle multiple requests in parallel. That will be determined solely by the `<threadsafe>true</threadsafe>` setting in you appengine-web.xml. So, technically, this code is just really inefficient and splits an essentially linear program flow across two threads. But here it is anyways:&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            ThreadFactory threadFactory = ThreadManager.currentRequestThreadFactory();&#xD;&#xA;            Executor executor = Executors.newCachedThreadPool(threadFactory);&#xD;&#xA;&#xD;&#xA;            Future<MyResult> result = executor.submit(new MyTask(request)); // Fires off request handling in a separate thread&#xD;&#xA;&#xD;&#xA;            writeResponse(response, result.get()); // Waits for thread to complete and builds response. After that, doGet() returns&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Since you are already inside a separate thread that is specific to the request you are currently handling, you should definitely save yourself the ""thread inside a thread"" and simply do this instead:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public class MyServlet implements HttpServlet {&#xD;&#xA;&#xD;&#xA;        @Override&#xD;&#xA;        public void doGet(HttpServletRequest request, HttpServletResponse response) {&#xD;&#xA;            writeResponse(response, new MyTask(request).call()); // Delegate request handling to MyTask object in current thread and write out returned response&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Or, even better, just move the code from MyTask.call() into the doGet() method. ;)&#xD;&#xA;&#xD;&#xA;**Aside - Regarding the limit of 10 simultaneous servlet threads you mentioned:**&#xD;&#xA;&#xD;&#xA;This is a (temporary) design-decision that allows Google to control the load on their servers more easily (specifically the memory use of servlets).&#xD;&#xA;&#xD;&#xA;You can find more discussion on those issues here:&#xD;&#xA;&#xD;&#xA; - [Issue 7927:	Allow configurable limit of concurrent requests per instance][2]&#xD;&#xA; - [Dynamic Backend Instance Scaling][3]&#xD;&#xA; - [If your bill shoots up due to increased latency, you may not be refunded the charges incurred][4]&#xD;&#xA;&#xD;&#xA;This topic has been bugging the heck out of me, too, since I am a strong believer in ultra-lean servlet code, so my usual servlets could easily handle hundreds, if not thousands, of concurrent requests. Having to pay for more instances due to this arbitrary limit of 10 threads per instance is a little annoying to me to say the least. But reading over the links I posted above, it sounds like they are aware of this and are working on a better solution. So, let's see what announcements Google I/O 2013 will bring in May... :)&#xD;&#xA;&#xD;&#xA;  [1]: https://developers.google.com/appengine/docs/java/runtime#The_Sandbox&#xD;&#xA;  [2]: http://code.google.com/p/googleappengine/issues/detail?id=7927&#xD;&#xA;  [3]: https://groups.google.com/forum/#!msg/google-appengine/Wvco3AQR-AM/N1Y7S2HfukkJ&#xD;&#xA;  [4]: https://groups.google.com/forum/#!msg/google-appengine/y-LnZ2WYJ5Q/j_w13F4oSSkJ";;added 1 characters in body
