Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
55067121;20965995;2246121;2;5123c487-5991-4271-998b-9191281cbe3b;2014-01-07 07:14:11.0;"1. How do you setup your camera? What might be causing the long execution time in the first `saveBitmap` call, could be that you are using the default camera picture size settings and not reading the supported camera picture size and choosing best fit for your 1024x768 image needs. You might be taking big mpixel images and saving such, but in the end need you need < 1 mpixles (1024x768). Something like this in code:&#xD;&#xA;&#xD;&#xA; <code>&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;Camera camera = Camera.open();  &#xD;&#xA;Parameters params = camera.getParameters();  &#xD;&#xA;List<Camera.Size> sizes = params.getSupportedPictureSizes();  &#xD;&#xA;// Loop camera sizes and find best match, larger than 1024x768</code>&#xD;&#xA;&#xD;&#xA; **This is probably where you will save most of the time if you are not doing this already. And do it only once, during some initialization phase.**&#xD;&#xA;&#xD;&#xA;2. Increase the buffer to `8k` in `saveBitmap`, change the `1024*4` to `1024*8`, this would increase the performance at least, not save any significant time perhaps.&#xD;&#xA;&#xD;&#xA;3. To save/reuse bitmap memory consider using `inBitmap` field of `BitmapFactory.Options` and set that field to point to `bitmapRotate` bitmap and send options down to your `convertToGrayscale` method to not need allocating yet another bitmap down in that method. Read about `inBitmap` here: [inBitmap][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://developer.android.com/training/displaying-bitmaps/manage-memory.html#inBitmap";;
55148376;20965995;2246121;5;7397520e-aefa-4595-b934-74be30ab44d4;2014-01-08 06:24:50.0;"1. How do you setup your camera? What might be causing the long execution time in the first `saveBitmap` call, could be that you are using the default camera picture size settings and not reading the supported camera picture size and choosing best fit for your 1024x768 image needs. You might be taking big mpixel images and saving such, but in the end need you need < 1 mpixles (1024x768). Something like this in code:&#xD;&#xA;&#xD;&#xA; <code>&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;Camera camera = Camera.open();  &#xD;&#xA;Parameters params = camera.getParameters();  &#xD;&#xA;List<Camera.Size> sizes = params.getSupportedPictureSizes();  &#xD;&#xA;// Loop camera sizes and find best match, larger than 1024x768</code>&#xD;&#xA;&#xD;&#xA; **This is probably where you will save most of the time if you are not doing this already. And do it only once, during some initialization phase.**&#xD;&#xA;&#xD;&#xA;2. Increase the buffer to `8k` in `saveBitmap`, change the `1024*4` to `1024*8`, this would increase the performance at least, not save any significant time perhaps.&#xD;&#xA;&#xD;&#xA;3. To save/reuse bitmap memory consider using `inBitmap` field, **if you have a post honeycomb version**, of `BitmapFactory.Options` and set that field to point to `bitmapRotate` bitmap and send options down to your `convertToGrayscale` method to not need allocating yet another bitmap down in that method. Read about `inBitmap` here: [inBitmap][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://developer.android.com/training/displaying-bitmaps/manage-memory.html#inBitmap";;added 43 characters in body
55149085;20965995;2246121;5;58d152d9-5a5c-4568-b0d6-33592099fd6a;2014-01-08 06:37:17.0;"**Update**:&#xD;&#xA;Since you're still saying that the method takes too long time I would define a callback interface&#xD;&#xA;&#xD;&#xA;    interface BitmapCallback {&#xD;&#xA;        onBitmapSaveComplete(Bitmap bitmap, int orientation);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Let your activity implement the above interface and convert the `byte[]` to bitmap in top of your `saveBitmap` method and fire the callback, before the first call to save. Rotate the `imageView` based on the orientation parameter and set a black/white filter on the `imageView` to *fool* the user into thinking that the bitmap is black and white (do this in your activity). See to that the calls are done on main thread (the calls to `imageView`). **Keep your old method as you have it.**&#xD;&#xA;&#xD;&#xA;1. How do you setup your camera? What might be causing the long execution time in the first `saveBitmap` call, could be that you are using the default camera picture size settings and not reading the supported camera picture size and choosing best fit for your 1024x768 image needs. You might be taking big mpixel images and saving such, but in the end need you need < 1 mpixles (1024x768). Something like this in code:&#xD;&#xA;&#xD;&#xA; <code>&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;Camera camera = Camera.open();  &#xD;&#xA;Parameters params = camera.getParameters();  &#xD;&#xA;List<Camera.Size> sizes = params.getSupportedPictureSizes();  &#xD;&#xA;// Loop camera sizes and find best match, larger than 1024x768</code>&#xD;&#xA;&#xD;&#xA; **This is probably where you will save most of the time if you are not doing this already. And do it only once, during some initialization phase.**&#xD;&#xA;&#xD;&#xA;2. Increase the buffer to `8k` in `saveBitmap`, change the `1024*4` to `1024*8`, this would increase the performance at least, not save any significant time perhaps.&#xD;&#xA;&#xD;&#xA;3. To save/reuse bitmap memory consider using `inBitmap` field, **if you have a post honeycomb version**, of `BitmapFactory.Options` and set that field to point to `bitmapRotate` bitmap and send options down to your `convertToGrayscale` method to not need allocating yet another bitmap down in that method. Read about `inBitmap` here: [inBitmap][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://developer.android.com/training/displaying-bitmaps/manage-memory.html#inBitmap";;added 43 characters in body
55149571;20965995;2246121;5;901b6b7c-8494-4849-a5b0-d9c17179fee7;2014-01-08 06:43:58.0;"**Update**:&#xD;&#xA;Since you're still saying that the method takes too long time I would define a callback interface&#xD;&#xA;&#xD;&#xA;    interface BitmapCallback {&#xD;&#xA;        onBitmapSaveComplete(Bitmap bitmap, int orientation);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Let your activity implement the above interface and convert the `byte[]` to bitmap in top of your `saveBitmap` method and fire the callback, before the first call to save. Rotate the `imageView` based on the orientation parameter and set a black/white filter on the `imageView` to *fool* the user into thinking that the bitmap is black and white (do this in your activity). See to that the calls are done on main thread (the calls to `imageView`). **Keep your old method as you have it. (all steps need to be done anyway)**&#xD;&#xA;&#xD;&#xA;1. How do you setup your camera? What might be causing the long execution time in the first `saveBitmap` call, could be that you are using the default camera picture size settings and not reading the supported camera picture size and choosing best fit for your 1024x768 image needs. You might be taking big mpixel images and saving such, but in the end need you need < 1 mpixles (1024x768). Something like this in code:&#xD;&#xA;&#xD;&#xA; <code>&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;Camera camera = Camera.open();  &#xD;&#xA;Parameters params = camera.getParameters();  &#xD;&#xA;List<Camera.Size> sizes = params.getSupportedPictureSizes();  &#xD;&#xA;// Loop camera sizes and find best match, larger than 1024x768</code>&#xD;&#xA;&#xD;&#xA; **This is probably where you will save most of the time if you are not doing this already. And do it only once, during some initialization phase.**&#xD;&#xA;&#xD;&#xA;2. Increase the buffer to `8k` in `saveBitmap`, change the `1024*4` to `1024*8`, this would increase the performance at least, not save any significant time perhaps.&#xD;&#xA;&#xD;&#xA;3. To save/reuse bitmap memory consider using `inBitmap` field, **if you have a post honeycomb version**, of `BitmapFactory.Options` and set that field to point to `bitmapRotate` bitmap and send options down to your `convertToGrayscale` method to not need allocating yet another bitmap down in that method. Read about `inBitmap` here: [inBitmap][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://developer.android.com/training/displaying-bitmaps/manage-memory.html#inBitmap";;added 35 characters in body
55150122;20965995;2246121;5;7b2d2f43-111c-49e5-abb4-c2f69a451493;2014-01-08 06:53:23.0;"**Update**:&#xD;&#xA;Since you're still saying that the method takes too long time I would define a callback interface&#xD;&#xA;&#xD;&#xA;    interface BitmapCallback {&#xD;&#xA;        onBitmapSaveComplete(Bitmap bitmap, int orientation);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Let your activity implement the above interface and convert the `byte[]` to bitmap in top of your `saveBitmap` method and fire the callback, before the first call to save. Rotate the `imageView` based on the orientation parameter and set a black/white filter on the `imageView` to *fool* the user into thinking that the bitmap is black and white (do this in your activity). See to that the calls are done on main thread (the calls to `imageView`). **Keep your old method as you have it. (all steps need to be done anyway)** Something like:&#xD;&#xA;&#xD;&#xA;    public static boolean saveBitmap(byte[] bitmapData, int orientation, String imagePath, String grayScalePath, BitmapCallback callback) throws Exception {&#xD;&#xA;    Boolean rotationSuccess = false;&#xD;&#xA;    BitmapFactory.Options options = new BitmapFactory.Options();&#xD;&#xA;    options.inPreferredConfig = Bitmap.Config.ARGB_8888;&#xD;&#xA;    Bitmap originalBm = null;&#xD;&#xA;    Bitmap bitmapRotate = null;&#xD;&#xA;    Bitmap grayScale = null;&#xD;&#xA;    FileOutputStream outStream = null;&#xD;&#xA;    try {&#xD;&#xA;        // convert byte to Bitmap, see to that the image is not larger than your wanted size (1024z768)&#xD;&#xA;        callback.onBitmapSaveComplete(bitmap, orientation);&#xD;&#xA;&#xD;&#xA;        // save directly from byte[] to file&#xD;&#xA;        saveBitmap(bitmapData, imagePath);&#xD;&#xA;        &#xD;&#xA;        // same as old &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;1. How do you setup your camera? What might be causing the long execution time in the first `saveBitmap` call, could be that you are using the default camera picture size settings and not reading the supported camera picture size and choosing best fit for your 1024x768 image needs. You might be taking big mpixel images and saving such, but in the end need you need < 1 mpixles (1024x768). Something like this in code:&#xD;&#xA;&#xD;&#xA; <code>&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;Camera camera = Camera.open();  &#xD;&#xA;Parameters params = camera.getParameters();  &#xD;&#xA;List<Camera.Size> sizes = params.getSupportedPictureSizes();  &#xD;&#xA;// Loop camera sizes and find best match, larger than 1024x768</code>&#xD;&#xA;&#xD;&#xA; **This is probably where you will save most of the time if you are not doing this already. And do it only once, during some initialization phase.**&#xD;&#xA;&#xD;&#xA;2. Increase the buffer to `8k` in `saveBitmap`, change the `1024*4` to `1024*8`, this would increase the performance at least, not save any significant time perhaps.&#xD;&#xA;&#xD;&#xA;3. To save/reuse bitmap memory consider using `inBitmap` field, **if you have a post honeycomb version**, of `BitmapFactory.Options` and set that field to point to `bitmapRotate` bitmap and send options down to your `convertToGrayscale` method to not need allocating yet another bitmap down in that method. Read about `inBitmap` here: [inBitmap][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://developer.android.com/training/displaying-bitmaps/manage-memory.html#inBitmap";;added 35 characters in body
55193268;20965995;2246121;5;cec4307c-0be1-4966-94ef-a0910c4f88d7;2014-01-08 16:17:50.0;"**Update**:&#xD;&#xA;Since you're still saying that the method takes too long time I would define a callback interface&#xD;&#xA;&#xD;&#xA;    interface BitmapCallback {&#xD;&#xA;        onBitmapSaveComplete(Bitmap bitmap, int orientation);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Let your activity implement the above interface and convert the `byte[]` to bitmap in top of your `saveBitmap` method and fire the callback, before the first call to save. Rotate the `imageView` based on the orientation parameter and set a black/white filter on the `imageView` to *fool* the user into thinking that the bitmap is black and white (do this in your activity). See to that the calls are done on main thread (the calls to `imageView`). **Keep your old method as you have it. (all steps need to be done anyway)** Something like:&#xD;&#xA;&#xD;&#xA;    public static boolean saveBitmap(byte[] bitmapData, int orientation, String imagePath, String grayScalePath, BitmapCallback callback) throws Exception {&#xD;&#xA;    Boolean rotationSuccess = false;&#xD;&#xA;    BitmapFactory.Options options = new BitmapFactory.Options();&#xD;&#xA;    options.inPreferredConfig = Bitmap.Config.ARGB_8888;&#xD;&#xA;    Bitmap originalBm = null;&#xD;&#xA;    Bitmap bitmapRotate = null;&#xD;&#xA;    Bitmap grayScale = null;&#xD;&#xA;    FileOutputStream outStream = null;&#xD;&#xA;    try {&#xD;&#xA;        // TODO: convert byte to Bitmap, see to that the image is not larger than your wanted size (1024z768)&#xD;&#xA;        callback.onBitmapSaveComplete(bitmap, orientation);&#xD;&#xA;&#xD;&#xA;        // save directly from byte[] to file&#xD;&#xA;        saveBitmap(bitmapData, imagePath);&#xD;&#xA;        &#xD;&#xA;        // same as old &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;1. How do you setup your camera? What might be causing the long execution time in the first `saveBitmap` call, could be that you are using the default camera picture size settings and not reading the supported camera picture size and choosing best fit for your 1024x768 image needs. You might be taking big mpixel images and saving such, but in the end need you need < 1 mpixles (1024x768). Something like this in code:&#xD;&#xA;&#xD;&#xA; <code>&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;Camera camera = Camera.open();  &#xD;&#xA;Parameters params = camera.getParameters();  &#xD;&#xA;List<Camera.Size> sizes = params.getSupportedPictureSizes();  &#xD;&#xA;// Loop camera sizes and find best match, larger than 1024x768</code>&#xD;&#xA;&#xD;&#xA; **This is probably where you will save most of the time if you are not doing this already. And do it only once, during some initialization phase.**&#xD;&#xA;&#xD;&#xA;2. Increase the buffer to `8k` in `saveBitmap`, change the `1024*4` to `1024*8`, this would increase the performance at least, not save any significant time perhaps.&#xD;&#xA;&#xD;&#xA;3. To save/reuse bitmap memory consider using `inBitmap` field, **if you have a post honeycomb version**, of `BitmapFactory.Options` and set that field to point to `bitmapRotate` bitmap and send options down to your `convertToGrayscale` method to not need allocating yet another bitmap down in that method. Read about `inBitmap` here: [inBitmap][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://developer.android.com/training/displaying-bitmaps/manage-memory.html#inBitmap";;added 6 characters in body
55200727;20965995;2246121;5;809f9ffc-f293-4e17-939a-979ef87f45b4;2014-01-08 17:56:24.0;"**Update**:&#xD;&#xA;Since you're still saying that the method takes too long time I would define a callback interface&#xD;&#xA;&#xD;&#xA;    interface BitmapCallback {&#xD;&#xA;        onBitmapSaveComplete(Bitmap bitmap, int orientation);&#xD;&#xA;&#xD;&#xA;        onBitmapRotateAndBWComlete(Bitmap bitmap);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Let your activity implement the above interface and convert the `byte[]` to bitmap in top of your `saveBitmap` method and fire the callback, before the first call to save. Rotate the `imageView` based on the orientation parameter and set a black/white filter on the `imageView` to *fool* the user into thinking that the bitmap is black and white (do this in your activity). See to that the calls are done on main thread (the calls to `imageView`). **Keep your old method as you have it. (all steps need to be done anyway)** Something like:&#xD;&#xA;&#xD;&#xA;    public static boolean saveBitmap(byte[] bitmapData, int orientation, String imagePath, String grayScalePath, BitmapCallback callback) throws Exception {&#xD;&#xA;    Boolean rotationSuccess = false;&#xD;&#xA;    BitmapFactory.Options options = new BitmapFactory.Options();&#xD;&#xA;    options.inPreferredConfig = Bitmap.Config.ARGB_8888;&#xD;&#xA;    Bitmap originalBm = null;&#xD;&#xA;    Bitmap bitmapRotate = null;&#xD;&#xA;    Bitmap grayScale = null;&#xD;&#xA;    FileOutputStream outStream = null;&#xD;&#xA;    try {&#xD;&#xA;        // TODO: convert byte to Bitmap, see to that the image is not larger than your wanted size (1024z768)&#xD;&#xA;        callback.onBitmapSaveComplete(bitmap, orientation);&#xD;&#xA;&#xD;&#xA;        // save directly from byte[] to file&#xD;&#xA;        saveBitmap(bitmapData, imagePath);&#xD;&#xA;        .&#xD;&#xA;        .&#xD;&#xA;        // same as old &#xD;&#xA;        .&#xD;&#xA;        .&#xD;&#xA;        saveBitmap(grayScale, grayScalePath);&#xD;&#xA;        // conversion done callback with the real fixed bitmap&#xD;&#xA;        callback.onBitmapRotateAndBWComlete(grayScale);&#xD;&#xA;&#xD;&#xA;        grayScale.recycle();&#xD;&#xA;        grayScale = null;&#xD;&#xA;&#xD;&#xA;        bitmapRotate.recycle();&#xD;&#xA;        bitmapRotate = null;&#xD;&#xA;        rotationSuccess = true;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;1. How do you setup your camera? What might be causing the long execution time in the first `saveBitmap` call, could be that you are using the default camera picture size settings and not reading the supported camera picture size and choosing best fit for your 1024x768 image needs. You might be taking big mpixel images and saving such, but in the end need you need < 1 mpixles (1024x768). Something like this in code:&#xD;&#xA;&#xD;&#xA; <code>&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;Camera camera = Camera.open();  &#xD;&#xA;Parameters params = camera.getParameters();  &#xD;&#xA;List<Camera.Size> sizes = params.getSupportedPictureSizes();  &#xD;&#xA;// Loop camera sizes and find best match, larger than 1024x768</code>&#xD;&#xA;&#xD;&#xA; **This is probably where you will save most of the time if you are not doing this already. And do it only once, during some initialization phase.**&#xD;&#xA;&#xD;&#xA;2. Increase the buffer to `8k` in `saveBitmap`, change the `1024*4` to `1024*8`, this would increase the performance at least, not save any significant time perhaps.&#xD;&#xA;&#xD;&#xA;3. To save/reuse bitmap memory consider using `inBitmap` field, **if you have a post honeycomb version**, of `BitmapFactory.Options` and set that field to point to `bitmapRotate` bitmap and send options down to your `convertToGrayscale` method to not need allocating yet another bitmap down in that method. Read about `inBitmap` here: [inBitmap][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://developer.android.com/training/displaying-bitmaps/manage-memory.html#inBitmap";;added 54 characters in body
