Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
86216244;29149240;1121707;2;232f3d69-e967-4357-bf21-836689d99172;2015-03-19 15:52:29.0;"I hope it's not too late or may be someone else could help.&#xD;&#xA;&#xD;&#xA;    public class MyContentProvider extends ContentProvider {&#xD;&#xA;&#xD;&#xA;    List<Item> items = new ArrayList<Item>();&#xD;&#xA;&#xD;&#xA;	@Override&#xD;&#xA;	public boolean onCreate() {&#xD;&#xA;        // initial list of items&#xD;&#xA;		items.add(new Item(""Coffe"", 3f));&#xD;&#xA;		items.add(new Item(""Coffe Latte"", 3.5f));&#xD;&#xA;		items.add(new Item(""Macchiato"", 4f));&#xD;&#xA;		items.add(new Item(""Frapuccion"", 4.25f));&#xD;&#xA;		items.add(new Item(""Te"", 3f));&#xD;&#xA;&#xD;&#xA;		return true;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;     @Override&#xD;&#xA;	public Cursor query(Uri uri, String[] projection, String selection,&#xD;&#xA;			String[] selectionArgs, String sortOrder) {&#xD;&#xA;&#xD;&#xA;		MatrixCursor cursor = new MatrixCursor(new String[] { ""name"", ""price""});&#xD;&#xA;&#xD;&#xA;		for (Item item : items) {&#xD;&#xA;			RowBuilder builder = cursor.newRow();&#xD;&#xA;			builder.add(""name"", item.name);&#xD;&#xA;			builder.add(""price"", item.price);&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		cursor.setNotificationUri(getContext().getContentResolver(), QUERY_URI);&#xD;&#xA;&#xD;&#xA;		return cursor;&#xD;&#xA;   }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    @Override&#xD;&#xA;	public Uri insert(Uri uri, ContentValues values) {&#xD;&#xA;        // TODO  change code to take new item from values -ContentValues- &#xD;&#xA;		items.add(new Item(""Cocacola"", 3.5f));&#xD;&#xA;&#xD;&#xA;		getContext().getContentResolver().notifyChange(uri, null);&#xD;&#xA;		return uri;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;
86217083;29149240;1121707;5;aff10f5e-300f-4d35-bccc-37694b78ac03;2015-03-19 16:00:46.0;"I hope it's not too late or may be someone else could help.&#xD;&#xA;&#xD;&#xA;The tricky thing here. It's you have to make a new cursor every time you query to the contentProvider for this reason I have my item list and every time I query content provider I build a new cursor with my backed item list that have new items.&#xD;&#xA;&#xD;&#xA;Why I have to do tha? Otherwise you are going to get an exception becouse CursorLoader attempt to register an observer inside a cursor that already have one. &#xD;&#xA;Notice that the way to build new rows in a CursorMatrix is permitted in api level 19 and above, but you have alternative ways but involve more borring code.&#xD;&#xA;&#xD;&#xA;    public class MyContentProvider extends ContentProvider {&#xD;&#xA;&#xD;&#xA;    List<Item> items = new ArrayList<Item>();&#xD;&#xA;&#xD;&#xA;	@Override&#xD;&#xA;	public boolean onCreate() {&#xD;&#xA;        // initial list of items&#xD;&#xA;		items.add(new Item(""Coffe"", 3f));&#xD;&#xA;		items.add(new Item(""Coffe Latte"", 3.5f));&#xD;&#xA;		items.add(new Item(""Macchiato"", 4f));&#xD;&#xA;		items.add(new Item(""Frapuccion"", 4.25f));&#xD;&#xA;		items.add(new Item(""Te"", 3f));&#xD;&#xA;&#xD;&#xA;		return true;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;     @Override&#xD;&#xA;	public Cursor query(Uri uri, String[] projection, String selection,&#xD;&#xA;			String[] selectionArgs, String sortOrder) {&#xD;&#xA;&#xD;&#xA;		MatrixCursor cursor = new MatrixCursor(new String[] { ""name"", ""price""});&#xD;&#xA;&#xD;&#xA;		for (Item item : items) {&#xD;&#xA;			RowBuilder builder = cursor.newRow();&#xD;&#xA;			builder.add(""name"", item.name);&#xD;&#xA;			builder.add(""price"", item.price);&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		cursor.setNotificationUri(getContext().getContentResolver(), QUERY_URI);&#xD;&#xA;&#xD;&#xA;		return cursor;&#xD;&#xA;   }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    @Override&#xD;&#xA;	public Uri insert(Uri uri, ContentValues values) {&#xD;&#xA;        // TODO  change code to take new item from values -ContentValues- &#xD;&#xA;		items.add(new Item(""Cocacola"", 3.5f));&#xD;&#xA;&#xD;&#xA;		getContext().getContentResolver().notifyChange(uri, null);&#xD;&#xA;		return uri;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 568 characters in body
86217782;29149240;1121707;5;8c003ab4-a01c-4ae9-a5b7-d1133ad1d333;2015-03-19 16:09:40.0;"I hope it's not too late or may be someone else could help.&#xD;&#xA;&#xD;&#xA;The tricky thing here. It's you have to make a new cursor every time you query to the contentProvider for this reason I have my item list and every time I query content provider I build a new cursor with my backed item list that have new items.&#xD;&#xA;&#xD;&#xA;Why I have to do tha? Otherwise you are going to get an exception becouse CursorLoader attempt to register an observer inside a cursor that already have one. &#xD;&#xA;Notice that the way to build new rows in a CursorMatrix is permitted in api level 19 and above, but you have alternative ways but involve more borring code.&#xD;&#xA;&#xD;&#xA;    public class MyContentProvider extends ContentProvider {&#xD;&#xA;&#xD;&#xA;    List<Item> items = new ArrayList<Item>();&#xD;&#xA;&#xD;&#xA;	@Override&#xD;&#xA;	public boolean onCreate() {&#xD;&#xA;        // initial list of items&#xD;&#xA;		items.add(new Item(""Coffe"", 3f));&#xD;&#xA;		items.add(new Item(""Coffe Latte"", 3.5f));&#xD;&#xA;		items.add(new Item(""Macchiato"", 4f));&#xD;&#xA;		items.add(new Item(""Frapuccion"", 4.25f));&#xD;&#xA;		items.add(new Item(""Te"", 3f));&#xD;&#xA;&#xD;&#xA;		return true;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;     @Override&#xD;&#xA;	public Cursor query(Uri uri, String[] projection, String selection,&#xD;&#xA;			String[] selectionArgs, String sortOrder) {&#xD;&#xA;&#xD;&#xA;		MatrixCursor cursor = new MatrixCursor(new String[] { ""name"", ""price""});&#xD;&#xA;&#xD;&#xA;		for (Item item : items) {&#xD;&#xA;			RowBuilder builder = cursor.newRow();&#xD;&#xA;			builder.add(""name"", item.name);&#xD;&#xA;			builder.add(""price"", item.price);&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		cursor.setNotificationUri(getContext().getContentResolver(), QUERY_URI);&#xD;&#xA;&#xD;&#xA;		return cursor;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    @Override&#xD;&#xA;	public Uri insert(Uri uri, ContentValues values) {&#xD;&#xA;        // TODO  change code to take new item from values -ContentValues- &#xD;&#xA;		items.add(new Item(""Cocacola"", 3.5f));&#xD;&#xA;&#xD;&#xA;		getContext().getContentResolver().notifyChange(uri, null);&#xD;&#xA;		return uri;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 1 character in body
86272081;29149240;1121707;5;45582bd7-be12-4e0b-9f64-d60e0b4eba53;2015-03-20 10:04:36.0;"I hope it's not too late or may be someone else could help.&#xD;&#xA;&#xD;&#xA;The tricky thing here. It's you have to make a new cursor every time you query to the contentProvider for this reason I have my item list and every time I query content provider I build a new cursor with my backed item list that have new items.&#xD;&#xA;&#xD;&#xA;Why I have to do tha? Otherwise you are going to get an exception becouse CursorLoader attempt to register an observer inside a cursor that already have one. &#xD;&#xA;Notice that the way to build new rows in a CursorMatrix is permitted in api level 19 and above, but you have alternative ways but involve more borring code.&#xD;&#xA;&#xD;&#xA;    public class MyContentProvider extends ContentProvider {&#xD;&#xA;&#xD;&#xA;    List<Item> items = new ArrayList<Item>();&#xD;&#xA;&#xD;&#xA;	@Override&#xD;&#xA;	public boolean onCreate() {&#xD;&#xA;        // initial list of items&#xD;&#xA;		items.add(new Item(""Coffe"", 3f));&#xD;&#xA;		items.add(new Item(""Coffe Latte"", 3.5f));&#xD;&#xA;		items.add(new Item(""Macchiato"", 4f));&#xD;&#xA;		items.add(new Item(""Frapuccion"", 4.25f));&#xD;&#xA;		items.add(new Item(""Te"", 3f));&#xD;&#xA;&#xD;&#xA;		return true;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;     @Override&#xD;&#xA;	public Cursor query(Uri uri, String[] projection, String selection,&#xD;&#xA;			String[] selectionArgs, String sortOrder) {&#xD;&#xA;&#xD;&#xA;		MatrixCursor cursor = new MatrixCursor(new String[] { ""name"", ""price""});&#xD;&#xA;&#xD;&#xA;		for (Item item : items) {&#xD;&#xA;			RowBuilder builder = cursor.newRow();&#xD;&#xA;			builder.add(""name"", item.name);&#xD;&#xA;			builder.add(""price"", item.price);&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		cursor.setNotificationUri(getContext().getContentResolver(),uri);&#xD;&#xA;&#xD;&#xA;		return cursor;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    @Override&#xD;&#xA;	public Uri insert(Uri uri, ContentValues values) {&#xD;&#xA;        // TODO  change code to take new item from values -ContentValues- &#xD;&#xA;		items.add(new Item(""Cocacola"", 3.5f));&#xD;&#xA;&#xD;&#xA;		getContext().getContentResolver().notifyChange(uri, null);&#xD;&#xA;		return uri;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;deleted 7 characters in body
106860152;29149240;1121707;5;89a43b60-5cf5-4ae0-8b2e-fe3ac59bbae8;2015-12-21 10:25:00.0;"I hope it's not too late or may be someone else could help.&#xD;&#xA;&#xD;&#xA;The tricky thing here. It's you have to make a new cursor every time you query to the contentProvider for this reason I have my item list and every time I query content provider I build a new cursor with my backed item list that have new items.&#xD;&#xA;&#xD;&#xA;Why I have to do tha? Otherwise you are going to get an exception becouse CursorLoader attempt to register an observer inside a cursor that already have one. &#xD;&#xA;Notice that the way to build new rows in a CursorMatrix is permitted in api level 19 and above, but you have alternative ways but involve more borring code.&#xD;&#xA;&#xD;&#xA;    public class MyContentProvider extends ContentProvider {&#xD;&#xA;&#xD;&#xA;    List<Item> items = new ArrayList<Item>();&#xD;&#xA;&#xD;&#xA;	@Override&#xD;&#xA;	public boolean onCreate() {&#xD;&#xA;        // initial list of items&#xD;&#xA;		items.add(new Item(""Coffe"", 3f));&#xD;&#xA;		items.add(new Item(""Coffe Latte"", 3.5f));&#xD;&#xA;		items.add(new Item(""Macchiato"", 4f));&#xD;&#xA;		items.add(new Item(""Frapuccion"", 4.25f));&#xD;&#xA;		items.add(new Item(""Te"", 3f));&#xD;&#xA;&#xD;&#xA;		return true;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;     @Override&#xD;&#xA;	public Cursor query(Uri uri, String[] projection, String selection,&#xD;&#xA;			String[] selectionArgs, String sortOrder) {&#xD;&#xA;&#xD;&#xA;		MatrixCursor cursor = new MatrixCursor(new String[] { ""name"", ""price""});&#xD;&#xA;&#xD;&#xA;		for (Item item : items) {&#xD;&#xA;			RowBuilder builder = cursor.newRow();&#xD;&#xA;			builder.add(""name"", item.name);&#xD;&#xA;			builder.add(""price"", item.price);&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		cursor.setNotificationUri(getContext().getContentResolver(),uri);&#xD;&#xA;&#xD;&#xA;		return cursor;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    @Override&#xD;&#xA;	public Uri insert(Uri uri, ContentValues values) {&#xD;&#xA;        // TODO  change code to take new item from values -ContentValues- &#xD;&#xA;		items.add(new Item(values.getAsString(""name),values.getAsFloat(""price"")));&#xD;&#xA;&#xD;&#xA;        //THE MAGIC COMES HERE !!!! when notify change it observers registred               make a requery so are going to call query on the content provider and now we are going to get a new Cursor with a new item&#xD;&#xA;&#xD;&#xA;		getContext().getContentResolver().notifyChange(uri, null);&#xD;&#xA;&#xD;&#xA;		return uri;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 38 characters in body
106860636;29149240;1121707;5;e9771b4d-c6f8-4121-a54a-e363c5caf290;2015-12-21 10:31:50.0;"I hope it's not too late or may be someone else could help.&#xD;&#xA;&#xD;&#xA;The tricky thing here. It's you have to make a new cursor every time you query to the contentProvider for this reason I have my item list and every time I query content provider I build a new cursor with my backed item list that have new items.&#xD;&#xA;&#xD;&#xA;Why I have to do tha? Otherwise you are going to get an exception becouse CursorLoader attempt to register an observer inside a cursor that already have one. &#xD;&#xA;Notice that the way to build new rows in a CursorMatrix is permitted in api level 19 and above, but you have alternative ways but involve more borring code.&#xD;&#xA;&#xD;&#xA;    public class MyContentProvider extends ContentProvider {&#xD;&#xA;&#xD;&#xA;    List<Item> items = new ArrayList<Item>();&#xD;&#xA;&#xD;&#xA;	@Override&#xD;&#xA;	public boolean onCreate() {&#xD;&#xA;        // initial list of items&#xD;&#xA;		items.add(new Item(""Coffe"", 3f));&#xD;&#xA;		items.add(new Item(""Coffe Latte"", 3.5f));&#xD;&#xA;		items.add(new Item(""Macchiato"", 4f));&#xD;&#xA;		items.add(new Item(""Frapuccion"", 4.25f));&#xD;&#xA;		items.add(new Item(""Te"", 3f));&#xD;&#xA;&#xD;&#xA;		return true;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;     @Override&#xD;&#xA;	public Cursor query(Uri uri, String[] projection, String selection,&#xD;&#xA;			String[] selectionArgs, String sortOrder) {&#xD;&#xA;&#xD;&#xA;		MatrixCursor cursor = new MatrixCursor(new String[] { ""name"", ""price""});&#xD;&#xA;&#xD;&#xA;		for (Item item : items) {&#xD;&#xA;			RowBuilder builder = cursor.newRow();&#xD;&#xA;			builder.add(""name"", item.name);&#xD;&#xA;			builder.add(""price"", item.price);&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		cursor.setNotificationUri(getContext().getContentResolver(),uri);&#xD;&#xA;&#xD;&#xA;		return cursor;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    @Override&#xD;&#xA;	public Uri insert(Uri uri, ContentValues values) {&#xD;&#xA;		items.add(new Item(values.getAsString(""name""),values.getAsFloat(""price"")))&#xD;&#xA;&#xD;&#xA;        //THE MAGIC COMES HERE !!!! when notify change it observers registred &#xD;&#xA;        //make a requery so are going to call query on the content provider and&#xD;&#xA;        //now we are going to get a new Cursor with a new item&#xD;&#xA;	    getContext().getContentResolver().notifyChange(uri, null);&#xD;&#xA;&#xD;&#xA;		return uri;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 38 characters in body
106862645;29149240;1121707;5;bd91173c-7b4b-4cdb-8f88-820d85ba9a01;2015-12-21 11:01:23.0;"I hope it's not too late or may be someone else could help.&#xD;&#xA;&#xD;&#xA;The tricky thing here. It's you have to make a new cursor every time you query to the contentProvider for this reason I have my item list and every time I query content provider I build a new cursor with my backed item list that have new items.&#xD;&#xA;&#xD;&#xA;Why I have to do tha? Otherwise you are going to get an exception becouse CursorLoader attempt to register an observer inside a cursor that already have one. &#xD;&#xA;Notice that the way to build new rows in a CursorMatrix is permitted in api level 19 and above, but you have alternative ways but involve more borring code.&#xD;&#xA;&#xD;&#xA;    public class MyContentProvider extends ContentProvider {&#xD;&#xA;&#xD;&#xA;    List<Item> items = new ArrayList<Item>();&#xD;&#xA;&#xD;&#xA;	@Override&#xD;&#xA;	public boolean onCreate() {&#xD;&#xA;        // initial list of items&#xD;&#xA;		items.add(new Item(""Coffe"", 3f));&#xD;&#xA;		items.add(new Item(""Coffe Latte"", 3.5f));&#xD;&#xA;		items.add(new Item(""Macchiato"", 4f));&#xD;&#xA;		items.add(new Item(""Frapuccion"", 4.25f));&#xD;&#xA;		items.add(new Item(""Te"", 3f));&#xD;&#xA;&#xD;&#xA;		return true;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;     @Override&#xD;&#xA;	public Cursor query(Uri uri, String[] projection, String selection,&#xD;&#xA;			String[] selectionArgs, String sortOrder) {&#xD;&#xA;&#xD;&#xA;		MatrixCursor cursor = new MatrixCursor(new String[] { ""name"", ""price""});&#xD;&#xA;&#xD;&#xA;		for (Item item : items) {&#xD;&#xA;			RowBuilder builder = cursor.newRow();&#xD;&#xA;			builder.add(""name"", item.name);&#xD;&#xA;			builder.add(""price"", item.price);&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		cursor.setNotificationUri(getContext().getContentResolver(),uri);&#xD;&#xA;&#xD;&#xA;		return cursor;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    @Override&#xD;&#xA;	public Uri insert(Uri uri, ContentValues values) {&#xD;&#xA;		items.add(new Item(values.getAsString(""name""),values.getAsFloat(""price"")))&#xD;&#xA;&#xD;&#xA;        //THE MAGIC COMES HERE !!!! when notify change and its observers registred make a requery so they are going to call query on the content provider and now we are going to get a new Cursor with the new item&#xD;&#xA;&#xD;&#xA;	    getContext().getContentResolver().notifyChange(uri, null);&#xD;&#xA;&#xD;&#xA;		return uri;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;deleted 9 characters in body
