Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
87716791;29535537;4584812;2;f97c3265-09bb-4537-ad3d-caaa0f9a31f8;2015-04-09 10:06:03.0;"I wrote this a while ago an it has been working great&#xD;&#xA;&#xD;&#xA;        [AttributeUsage(AttributeTargets.Property, Inherited = false)]&#xD;&#xA;        public class CalculatedProperty : Attribute&#xD;&#xA;        {&#xD;&#xA;            private string[] _props;&#xD;&#xA;            public CalculatedProperty(params string[] props)&#xD;&#xA;            {&#xD;&#xA;                this._props = props;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public string[] Properties&#xD;&#xA;            {&#xD;&#xA;                get&#xD;&#xA;                {&#xD;&#xA;                    return _props;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;            public class ObservableObject : INotifyPropertyChanged&#xD;&#xA;            {&#xD;&#xA;                //static, because we use reflication only once on initalization per type that inherits ObservableObject&#xD;&#xA;                //the first key is full type name, the second is the computed property name, the array is the names of the properties that the calculated property depends on&#xD;&#xA;                private static Dictionary<string, Dictionary<string, string[]>> calculatedPropertiesOfTypes = new Dictionary<string, Dictionary<string, string[]>>();&#xD;&#xA;    &#xD;&#xA;                //initalize this in the constructor&#xD;&#xA;                private readonly bool hasComputedProperties;&#xD;&#xA;    &#xD;&#xA;                //the constructor checks if the calculatedPropertiesOfTypes has the class meta already, if not it uses reflection to get the relevant prop info&#xD;&#xA;                public ObservableObject()&#xD;&#xA;                {&#xD;&#xA;                    Type t = GetType();&#xD;&#xA;                    if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                    {&#xD;&#xA;                        var props = t.GetProperties();&#xD;&#xA;    &#xD;&#xA;                        foreach (var pInfo in props)&#xD;&#xA;                        {&#xD;&#xA;                            var attr = pInfo.GetCustomAttribute<CalculatedProperty>(false);&#xD;&#xA;                            if (attr == null)&#xD;&#xA;                                continue;&#xD;&#xA;    &#xD;&#xA;                            calculatedPropertiesOfTypes[t.FullName] = new Dictionary<string, string[]>();&#xD;&#xA;                            calculatedPropertiesOfTypes[t.FullName][pInfo.Name] = attr.Properties;&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;    &#xD;&#xA;                    if (calculatedPropertiesOfTypes[t.FullName] != null)&#xD;&#xA;                        hasComputedProperties = true;&#xD;&#xA;                    &#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;                public event PropertyChangedEventHandler PropertyChanged;&#xD;&#xA;                public virtual void OnPropertyChanged(string propertyName)&#xD;&#xA;                {&#xD;&#xA;                    PropertyChangedEventHandler handler = PropertyChanged;&#xD;&#xA;                    if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;                protected bool SetField<T>(ref T field, T value, [CallerMemberName] string propertyName = null)&#xD;&#xA;                {&#xD;&#xA;                    //only set the field if there is a new value&#xD;&#xA;                    if (EqualityComparer<T>.Default.Equals(field, value)) &#xD;&#xA;                        return false;&#xD;&#xA;    &#xD;&#xA;                    field = value;&#xD;&#xA;    &#xD;&#xA;                    OnPropertyChanged(propertyName);&#xD;&#xA;                    &#xD;&#xA;                    if (this.hasComputedProperties)&#xD;&#xA;                    {&#xD;&#xA;                        //check for any computed properties that depend on this property&#xD;&#xA;                        var computedPropNames = &#xD;&#xA;                            calculatedPropertiesOfTypes[this.GetType().FullName]&#xD;&#xA;                            .Where(kvp => kvp.Value.Contains(propertyName))&#xD;&#xA;                            .Select(kvp => kvp.Key);&#xD;&#xA;    &#xD;&#xA;                        if (computedPropNames != null)&#xD;&#xA;                            if (!computedPropNames.Any())&#xD;&#xA;                                return true;&#xD;&#xA;                        &#xD;&#xA;                        //raise property changed for every computed property that is dependant on the property we did just set&#xD;&#xA;                        foreach (var computedPropName in computedPropNames)&#xD;&#xA;                        {&#xD;&#xA;                            OnPropertyChanged(computedPropName);&#xD;&#xA;                        }&#xD;&#xA;     &#xD;&#xA;                    }&#xD;&#xA;                    return true;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;Example:&#xD;&#xA;&#xD;&#xA;    public class ViewModel : ObservableObject&#xD;&#xA;            {&#xD;&#xA;                private int _x;&#xD;&#xA;                public int X &#xD;&#xA;                {&#xD;&#xA;                    get { return _x;}&#xD;&#xA;                    set { SetField(ref _x, value); }&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                private int _y;&#xD;&#xA;    &#xD;&#xA;                public int Y&#xD;&#xA;                {&#xD;&#xA;                    get { return _y; }&#xD;&#xA;                    set { SetField(ref _y, value); }&#xD;&#xA;                   &#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                //use the CalculatedProperty annotation for properties that depend on other properties and pass it the prop names that it depends on&#xD;&#xA;                [CalculatedProperty(""X"",""Y"")]&#xD;&#xA;                public int Result&#xD;&#xA;                {&#xD;&#xA;                    get { return X * Y; }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;Note that:&#xD;&#xA;&#xD;&#xA; - it uses reflection only once per type&#xD;&#xA; - `SetField` sets the field and raises property changed if there is a new value&#xD;&#xA; - you don't need to pass property name to `SetField` because the&#xD;&#xA;   `[CallerMemberName]` does it for you since c# 5.0.";;
87717359;29535537;4584812;5;634501a6-3ebf-4aaf-be0a-37847f41a689;2015-04-09 10:13:47.0;"I wrote this a while ago an it has been working great&#xD;&#xA;&#xD;&#xA;        [AttributeUsage(AttributeTargets.Property, Inherited = false)]&#xD;&#xA;        public class CalculatedProperty : Attribute&#xD;&#xA;        {&#xD;&#xA;            private string[] _props;&#xD;&#xA;            public CalculatedProperty(params string[] props)&#xD;&#xA;            {&#xD;&#xA;                this._props = props;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public string[] Properties&#xD;&#xA;            {&#xD;&#xA;                get&#xD;&#xA;                {&#xD;&#xA;                    return _props;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;            public class ObservableObject : INotifyPropertyChanged&#xD;&#xA;            {&#xD;&#xA;                //static, because we use reflication only once on initalization per type that inherits ObservableObject&#xD;&#xA;                //the first key is full type name, the second is the computed property name, the array is the names of the properties that the calculated property depends on&#xD;&#xA;                private static Dictionary<string, Dictionary<string, string[]>> calculatedPropertiesOfTypes = new Dictionary<string, Dictionary<string, string[]>>();&#xD;&#xA;    &#xD;&#xA;                //initalize this in the constructor&#xD;&#xA;                private readonly bool hasComputedProperties;&#xD;&#xA;    &#xD;&#xA;                //the constructor checks if the calculatedPropertiesOfTypes has the class meta already, if not it uses reflection to get the relevant prop info&#xD;&#xA;                public ObservableObject()&#xD;&#xA;                {&#xD;&#xA;                    Type t = GetType();&#xD;&#xA;                    if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                    {&#xD;&#xA;                        var props = t.GetProperties();&#xD;&#xA;    &#xD;&#xA;                        foreach (var pInfo in props)&#xD;&#xA;                        {&#xD;&#xA;                            var attr = pInfo.GetCustomAttribute<CalculatedProperty>(false);&#xD;&#xA;                            if (attr == null)&#xD;&#xA;                                continue;&#xD;&#xA;    &#xD;&#xA;                            calculatedPropertiesOfTypes[t.FullName] = new Dictionary<string, string[]>();&#xD;&#xA;                            calculatedPropertiesOfTypes[t.FullName][pInfo.Name] = attr.Properties;&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;    &#xD;&#xA;                    if (calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                        hasComputedProperties = true;&#xD;&#xA;                    &#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;                public event PropertyChangedEventHandler PropertyChanged;&#xD;&#xA;                public virtual void OnPropertyChanged(string propertyName)&#xD;&#xA;                {&#xD;&#xA;                    PropertyChangedEventHandler handler = PropertyChanged;&#xD;&#xA;                    if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;                protected bool SetField<T>(ref T field, T value, [CallerMemberName] string propertyName = null)&#xD;&#xA;                {&#xD;&#xA;                    //only set the field if there is a new value&#xD;&#xA;                    if (EqualityComparer<T>.Default.Equals(field, value)) &#xD;&#xA;                        return false;&#xD;&#xA;    &#xD;&#xA;                    field = value;&#xD;&#xA;    &#xD;&#xA;                    OnPropertyChanged(propertyName);&#xD;&#xA;                    &#xD;&#xA;                    if (this.hasComputedProperties)&#xD;&#xA;                    {&#xD;&#xA;                        //check for any computed properties that depend on this property&#xD;&#xA;                        var computedPropNames = &#xD;&#xA;                            calculatedPropertiesOfTypes[this.GetType().FullName]&#xD;&#xA;                            .Where(kvp => kvp.Value.Contains(propertyName))&#xD;&#xA;                            .Select(kvp => kvp.Key);&#xD;&#xA;    &#xD;&#xA;                        if (computedPropNames != null)&#xD;&#xA;                            if (!computedPropNames.Any())&#xD;&#xA;                                return true;&#xD;&#xA;                        &#xD;&#xA;                        //raise property changed for every computed property that is dependant on the property we did just set&#xD;&#xA;                        foreach (var computedPropName in computedPropNames)&#xD;&#xA;                        {&#xD;&#xA;                            OnPropertyChanged(computedPropName);&#xD;&#xA;                        }&#xD;&#xA;     &#xD;&#xA;                    }&#xD;&#xA;                    return true;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;Example:&#xD;&#xA;&#xD;&#xA;    public class ViewModel : ObservableObject&#xD;&#xA;            {&#xD;&#xA;                private int _x;&#xD;&#xA;                public int X &#xD;&#xA;                {&#xD;&#xA;                    get { return _x;}&#xD;&#xA;                    set { SetField(ref _x, value); }&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                private int _y;&#xD;&#xA;    &#xD;&#xA;                public int Y&#xD;&#xA;                {&#xD;&#xA;                    get { return _y; }&#xD;&#xA;                    set { SetField(ref _y, value); }&#xD;&#xA;                   &#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                //use the CalculatedProperty annotation for properties that depend on other properties and pass it the prop names that it depends on&#xD;&#xA;                [CalculatedProperty(""X"",""Y"")]&#xD;&#xA;                public int Result&#xD;&#xA;                {&#xD;&#xA;                    get { return X * Y; }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;Note that:&#xD;&#xA;&#xD;&#xA; - it uses reflection only once per type&#xD;&#xA; - `SetField` sets the field and raises property changed if there is a new value&#xD;&#xA; - you don't need to pass property name to `SetField` because the&#xD;&#xA;   `[CallerMemberName]` does it for you since c# 5.0.";;added 4 characters in body
88905313;29535537;4584812;5;4218f08c-a542-40eb-9783-ed7c3e819e30;2015-04-24 07:22:37.0;"I wrote this a while ago an it has been working great&#xD;&#xA;&#xD;&#xA;        [AttributeUsage(AttributeTargets.Property, Inherited = false)]&#xD;&#xA;        public class CalculatedProperty : Attribute&#xD;&#xA;        {&#xD;&#xA;            private string[] _props;&#xD;&#xA;            public CalculatedProperty(params string[] props)&#xD;&#xA;            {&#xD;&#xA;                this._props = props;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public string[] Properties&#xD;&#xA;            {&#xD;&#xA;                get&#xD;&#xA;                {&#xD;&#xA;                    return _props;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;            public class ObservableObject : INotifyPropertyChanged&#xD;&#xA;            {&#xD;&#xA;                //static, because we use reflication only once on initalization per type that inherits ObservableObject&#xD;&#xA;                //the first key is full type name, the second is the computed property name, the array is the names of the properties that the calculated property depends on&#xD;&#xA;                private static Dictionary<string, Dictionary<string, string[]>> calculatedPropertiesOfTypes = new Dictionary<string, Dictionary<string, string[]>>();&#xD;&#xA;    &#xD;&#xA;                //initalize this in the constructor&#xD;&#xA;                private readonly bool hasComputedProperties;&#xD;&#xA;    &#xD;&#xA;                //the constructor checks if the calculatedPropertiesOfTypes has the class meta already, if not it uses reflection to get the relevant prop info&#xD;&#xA;                public ObservableObject()&#xD;&#xA;                {&#xD;&#xA;                    Type t = GetType();&#xD;&#xA;                    if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                    {&#xD;&#xA;                        var props = t.GetProperties();&#xD;&#xA;    &#xD;&#xA;                        foreach (var pInfo in props)&#xD;&#xA;                        {&#xD;&#xA;                            var attr = pInfo.GetCustomAttribute<CalculatedProperty>(false);&#xD;&#xA;                            if (attr == null)&#xD;&#xA;                                continue;&#xD;&#xA;    &#xD;&#xA;                            calculatedPropertiesOfTypes[t.FullName] = new Dictionary<string, string[]>();&#xD;&#xA;                            calculatedPropertiesOfTypes[t.FullName][pInfo.Name] = attr.Properties;&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;    &#xD;&#xA;                    if (calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                        hasComputedProperties = true;&#xD;&#xA;                    &#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;                public event PropertyChangedEventHandler PropertyChanged;&#xD;&#xA;                public virtual void OnPropertyChanged(string propertyName)&#xD;&#xA;                {&#xD;&#xA;                    PropertyChangedEventHandler handler = PropertyChanged;&#xD;&#xA;                    if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;                protected bool SetField<T>(ref T field, T value, [CallerMemberName] string propertyName = null)&#xD;&#xA;                {&#xD;&#xA;                    //only set the field if there is a new value&#xD;&#xA;                    if (EqualityComparer<T>.Default.Equals(field, value)) &#xD;&#xA;                        return false;&#xD;&#xA;    &#xD;&#xA;                    field = value;&#xD;&#xA;    &#xD;&#xA;                    OnPropertyChanged(propertyName);&#xD;&#xA;                    &#xD;&#xA;                    if (this.hasComputedProperties)&#xD;&#xA;                    {&#xD;&#xA;                        //check for any computed properties that depend on this property&#xD;&#xA;                        var computedPropNames = &#xD;&#xA;                            calculatedPropertiesOfTypes[this.GetType().FullName]&#xD;&#xA;                            .Where(kvp => kvp.Value.Contains(propertyName))&#xD;&#xA;                            .Select(kvp => kvp.Key);&#xD;&#xA;    &#xD;&#xA;                        if (computedPropNames != null)&#xD;&#xA;                            if (!computedPropNames.Any())&#xD;&#xA;                                return true;&#xD;&#xA;                        &#xD;&#xA;                        //raise property changed for every computed property that is dependant on the property we did just set&#xD;&#xA;                        foreach (var computedPropName in computedPropNames)&#xD;&#xA;                        {&#xD;&#xA;                            OnPropertyChanged(computedPropName);&#xD;&#xA;                        }&#xD;&#xA;     &#xD;&#xA;                    }&#xD;&#xA;                    return true;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;Example:&#xD;&#xA;&#xD;&#xA;    public class ViewModel : ObservableObject&#xD;&#xA;            {&#xD;&#xA;                private int _x;&#xD;&#xA;                public int X &#xD;&#xA;                {&#xD;&#xA;                    get { return _x;}&#xD;&#xA;                    set { SetField(ref _x, value); }&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                private int _y;&#xD;&#xA;    &#xD;&#xA;                public int Y&#xD;&#xA;                {&#xD;&#xA;                    get { return _y; }&#xD;&#xA;                    set { SetField(ref _y, value); }&#xD;&#xA;                   &#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                //use the CalculatedProperty annotation for properties that depend on other properties and pass it the prop names that it depends on&#xD;&#xA;                [CalculatedProperty(""X"",""Y"")]&#xD;&#xA;                public int Result&#xD;&#xA;                {&#xD;&#xA;                    get { return X * Y; }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;Note that:&#xD;&#xA;&#xD;&#xA; - it uses reflection only once per type&#xD;&#xA; - `SetField` sets the field and raises property changed if there is a new value&#xD;&#xA; - you don't need to pass property name to `SetField` because the&#xD;&#xA;   `[CallerMemberName]` does it for you since c# 5.0.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;As per your comment:&#xD;&#xA;&#xD;&#xA; - don't pass the property name to  `SetField` method as long as you&#xD;&#xA;   call it from the setter of the relevant property since&#xD;&#xA;   `[CallerMemberName]` (c#5) will do it for you so do it just like the example.&#xD;&#xA; - if you call `SetField` from outside the setter of the property then&#xD;&#xA;   you will have to pass the property name such as&#xD;&#xA;   &#xD;&#xA;`SetField(ref _field,value,""PropertyName"")` or &#xD;&#xA; &#xD;&#xA;  `SetField(ref _field,value,nameof(PropertyName))` (c#6).&#xD;&#xA; &#xD;&#xA; - you can also use OnPropertyChanged(""PropertyName"") to raise&#xD;&#xA;   PropertyChanged after you set the value without using `SetField`,but note if you do it this way the PropertyChanged&#xD;&#xA;   won't be raised for dependant properties if there was any.&#xD;&#xA; - in the above example whenever `Y` or `X` gets set thorugh `SetField`&#xD;&#xA;   PropertyChanged will get raised for `Result` too since we added the&#xD;&#xA;   properties it depends on in the `CalculatedProperty` annotation";;added 730 characters in body
88913415;29535537;4584812;5;24b54ce6-f660-495c-a13b-ac9f16ce5a25;2015-04-24 09:10:25.0;"I wrote this a while ago an it has been working great&#xD;&#xA;&#xD;&#xA;        [AttributeUsage(AttributeTargets.Property, Inherited = false)]&#xD;&#xA;        public class CalculatedProperty : Attribute&#xD;&#xA;        {&#xD;&#xA;            private string[] _props;&#xD;&#xA;            public CalculatedProperty(params string[] props)&#xD;&#xA;            {&#xD;&#xA;                this._props = props;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public string[] Properties&#xD;&#xA;            {&#xD;&#xA;                get&#xD;&#xA;                {&#xD;&#xA;                    return _props;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;The ViewModel base&#xD;&#xA;&#xD;&#xA;        public class ObservableObject : INotifyPropertyChanged&#xD;&#xA;        {&#xD;&#xA;            private static Dictionary<string, Dictionary<string, string[]>> calculatedPropertiesOfTypes = new Dictionary<string, Dictionary<string, string[]>>();&#xD;&#xA;    &#xD;&#xA;            private readonly bool hasComputedProperties;&#xD;&#xA;            public ObservableObject()&#xD;&#xA;            {&#xD;&#xA;                Type t = GetType();&#xD;&#xA;                if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                {&#xD;&#xA;                    var props = t.GetProperties();&#xD;&#xA;    &#xD;&#xA;                    foreach (var pInfo in props)&#xD;&#xA;                    {&#xD;&#xA;                        var attr = pInfo.GetCustomAttribute<CalculatedProperty>(false);&#xD;&#xA;                        if (attr == null)&#xD;&#xA;                            continue;&#xD;&#xA;    &#xD;&#xA;                        if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                        {&#xD;&#xA;                            calculatedPropertiesOfTypes[t.FullName] = new Dictionary<string, string[]>();&#xD;&#xA;                        }&#xD;&#xA;                        calculatedPropertiesOfTypes[t.FullName][pInfo.Name] = attr.Properties;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                if (calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                    hasComputedProperties = true;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;            public event PropertyChangedEventHandler PropertyChanged;&#xD;&#xA;            public virtual void OnPropertyChanged(string propertyName)&#xD;&#xA;            {&#xD;&#xA;                PropertyChangedEventHandler handler = PropertyChanged;&#xD;&#xA;                if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));&#xD;&#xA;    &#xD;&#xA;                if (this.hasComputedProperties)&#xD;&#xA;                {&#xD;&#xA;                    //check for any computed properties that depend on this property&#xD;&#xA;                    var computedPropNames =&#xD;&#xA;                        calculatedPropertiesOfTypes[this.GetType().FullName]&#xD;&#xA;                        .Where(kvp => kvp.Value.Contains(propertyName))&#xD;&#xA;                        .Select(kvp => kvp.Key);&#xD;&#xA;    &#xD;&#xA;                    if (computedPropNames != null)&#xD;&#xA;                        if (!computedPropNames.Any())&#xD;&#xA;                            return;&#xD;&#xA;    &#xD;&#xA;                    //raise property changed for every computed property that is dependant on the property we did just set&#xD;&#xA;                    foreach (var computedPropName in computedPropNames)&#xD;&#xA;                    {&#xD;&#xA;                        OnPropertyChanged(computedPropName);&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;            protected bool SetField<T>(ref T field, T value, [CallerMemberName] string propertyName = null)&#xD;&#xA;            {&#xD;&#xA;                if (EqualityComparer<T>.Default.Equals(field, value))&#xD;&#xA;                    return false;&#xD;&#xA;    &#xD;&#xA;                field = value;&#xD;&#xA;                OnPropertyChanged(propertyName);&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;Example:&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;    public class ViewModel : ObservableObject&#xD;&#xA;    {&#xD;&#xA;        private int _x;&#xD;&#xA;        public int X&#xD;&#xA;        {&#xD;&#xA;            get { return _x; }&#xD;&#xA;            set { SetField(ref _x, value); }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        private int _y;&#xD;&#xA;    &#xD;&#xA;        public int Y&#xD;&#xA;        {&#xD;&#xA;            get { return _y; }&#xD;&#xA;            set { SetField(ref _y, value); }&#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        //use the CalculatedProperty annotation for properties that depend on other properties and pass it the prop names that it depends on&#xD;&#xA;        [CalculatedProperty(""X"", ""Y"")]&#xD;&#xA;        public int Z&#xD;&#xA;        {&#xD;&#xA;            get { return X * Y; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        [CalculatedProperty(""Z"")]&#xD;&#xA;        public int M&#xD;&#xA;        {&#xD;&#xA;            get { return Y * Z; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note that:&#xD;&#xA;&#xD;&#xA; - it uses reflection only once per type&#xD;&#xA; - `SetField` sets the field and raises property changed if there is a new value&#xD;&#xA; - you don't need to pass property name to `SetField` because the&#xD;&#xA;   `[CallerMemberName]` does it for you since c# 5.0.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;deleted 750 characters in body
88913965;29535537;4584812;5;ce011767-e980-4f51-aaf3-d1b2d6aa7b85;2015-04-24 09:17:01.0;"I wrote this a while ago an it has been working great&#xD;&#xA;&#xD;&#xA;        [AttributeUsage(AttributeTargets.Property, Inherited = false)]&#xD;&#xA;        public class CalculatedProperty : Attribute&#xD;&#xA;        {&#xD;&#xA;            private string[] _props;&#xD;&#xA;            public CalculatedProperty(params string[] props)&#xD;&#xA;            {&#xD;&#xA;                this._props = props;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public string[] Properties&#xD;&#xA;            {&#xD;&#xA;                get&#xD;&#xA;                {&#xD;&#xA;                    return _props;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;The ViewModel base&#xD;&#xA;&#xD;&#xA;        public class ObservableObject : INotifyPropertyChanged&#xD;&#xA;        {&#xD;&#xA;            private static Dictionary<string, Dictionary<string, string[]>> calculatedPropertiesOfTypes = new Dictionary<string, Dictionary<string, string[]>>();&#xD;&#xA;    &#xD;&#xA;            private readonly bool hasComputedProperties;&#xD;&#xA;            public ObservableObject()&#xD;&#xA;            {&#xD;&#xA;                Type t = GetType();&#xD;&#xA;                if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                {&#xD;&#xA;                    var props = t.GetProperties();&#xD;&#xA;    &#xD;&#xA;                    foreach (var pInfo in props)&#xD;&#xA;                    {&#xD;&#xA;                        var attr = pInfo.GetCustomAttribute<CalculatedProperty>(false);&#xD;&#xA;                        if (attr == null)&#xD;&#xA;                            continue;&#xD;&#xA;    &#xD;&#xA;                        if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                        {&#xD;&#xA;                            calculatedPropertiesOfTypes[t.FullName] = new Dictionary<string, string[]>();&#xD;&#xA;                        }&#xD;&#xA;                        calculatedPropertiesOfTypes[t.FullName][pInfo.Name] = attr.Properties;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                if (calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                    hasComputedProperties = true;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;            public event PropertyChangedEventHandler PropertyChanged;&#xD;&#xA;            public virtual void OnPropertyChanged(string propertyName)&#xD;&#xA;            {&#xD;&#xA;                PropertyChangedEventHandler handler = PropertyChanged;&#xD;&#xA;                if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));&#xD;&#xA;    &#xD;&#xA;                if (this.hasComputedProperties)&#xD;&#xA;                {&#xD;&#xA;                    //check for any computed properties that depend on this property&#xD;&#xA;                    var computedPropNames =&#xD;&#xA;                        calculatedPropertiesOfTypes[this.GetType().FullName]&#xD;&#xA;                        .Where(kvp => kvp.Value.Contains(propertyName))&#xD;&#xA;                        .Select(kvp => kvp.Key);&#xD;&#xA;    &#xD;&#xA;                    if (computedPropNames != null)&#xD;&#xA;                        if (!computedPropNames.Any())&#xD;&#xA;                            return;&#xD;&#xA;    &#xD;&#xA;                    //raise property changed for every computed property that is dependant on the property we did just set&#xD;&#xA;                    foreach (var computedPropName in computedPropNames)&#xD;&#xA;                    {&#xD;&#xA;                        OnPropertyChanged(computedPropName);&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;            protected bool SetField<T>(ref T field, T value, [CallerMemberName] string propertyName = null)&#xD;&#xA;            {&#xD;&#xA;                if (EqualityComparer<T>.Default.Equals(field, value))&#xD;&#xA;                    return false;&#xD;&#xA;    &#xD;&#xA;                field = value;&#xD;&#xA;                OnPropertyChanged(propertyName);&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;Example:&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;    public class ViewModel : ObservableObject&#xD;&#xA;    {&#xD;&#xA;        private int _x;&#xD;&#xA;        public int X&#xD;&#xA;        {&#xD;&#xA;            get { return _x; }&#xD;&#xA;            set { SetField(ref _x, value); }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        private int _y;&#xD;&#xA;    &#xD;&#xA;        public int Y&#xD;&#xA;        {&#xD;&#xA;            get { return _y; }&#xD;&#xA;            set { SetField(ref _y, value); }&#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        //use the CalculatedProperty annotation for properties that depend on other properties and pass it the prop names that it depends on&#xD;&#xA;        [CalculatedProperty(""X"", ""Y"")]&#xD;&#xA;        public int Z&#xD;&#xA;        {&#xD;&#xA;            get { return X * Y; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        [CalculatedProperty(""Z"")]&#xD;&#xA;        public int M&#xD;&#xA;        {&#xD;&#xA;            get { return Y * Z; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note that:&#xD;&#xA;&#xD;&#xA; - it uses reflection only once per type&#xD;&#xA; - `SetField` sets the field and raises property changed if there is a new value&#xD;&#xA; - you don't need to pass property name to `SetField` as long as you call it within a setter because the&#xD;&#xA;   `[CallerMemberName]` does it for you since c# 5.0.&#xD;&#xA; - if you call `SetField` outside the setter then you will have to pass&#xD;&#xA;   it the property name&#xD;&#xA; - if a property depends on itself you get a stackoverflow ;)&#xD;&#xA; - as per my last update you can avoid using `SetField` by setting the field directly and then&#xD;&#xA;   calling OnPropertyChanged(""PropertyName"") and it will raise&#xD;&#xA;   PropertyChanged for all properties for all properties that are&#xD;&#xA;   dependant on it.&#xD;&#xA; - in c# 6 you can use the nameof operator to get the property name such&#xD;&#xA;   as `nameof(Property)`&#xD;&#xA;&#xD;&#xA;XAML for testing&#xD;&#xA;&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     <StackPanel>&#xD;&#xA;            <TextBox Text=""{Binding X,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}""></TextBox>&#xD;&#xA;            <TextBox Text=""{Binding Y,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}""></TextBox>&#xD;&#xA;            <TextBlock Text=""{Binding Z,Mode=OneWay}""></TextBlock>&#xD;&#xA;            <TextBlock Text=""{Binding M,Mode=OneWay}""></TextBlock>&#xD;&#xA;        </StackPanel>";;deleted 750 characters in body
88918137;29535537;4584812;5;d4d851aa-d162-4a25-a5c5-6f3c689cd592;2015-04-24 10:01:35.0;"I wrote this a while ago an it has been working great&#xD;&#xA;&#xD;&#xA;        [AttributeUsage(AttributeTargets.Property, Inherited = false)]&#xD;&#xA;        public class CalculatedProperty : Attribute&#xD;&#xA;        {&#xD;&#xA;            private string[] _props;&#xD;&#xA;            public CalculatedProperty(params string[] props)&#xD;&#xA;            {&#xD;&#xA;                this._props = props;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public string[] Properties&#xD;&#xA;            {&#xD;&#xA;                get&#xD;&#xA;                {&#xD;&#xA;                    return _props;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;The ViewModel base&#xD;&#xA;&#xD;&#xA;        public class ObservableObject : INotifyPropertyChanged&#xD;&#xA;        {&#xD;&#xA;            private static Dictionary<string, Dictionary<string, string[]>> calculatedPropertiesOfTypes = new Dictionary<string, Dictionary<string, string[]>>();&#xD;&#xA;    &#xD;&#xA;            private readonly bool hasComputedProperties;&#xD;&#xA;            public ObservableObject()&#xD;&#xA;            {&#xD;&#xA;                Type t = GetType();&#xD;&#xA;                if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                {&#xD;&#xA;                    var props = t.GetProperties();&#xD;&#xA;    &#xD;&#xA;                    foreach (var pInfo in props)&#xD;&#xA;                    {&#xD;&#xA;                        var attr = pInfo.GetCustomAttribute<CalculatedProperty>(false);&#xD;&#xA;                        if (attr == null)&#xD;&#xA;                            continue;&#xD;&#xA;    &#xD;&#xA;                        if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                        {&#xD;&#xA;                            calculatedPropertiesOfTypes[t.FullName] = new Dictionary<string, string[]>();&#xD;&#xA;                        }&#xD;&#xA;                        calculatedPropertiesOfTypes[t.FullName][pInfo.Name] = attr.Properties;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                if (calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                    hasComputedProperties = true;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;            public event PropertyChangedEventHandler PropertyChanged;&#xD;&#xA;            public virtual void OnPropertyChanged(string propertyName)&#xD;&#xA;            {&#xD;&#xA;                PropertyChangedEventHandler handler = PropertyChanged;&#xD;&#xA;                if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));&#xD;&#xA;    &#xD;&#xA;                if (this.hasComputedProperties)&#xD;&#xA;                {&#xD;&#xA;                    //check for any computed properties that depend on this property&#xD;&#xA;                    var computedPropNames =&#xD;&#xA;                        calculatedPropertiesOfTypes[this.GetType().FullName]&#xD;&#xA;                        .Where(kvp => kvp.Value.Contains(propertyName))&#xD;&#xA;                        .Select(kvp => kvp.Key);&#xD;&#xA;    &#xD;&#xA;                    if (computedPropNames != null)&#xD;&#xA;                        if (!computedPropNames.Any())&#xD;&#xA;                            return;&#xD;&#xA;    &#xD;&#xA;                    //raise property changed for every computed property that is dependant on the property we did just set&#xD;&#xA;                    foreach (var computedPropName in computedPropNames)&#xD;&#xA;                    {&#xD;&#xA;                        OnPropertyChanged(computedPropName);&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;            protected bool SetField<T>(ref T field, T value, [CallerMemberName] string propertyName = null)&#xD;&#xA;            {&#xD;&#xA;                if (EqualityComparer<T>.Default.Equals(field, value))&#xD;&#xA;                    return false;&#xD;&#xA;    &#xD;&#xA;                field = value;&#xD;&#xA;                OnPropertyChanged(propertyName);&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;Example:&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;    public class ViewModel : ObservableObject&#xD;&#xA;    {&#xD;&#xA;        private int _x;&#xD;&#xA;        public int X&#xD;&#xA;        {&#xD;&#xA;            get { return _x; }&#xD;&#xA;            set { SetField(ref _x, value); }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        private int _y;&#xD;&#xA;    &#xD;&#xA;        public int Y&#xD;&#xA;        {&#xD;&#xA;            get { return _y; }&#xD;&#xA;            set { SetField(ref _y, value); }&#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        //use the CalculatedProperty annotation for properties that depend on other properties and pass it the prop names that it depends on&#xD;&#xA;        [CalculatedProperty(""X"", ""Y"")]&#xD;&#xA;        public int Z&#xD;&#xA;        {&#xD;&#xA;            get { return X * Y; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        [CalculatedProperty(""Z"")]&#xD;&#xA;        public int M&#xD;&#xA;        {&#xD;&#xA;            get { return Y * Z; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note that:&#xD;&#xA;&#xD;&#xA; - it uses reflection only once per type&#xD;&#xA; - `SetField` sets the field and raises property changed if there is a new value&#xD;&#xA; - you don't need to pass property name to `SetField` as long as you call it within a setter because the&#xD;&#xA;   `[CallerMemberName]` does it for you since c# 5.0.&#xD;&#xA; - if you call `SetField` outside the setter then you will have to pass&#xD;&#xA;   it the property name&#xD;&#xA; - if a property depends on itself you get a stackoverflow ;)&#xD;&#xA; - as per my last update you can avoid using `SetField` by setting the field directly and then&#xD;&#xA;   calling OnPropertyChanged(""PropertyName"") and it will raise&#xD;&#xA;   PropertyChanged for all properties for all properties that are&#xD;&#xA;   dependant on it.&#xD;&#xA; - in c# 6 you can use the nameof operator to get the property name such&#xD;&#xA;   as `nameof(Property)`&#xD;&#xA; - `OnPropertyChanged` will call itself recusively if there are computed&#xD;&#xA;   properties&#xD;&#xA;&#xD;&#xA;XAML for testing&#xD;&#xA;&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     <StackPanel>&#xD;&#xA;            <TextBox Text=""{Binding X,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}""></TextBox>&#xD;&#xA;            <TextBox Text=""{Binding Y,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}""></TextBox>&#xD;&#xA;            <TextBlock Text=""{Binding Z,Mode=OneWay}""></TextBlock>&#xD;&#xA;            <TextBlock Text=""{Binding M,Mode=OneWay}""></TextBlock>&#xD;&#xA;        </StackPanel>";;added 89 characters in body
88919594;29535537;4584812;5;4b4b6e8e-9d97-4a58-8d1e-6922dcb32cc5;2015-04-24 10:19:34.0;"I wrote this a while ago an it has been working great&#xD;&#xA;&#xD;&#xA;        [AttributeUsage(AttributeTargets.Property, Inherited = false)]&#xD;&#xA;        public class CalculatedProperty : Attribute&#xD;&#xA;        {&#xD;&#xA;            private string[] _props;&#xD;&#xA;            public CalculatedProperty(params string[] props)&#xD;&#xA;            {&#xD;&#xA;                this._props = props;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public string[] Properties&#xD;&#xA;            {&#xD;&#xA;                get&#xD;&#xA;                {&#xD;&#xA;                    return _props;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;The ViewModel base&#xD;&#xA;&#xD;&#xA;        public class ObservableObject : INotifyPropertyChanged&#xD;&#xA;        {&#xD;&#xA;            private static Dictionary<string, Dictionary<string, string[]>> calculatedPropertiesOfTypes = new Dictionary<string, Dictionary<string, string[]>>();&#xD;&#xA;    &#xD;&#xA;            private readonly bool hasComputedProperties;&#xD;&#xA;            public ObservableObject()&#xD;&#xA;            {&#xD;&#xA;                Type t = GetType();&#xD;&#xA;                if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                {&#xD;&#xA;                    var props = t.GetProperties();&#xD;&#xA;    &#xD;&#xA;                    foreach (var pInfo in props)&#xD;&#xA;                    {&#xD;&#xA;                        var attr = pInfo.GetCustomAttribute<CalculatedProperty>(false);&#xD;&#xA;                        if (attr == null)&#xD;&#xA;                            continue;&#xD;&#xA;    &#xD;&#xA;                        if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                        {&#xD;&#xA;                            calculatedPropertiesOfTypes[t.FullName] = new Dictionary<string, string[]>();&#xD;&#xA;                        }&#xD;&#xA;                        calculatedPropertiesOfTypes[t.FullName][pInfo.Name] = attr.Properties;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                if (calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                    hasComputedProperties = true;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;            public event PropertyChangedEventHandler PropertyChanged;&#xD;&#xA;            public virtual void OnPropertyChanged(string propertyName)&#xD;&#xA;            {&#xD;&#xA;                PropertyChangedEventHandler handler = PropertyChanged;&#xD;&#xA;                if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));&#xD;&#xA;    &#xD;&#xA;                if (this.hasComputedProperties)&#xD;&#xA;                {&#xD;&#xA;                    //check for any computed properties that depend on this property&#xD;&#xA;                    var computedPropNames =&#xD;&#xA;                        calculatedPropertiesOfTypes[this.GetType().FullName]&#xD;&#xA;                        .Where(kvp => kvp.Value.Contains(propertyName))&#xD;&#xA;                        .Select(kvp => kvp.Key);&#xD;&#xA;    &#xD;&#xA;                    if (computedPropNames != null)&#xD;&#xA;                        if (!computedPropNames.Any())&#xD;&#xA;                            return;&#xD;&#xA;    &#xD;&#xA;                    //raise property changed for every computed property that is dependant on the property we did just set&#xD;&#xA;                    foreach (var computedPropName in computedPropNames)&#xD;&#xA;                    {&#xD;&#xA;                        //to avoid stackoverflow as a result of infinite recursion if a property depends on itself!&#xD;&#xA;                        if (computedPropName == propertyName)&#xD;&#xA;                          continue; &#xD;&#xA;                       &#xD;&#xA;                        OnPropertyChanged(computedPropName);&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;            protected bool SetField<T>(ref T field, T value, [CallerMemberName] string propertyName = null)&#xD;&#xA;            {&#xD;&#xA;                if (EqualityComparer<T>.Default.Equals(field, value))&#xD;&#xA;                    return false;&#xD;&#xA;    &#xD;&#xA;                field = value;&#xD;&#xA;                OnPropertyChanged(propertyName);&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;Example:&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;    public class ViewModel : ObservableObject&#xD;&#xA;    {&#xD;&#xA;        private int _x;&#xD;&#xA;        public int X&#xD;&#xA;        {&#xD;&#xA;            get { return _x; }&#xD;&#xA;            set { SetField(ref _x, value); }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        private int _y;&#xD;&#xA;    &#xD;&#xA;        public int Y&#xD;&#xA;        {&#xD;&#xA;            get { return _y; }&#xD;&#xA;            set { SetField(ref _y, value); }&#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        //use the CalculatedProperty annotation for properties that depend on other properties and pass it the prop names that it depends on&#xD;&#xA;        [CalculatedProperty(""X"", ""Y"")]&#xD;&#xA;        public int Z&#xD;&#xA;        {&#xD;&#xA;            get { return X * Y; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        [CalculatedProperty(""Z"")]&#xD;&#xA;        public int M&#xD;&#xA;        {&#xD;&#xA;            get { return Y * Z; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note that:&#xD;&#xA;&#xD;&#xA; - it uses reflection only once per type&#xD;&#xA; - `SetField` sets the field and raises property changed if there is a new value&#xD;&#xA; - you don't need to pass property name to `SetField` as long as you call it within a setter because the&#xD;&#xA;   `[CallerMemberName]` does it for you since c# 5.0.&#xD;&#xA; - if you call `SetField` outside the setter then you will have to pass&#xD;&#xA;   it the property name&#xD;&#xA; - if a property depends on itself you get a stackoverflow ;), so i added a check to avoid that inside `OnPropertyChanged` but still don't do it.&#xD;&#xA; - as per my last update you can avoid using `SetField` by setting the field directly and then&#xD;&#xA;   calling OnPropertyChanged(""PropertyName"") and it will raise&#xD;&#xA;   PropertyChanged for all properties that are&#xD;&#xA;   dependant on it.&#xD;&#xA; - in c# 6 you can use the nameof operator to get the property name such&#xD;&#xA;   as `nameof(Property)`&#xD;&#xA; - `OnPropertyChanged` will call itself recusively if there are computed&#xD;&#xA;   properties&#xD;&#xA;&#xD;&#xA;XAML for testing&#xD;&#xA;&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     <StackPanel>&#xD;&#xA;            <TextBox Text=""{Binding X,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}""></TextBox>&#xD;&#xA;            <TextBox Text=""{Binding Y,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}""></TextBox>&#xD;&#xA;            <TextBlock Text=""{Binding Z,Mode=OneWay}""></TextBlock>&#xD;&#xA;            <TextBlock Text=""{Binding M,Mode=OneWay}""></TextBlock>&#xD;&#xA;        </StackPanel>";;added 327 characters in body
117797324;29535537;1545777;5;24b84081-34c0-431c-aa3b-d20a4c9f6f1e;2016-05-11 07:42:24.0;"I wrote this a while ago an it has been working great&#xD;&#xA;&#xD;&#xA;    [AttributeUsage(AttributeTargets.Property, Inherited = false)]&#xD;&#xA;    public class CalculatedProperty : Attribute&#xD;&#xA;    {&#xD;&#xA;        private string[] _props;&#xD;&#xA;        public CalculatedProperty(params string[] props)&#xD;&#xA;        {&#xD;&#xA;            this._props = props;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public string[] Properties&#xD;&#xA;        {&#xD;&#xA;            get&#xD;&#xA;            {&#xD;&#xA;                return _props;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The ViewModel base&#xD;&#xA;&#xD;&#xA;    public class ObservableObject : INotifyPropertyChanged&#xD;&#xA;    {&#xD;&#xA;        private static Dictionary<string, Dictionary<string, string[]>> calculatedPropertiesOfTypes = new Dictionary<string, Dictionary<string, string[]>>();&#xD;&#xA;&#xD;&#xA;        private readonly bool hasComputedProperties;&#xD;&#xA;        public ObservableObject()&#xD;&#xA;        {&#xD;&#xA;            Type t = GetType();&#xD;&#xA;            if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;            {&#xD;&#xA;                var props = t.GetProperties();&#xD;&#xA;&#xD;&#xA;                foreach (var pInfo in props)&#xD;&#xA;                {&#xD;&#xA;                    var attr = pInfo.GetCustomAttribute<CalculatedProperty>(false);&#xD;&#xA;                    if (attr == null)&#xD;&#xA;                        continue;&#xD;&#xA;&#xD;&#xA;                    if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                    {&#xD;&#xA;                        calculatedPropertiesOfTypes[t.FullName] = new Dictionary<string, string[]>();&#xD;&#xA;                    }&#xD;&#xA;                    calculatedPropertiesOfTypes[t.FullName][pInfo.Name] = attr.Properties;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            if (calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                hasComputedProperties = true;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;        public event PropertyChangedEventHandler PropertyChanged;&#xD;&#xA;        public virtual void OnPropertyChanged(string propertyName)&#xD;&#xA;        {&#xD;&#xA;            PropertyChangedEventHandler handler = PropertyChanged;&#xD;&#xA;            if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));&#xD;&#xA;&#xD;&#xA;            if (this.hasComputedProperties)&#xD;&#xA;            {&#xD;&#xA;                //check for any computed properties that depend on this property&#xD;&#xA;                var computedPropNames =&#xD;&#xA;                    calculatedPropertiesOfTypes[this.GetType().FullName]&#xD;&#xA;                    .Where(kvp => kvp.Value.Contains(propertyName))&#xD;&#xA;                    .Select(kvp => kvp.Key);&#xD;&#xA;&#xD;&#xA;                if (computedPropNames != null)&#xD;&#xA;                    if (!computedPropNames.Any())&#xD;&#xA;                        return;&#xD;&#xA;&#xD;&#xA;                //raise property changed for every computed property that is dependant on the property we did just set&#xD;&#xA;                foreach (var computedPropName in computedPropNames)&#xD;&#xA;                {&#xD;&#xA;                    //to avoid stackoverflow as a result of infinite recursion if a property depends on itself!&#xD;&#xA;                    if (computedPropName == propertyName)&#xD;&#xA;                      continue; &#xD;&#xA;                   &#xD;&#xA;                    OnPropertyChanged(computedPropName);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;        protected bool SetField<T>(ref T field, T value, [CallerMemberName] string propertyName = null)&#xD;&#xA;        {&#xD;&#xA;            if (EqualityComparer<T>.Default.Equals(field, value))&#xD;&#xA;                return false;&#xD;&#xA;&#xD;&#xA;            field = value;&#xD;&#xA;            OnPropertyChanged(propertyName);&#xD;&#xA;            return true;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example:&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;    public class ViewModel : ObservableObject&#xD;&#xA;    {&#xD;&#xA;        private int _x;&#xD;&#xA;        public int X&#xD;&#xA;        {&#xD;&#xA;            get { return _x; }&#xD;&#xA;            set { SetField(ref _x, value); }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        private int _y;&#xD;&#xA;    &#xD;&#xA;        public int Y&#xD;&#xA;        {&#xD;&#xA;            get { return _y; }&#xD;&#xA;            set { SetField(ref _y, value); }&#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        //use the CalculatedProperty annotation for properties that depend on other properties and pass it the prop names that it depends on&#xD;&#xA;        [CalculatedProperty(""X"", ""Y"")]&#xD;&#xA;        public int Z&#xD;&#xA;        {&#xD;&#xA;            get { return X * Y; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        [CalculatedProperty(""Z"")]&#xD;&#xA;        public int M&#xD;&#xA;        {&#xD;&#xA;            get { return Y * Z; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note that:&#xD;&#xA;&#xD;&#xA; - it uses reflection only once per type&#xD;&#xA; - `SetField` sets the field and raises property changed if there is a new value&#xD;&#xA; - you don't need to pass property name to `SetField` as long as you call it within a setter because the&#xD;&#xA;   `[CallerMemberName]` does it for you since c# 5.0.&#xD;&#xA; - if you call `SetField` outside the setter then you will have to pass&#xD;&#xA;   it the property name&#xD;&#xA; - if a property depends on itself you get a stackoverflow ;), so i added a check to avoid that inside `OnPropertyChanged` but still don't do it.&#xD;&#xA; - as per my last update you can avoid using `SetField` by setting the field directly and then&#xD;&#xA;   calling OnPropertyChanged(""PropertyName"") and it will raise&#xD;&#xA;   PropertyChanged for all properties that are&#xD;&#xA;   dependant on it.&#xD;&#xA; - in c# 6 you can use the nameof operator to get the property name such&#xD;&#xA;   as `nameof(Property)`&#xD;&#xA; - `OnPropertyChanged` will call itself recusively if there are computed&#xD;&#xA;   properties&#xD;&#xA;&#xD;&#xA;XAML for testing&#xD;&#xA;&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;    <StackPanel>&#xD;&#xA;        <TextBox Text=""{Binding X,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}""></TextBox>&#xD;&#xA;        <TextBox Text=""{Binding Y,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}""></TextBox>&#xD;&#xA;        <TextBlock Text=""{Binding Z,Mode=OneWay}""></TextBlock>&#xD;&#xA;        <TextBlock Text=""{Binding M,Mode=OneWay}""></TextBlock>&#xD;&#xA;    </StackPanel>";;deleted 350 characters in body
141877406;29535537;4584812;5;c19c66fc-eab1-498b-b625-013fd4d4abd3;2017-03-30 01:08:16.0;"I wrote this a while ago an it has been working great&#xD;&#xA;&#xD;&#xA;    [AttributeUsage(AttributeTargets.Property, Inherited = false)]&#xD;&#xA;    public class CalculatedProperty : Attribute&#xD;&#xA;    {&#xD;&#xA;        private string[] _props;&#xD;&#xA;        public CalculatedProperty(params string[] props)&#xD;&#xA;        {&#xD;&#xA;            this._props = props;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public string[] Properties&#xD;&#xA;        {&#xD;&#xA;            get&#xD;&#xA;            {&#xD;&#xA;                return _props;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The ViewModel base&#xD;&#xA;&#xD;&#xA;    public class ObservableObject : INotifyPropertyChanged&#xD;&#xA;    {&#xD;&#xA;        private static Dictionary<string, Dictionary<string, string[]>> calculatedPropertiesOfTypes = new Dictionary<string, Dictionary<string, string[]>>();&#xD;&#xA;&#xD;&#xA;        private readonly bool hasComputedProperties;&#xD;&#xA;        public ObservableObject()&#xD;&#xA;        {&#xD;&#xA;            Type t = GetType();&#xD;&#xA;            if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;            {&#xD;&#xA;                var props = t.GetProperties();&#xD;&#xA;&#xD;&#xA;                foreach (var pInfo in props)&#xD;&#xA;                {&#xD;&#xA;                    var attr = pInfo.GetCustomAttribute<CalculatedProperty>(false);&#xD;&#xA;                    if (attr == null)&#xD;&#xA;                        continue;&#xD;&#xA;&#xD;&#xA;                    if (!calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                    {&#xD;&#xA;                        calculatedPropertiesOfTypes[t.FullName] = new Dictionary<string, string[]>();&#xD;&#xA;                    }&#xD;&#xA;                    calculatedPropertiesOfTypes[t.FullName][pInfo.Name] = attr.Properties;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            if (calculatedPropertiesOfTypes.ContainsKey(t.FullName))&#xD;&#xA;                hasComputedProperties = true;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;        public event PropertyChangedEventHandler PropertyChanged;&#xD;&#xA;        public virtual void OnPropertyChanged(string propertyName)&#xD;&#xA;        {&#xD;&#xA;            PropertyChangedEventHandler handler = PropertyChanged;&#xD;&#xA;            if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));&#xD;&#xA;&#xD;&#xA;            if (this.hasComputedProperties)&#xD;&#xA;            {&#xD;&#xA;                //check for any computed properties that depend on this property&#xD;&#xA;                var computedPropNames =&#xD;&#xA;                    calculatedPropertiesOfTypes[this.GetType().FullName]&#xD;&#xA;                    .Where(kvp => kvp.Value.Contains(propertyName))&#xD;&#xA;                    .Select(kvp => kvp.Key);&#xD;&#xA;&#xD;&#xA;                if (computedPropNames != null)&#xD;&#xA;                    if (!computedPropNames.Any())&#xD;&#xA;                        return;&#xD;&#xA;&#xD;&#xA;                //raise property changed for every computed property that is dependant on the property we did just set&#xD;&#xA;                foreach (var computedPropName in computedPropNames)&#xD;&#xA;                {&#xD;&#xA;                    //to avoid stackoverflow as a result of infinite recursion if a property depends on itself!&#xD;&#xA;                    if (computedPropName == propertyName)&#xD;&#xA;                      throw new InvalidOperationException(""A property can't depend on itself"");&#xD;&#xA;                   &#xD;&#xA;                    OnPropertyChanged(computedPropName);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;        protected bool SetField<T>(ref T field, T value, [CallerMemberName] string propertyName = null)&#xD;&#xA;        {&#xD;&#xA;            if (EqualityComparer<T>.Default.Equals(field, value))&#xD;&#xA;                return false;&#xD;&#xA;&#xD;&#xA;            field = value;&#xD;&#xA;            OnPropertyChanged(propertyName);&#xD;&#xA;            return true;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example:&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;    public class ViewModel : ObservableObject&#xD;&#xA;    {&#xD;&#xA;        private int _x;&#xD;&#xA;        public int X&#xD;&#xA;        {&#xD;&#xA;            get { return _x; }&#xD;&#xA;            set { SetField(ref _x, value); }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        private int _y;&#xD;&#xA;    &#xD;&#xA;        public int Y&#xD;&#xA;        {&#xD;&#xA;            get { return _y; }&#xD;&#xA;            set { SetField(ref _y, value); }&#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        //use the CalculatedProperty annotation for properties that depend on other properties and pass it the prop names that it depends on&#xD;&#xA;        [CalculatedProperty(""X"", ""Y"")]&#xD;&#xA;        public int Z&#xD;&#xA;        {&#xD;&#xA;            get { return X * Y; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        [CalculatedProperty(""Z"")]&#xD;&#xA;        public int M&#xD;&#xA;        {&#xD;&#xA;            get { return Y * Z; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note that:&#xD;&#xA;&#xD;&#xA; - it uses reflection only once per type&#xD;&#xA; - `SetField` sets the field and raises property changed if there is a new value&#xD;&#xA; - you don't need to pass property name to `SetField` as long as you call it within a setter because the&#xD;&#xA;   `[CallerMemberName]` does it for you since c# 5.0.&#xD;&#xA; - if you call `SetField` outside the setter then you will have to pass&#xD;&#xA;   it the property name&#xD;&#xA; - as per my last update you can avoid using `SetField` by setting the field directly and then&#xD;&#xA;   calling OnPropertyChanged(""PropertyName"") and it will raise&#xD;&#xA;   PropertyChanged for all properties that are&#xD;&#xA;   dependant on it.&#xD;&#xA; - in c# 6 you can use the nameof operator to get the property name such&#xD;&#xA;   as `nameof(Property)`&#xD;&#xA; - `OnPropertyChanged` will call itself recusively if there are computed&#xD;&#xA;   properties&#xD;&#xA;&#xD;&#xA;XAML for testing&#xD;&#xA;&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;    <StackPanel>&#xD;&#xA;        <TextBox Text=""{Binding X,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}""></TextBox>&#xD;&#xA;        <TextBox Text=""{Binding Y,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}""></TextBox>&#xD;&#xA;        <TextBlock Text=""{Binding Z,Mode=OneWay}""></TextBlock>&#xD;&#xA;        <TextBlock Text=""{Binding M,Mode=OneWay}""></TextBlock>&#xD;&#xA;    </StackPanel>";;deleted 84 characters in body
