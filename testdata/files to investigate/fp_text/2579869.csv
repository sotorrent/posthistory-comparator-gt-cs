Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
5276894;2579869;165737;2;e0f52e8d-7964-46b2-9513-378fafb78d78;2010-04-05 17:31:27.0;"Text nodes have a `nodeType` value of 3. You could iterate over all nodes and include only those that have a `nodeType` 3. Also, you might find this discussion helpful - http://bytes.com/topic/javascript/answers/153239-how-do-i-get-elements-text-node&#xD;&#xA;&#xD;&#xA;One of the answers mentions using a `TreeWalker` to iterate the DOM and get only text nodes out. IE will most certainly not support this, so this is not cross-browser. [Example here][1].&#xD;&#xA;&#xD;&#xA;    var walker = document.createTreeWalker(&#xD;&#xA;        document.body, NodeFilter.SHOW_TEXT, null, false&#xD;&#xA;    );&#xD;&#xA;&#xD;&#xA;    var node;&#xD;&#xA;    var textNodes = [];&#xD;&#xA;    &#xD;&#xA;    while(node = walker.nextNode()) {&#xD;&#xA;        textNodes.push(node.nodeValue);&#xD;&#xA;    }    ​&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://jsfiddle.net/NnxAG/";;
5277035;2579869;165737;5;a905093b-8d83-4dd9-a270-456619898ff2;2010-04-05 17:42:50.0;"Text nodes have a [`nodeType`][1] value of 3. You could iterate over all nodes and include only those that have a `nodeType` 3. Also, you might find this discussion helpful - http://bytes.com/topic/javascript/answers/153239-how-do-i-get-elements-text-node&#xD;&#xA;&#xD;&#xA;One of the answers mentions using a `TreeWalker` to iterate the DOM and get only text nodes out. IE will most certainly not support this, so this is not cross-browser. [Example here][2].&#xD;&#xA;&#xD;&#xA;    var walker = document.createTreeWalker(&#xD;&#xA;        document.body, NodeFilter.SHOW_TEXT, null, false&#xD;&#xA;    );&#xD;&#xA;&#xD;&#xA;    var node;&#xD;&#xA;    var textNodes = [];&#xD;&#xA;    &#xD;&#xA;    while(node = walker.nextNode()) {&#xD;&#xA;        textNodes.push(node.nodeValue);&#xD;&#xA;    }    ​&#xD;&#xA;&#xD;&#xA;Here is another hopefully cross-browser implementation for this. It traverses from a root node recursively and accumulates the content of all text nodes in an array. [Example here][3].&#xD;&#xA;&#xD;&#xA;    function textNodes(root) {&#xD;&#xA;    &#xD;&#xA;        var result = [];&#xD;&#xA;        &#xD;&#xA;        (function findTextNodes(current) {&#xD;&#xA;            for(var i = 0; i < current.childNodes.length; i++) {&#xD;&#xA;                var child = current.childNodes[i];&#xD;&#xA;                if(child.nodeType == 3) {&#xD;&#xA;                    result.push(child.nodeValue);&#xD;&#xA;                }&#xD;&#xA;                else {&#xD;&#xA;                    findTextNodes(child);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        })(root);&#xD;&#xA;        &#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    var result = textNodes(document.body);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://developer.mozilla.org/en/nodeType&#xD;&#xA;  [2]: http://jsfiddle.net/NnxAG/&#xD;&#xA;  [3]: http://jsfiddle.net/p6f4v/";;added 840 characters in body
5282377;2579869;165737;5;fcc8d05b-95b0-4c9f-9a96-fc7381c95835;2010-04-06 03:06:44.0;"**Update**:&#xD;&#xA;&#xD;&#xA;I have outlined some basic performance tests for each of these 6 methods over 1000 runs. `getElementsByTagName` is the fastest but it does a half-assed job, as it does not select all elements, but only one particular type of tag ( i think `p`) and blindly assumes that its firstChild is a text element. It might be little flawed but its there for demonstration purpose and comparing its performance to `TreeWalker`. [Run the tests yourselves on jsfiddle][4] to see the results.&#xD;&#xA;&#xD;&#xA; 1. Using a TreeWalker&#xD;&#xA; 2. Custom Iterative Traversal&#xD;&#xA; 3. Custom Recursive Traversal&#xD;&#xA; 4. Xpath query&#xD;&#xA; 5. querySelectorAll&#xD;&#xA; 6. getElementsByTagName&#xD;&#xA;&#xD;&#xA;Let's assume for a moment that there is a method that allows you to get all `Text` nodes natively. You would still have to traverse each resulting text node and call `node.nodeValue` to get the actual text as you would do with any DOM Node. So the issue of performance is not with iterating through text nodes, but iterating through all nodes that are not text and checking their type. I would argue (based on the results) that `TreeWalker` performs just as fast as `getElementsByTagName`, if not faster (even with getElementsByTagName playing handicapped).&#xD;&#xA;&#xD;&#xA;<pre>&#xD;&#xA;Ran each test 1000 times.&#xD;&#xA;&#xD;&#xA;Method                  Total ms        Average ms&#xD;&#xA;--------------------------------------------------&#xD;&#xA;document.TreeWalker          816             0.816&#xD;&#xA;Iterative Traverser         2518             2.518&#xD;&#xA;Recursive Traverser        21556            21.556&#xD;&#xA;XPath query                 5087             5.087&#xD;&#xA;querySelectorAll            5352             5.352&#xD;&#xA;getElementsByTagName         660              0.66&#xD;&#xA;</pre>&#xD;&#xA;&#xD;&#xA;<hr />&#xD;&#xA;&#xD;&#xA;Source for each method:&#xD;&#xA;&#xD;&#xA;**TreeWalker**&#xD;&#xA;&#xD;&#xA;    function nativeTreeWalker() {&#xD;&#xA;        var walker = document.createTreeWalker(&#xD;&#xA;            document.body, &#xD;&#xA;            NodeFilter.SHOW_TEXT, &#xD;&#xA;            null, &#xD;&#xA;            false&#xD;&#xA;        );&#xD;&#xA;        &#xD;&#xA;        var node;&#xD;&#xA;        var textNodes = [];&#xD;&#xA;    &#xD;&#xA;        while(node = walker.nextNode()) {&#xD;&#xA;            textNodes.push(node.nodeValue);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Recursive Tree Traversal**&#xD;&#xA;&#xD;&#xA;    function customRecursiveTreeWalker() {&#xD;&#xA;        var result = [];&#xD;&#xA;    &#xD;&#xA;        (function findTextNodes(current) {&#xD;&#xA;            for(var i = 0; i < current.childNodes.length; i++) {&#xD;&#xA;                var child = current.childNodes[i];&#xD;&#xA;                if(child.nodeType == 3) {&#xD;&#xA;                    result.push(child.nodeValue);&#xD;&#xA;                }&#xD;&#xA;                else {&#xD;&#xA;                    findTextNodes(child);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        })(document.body);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Iterative Tree Traversal**&#xD;&#xA;&#xD;&#xA;    function customIterativeTreeWalker() {&#xD;&#xA;        var result = [];&#xD;&#xA;        var root = document.body;&#xD;&#xA;        &#xD;&#xA;        var node = root.childNodes[0];&#xD;&#xA;        while(node != null) {&#xD;&#xA;            if(node.nodeType = 3) {&#xD;&#xA;                result.push(node.nodeValue);&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            if(node.hasChildNodes()) {&#xD;&#xA;                node = node.firstChild;&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                while(node.nextSibling == null && node != root) {&#xD;&#xA;                    node = node.parentNode;&#xD;&#xA;                }&#xD;&#xA;                node = node.nextSibling;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**querySelectorAll**&#xD;&#xA;&#xD;&#xA;    function nativeSelector() {&#xD;&#xA;        var elements = document.querySelectorAll(""body *"");&#xD;&#xA;        var results = [];&#xD;&#xA;        var child;&#xD;&#xA;        for(var i = 0; i < elements.length; i++) {&#xD;&#xA;            child = elements[i].childNodes[0];&#xD;&#xA;            if(elements[i].hasChildNodes() && child.nodeType == 3) {&#xD;&#xA;                results.push(child.nodeValue);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**getElementsByTagName**&#xD;&#xA;&#xD;&#xA;    function getElementsByTagName() {&#xD;&#xA;        var elements = document.getElementsByTagName(""p"");&#xD;&#xA;        var results = [];&#xD;&#xA;        for(var i = 0; i < elements.length; i++) {&#xD;&#xA;            results.push(elements[i].childNodes[0].nodeValue);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**XPath**&#xD;&#xA;&#xD;&#xA;    function xpathSelector() {&#xD;&#xA;        var xpathResult = document.evaluate(&#xD;&#xA;            ""//*/text()"", &#xD;&#xA;            document, &#xD;&#xA;            null, &#xD;&#xA;            XPathResult.ORDERED_NODE_ITERATOR_TYPE, &#xD;&#xA;            null&#xD;&#xA;        );&#xD;&#xA;        &#xD;&#xA;        var results = [], res;&#xD;&#xA;        while(res = xpathResult.iterateNext()) {&#xD;&#xA;            results.push(res);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Also, you might find this discussion helpful - http://bytes.com/topic/javascript/answers/153239-how-do-i-get-elements-text-node&#xD;&#xA;&#xD;&#xA;  [1]: https://developer.mozilla.org/en/nodeType&#xD;&#xA;  [2]: http://jsfiddle.net/NnxAG/&#xD;&#xA;  [3]: http://jsfiddle.net/p6f4v/&#xD;&#xA;  [4]: http://jsfiddle.net/zaqtg/1/&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;"added 3219 characters in body; deleted 128 characters in body"
5282660;2579869;165737;5;92b671ad-5766-4648-8e86-91eb32cefe8e;2010-04-06 03:55:29.0;"**Update**:&#xD;&#xA;&#xD;&#xA;I have outlined some basic performance tests for each of these 6 methods over 1000 runs. `getElementsByTagName` is the fastest but it does a half-assed job, as it does not select all elements, but only one particular type of tag ( i think `p`) and blindly assumes that its firstChild is a text element. It might be little flawed but its there for demonstration purpose and comparing its performance to `TreeWalker`. [Run the tests yourselves on jsfiddle][4] to see the results.&#xD;&#xA;&#xD;&#xA; 1. Using a TreeWalker&#xD;&#xA; 2. Custom Iterative Traversal&#xD;&#xA; 3. Custom Recursive Traversal&#xD;&#xA; 4. Xpath query&#xD;&#xA; 5. querySelectorAll&#xD;&#xA; 6. getElementsByTagName&#xD;&#xA;&#xD;&#xA;Let's assume for a moment that there is a method that allows you to get all `Text` nodes natively. You would still have to traverse each resulting text node and call `node.nodeValue` to get the actual text as you would do with any DOM Node. So the issue of performance is not with iterating through text nodes, but iterating through all nodes that are not text and checking their type. I would argue (based on the results) that `TreeWalker` performs just as fast as `getElementsByTagName`, if not faster (even with getElementsByTagName playing handicapped).&#xD;&#xA;&#xD;&#xA;<pre>&#xD;&#xA;Ran each test 1000 times.&#xD;&#xA;&#xD;&#xA;Method                  Total ms        Average ms&#xD;&#xA;--------------------------------------------------&#xD;&#xA;document.TreeWalker          816             0.816&#xD;&#xA;Iterative Traverser         2518             2.518&#xD;&#xA;Recursive Traverser        21556            21.556&#xD;&#xA;XPath query                 5087             5.087&#xD;&#xA;querySelectorAll            5352             5.352&#xD;&#xA;getElementsByTagName         660              0.66&#xD;&#xA;</pre>&#xD;&#xA;&#xD;&#xA;<hr />&#xD;&#xA;&#xD;&#xA;Source for each method:&#xD;&#xA;&#xD;&#xA;**TreeWalker**&#xD;&#xA;&#xD;&#xA;    function nativeTreeWalker() {&#xD;&#xA;        var walker = document.createTreeWalker(&#xD;&#xA;            document.body, &#xD;&#xA;            NodeFilter.SHOW_TEXT, &#xD;&#xA;            null, &#xD;&#xA;            false&#xD;&#xA;        );&#xD;&#xA;        &#xD;&#xA;        var node;&#xD;&#xA;        var textNodes = [];&#xD;&#xA;    &#xD;&#xA;        while(node = walker.nextNode()) {&#xD;&#xA;            textNodes.push(node.nodeValue);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Recursive Tree Traversal**&#xD;&#xA;&#xD;&#xA;    function customRecursiveTreeWalker() {&#xD;&#xA;        var result = [];&#xD;&#xA;    &#xD;&#xA;        (function findTextNodes(current) {&#xD;&#xA;            for(var i = 0; i < current.childNodes.length; i++) {&#xD;&#xA;                var child = current.childNodes[i];&#xD;&#xA;                if(child.nodeType == 3) {&#xD;&#xA;                    result.push(child.nodeValue);&#xD;&#xA;                }&#xD;&#xA;                else {&#xD;&#xA;                    findTextNodes(child);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        })(document.body);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Iterative Tree Traversal**&#xD;&#xA;&#xD;&#xA;    function customIterativeTreeWalker() {&#xD;&#xA;        var result = [];&#xD;&#xA;        var root = document.body;&#xD;&#xA;        &#xD;&#xA;        var node = root.childNodes[0];&#xD;&#xA;        while(node != null) {&#xD;&#xA;            if(node.nodeType = 3) {&#xD;&#xA;                result.push(node.nodeValue);&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            if(node.hasChildNodes()) {&#xD;&#xA;                node = node.firstChild;&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                while(node.nextSibling == null && node != root) {&#xD;&#xA;                    node = node.parentNode;&#xD;&#xA;                }&#xD;&#xA;                node = node.nextSibling;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**querySelectorAll**&#xD;&#xA;&#xD;&#xA;    function nativeSelector() {&#xD;&#xA;        var elements = document.querySelectorAll(""body *"");&#xD;&#xA;        var results = [];&#xD;&#xA;        var child;&#xD;&#xA;        for(var i = 0; i < elements.length; i++) {&#xD;&#xA;            child = elements[i].childNodes[0];&#xD;&#xA;            if(elements[i].hasChildNodes() && child.nodeType == 3) {&#xD;&#xA;                results.push(child.nodeValue);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**getElementsByTagName** (handicap)&#xD;&#xA;&#xD;&#xA;    function getElementsByTagName() {&#xD;&#xA;        var elements = document.getElementsByTagName(""p"");&#xD;&#xA;        var results = [];&#xD;&#xA;        for(var i = 0; i < elements.length; i++) {&#xD;&#xA;            results.push(elements[i].childNodes[0].nodeValue);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**XPath**&#xD;&#xA;&#xD;&#xA;    function xpathSelector() {&#xD;&#xA;        var xpathResult = document.evaluate(&#xD;&#xA;            ""//*/text()"", &#xD;&#xA;            document, &#xD;&#xA;            null, &#xD;&#xA;            XPathResult.ORDERED_NODE_ITERATOR_TYPE, &#xD;&#xA;            null&#xD;&#xA;        );&#xD;&#xA;        &#xD;&#xA;        var results = [], res;&#xD;&#xA;        while(res = xpathResult.iterateNext()) {&#xD;&#xA;            results.push(res);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Also, you might find this discussion helpful - http://bytes.com/topic/javascript/answers/153239-how-do-i-get-elements-text-node&#xD;&#xA;&#xD;&#xA;  [1]: https://developer.mozilla.org/en/nodeType&#xD;&#xA;  [2]: http://jsfiddle.net/NnxAG/&#xD;&#xA;  [3]: http://jsfiddle.net/p6f4v/&#xD;&#xA;  [4]: http://jsfiddle.net/zaqtg/1/&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 11 characters in body
26391973;2579869;165737;5;f6b6fd35-d32b-4522-a2c6-49300b346ac5;2012-07-06 03:11:10.0;"**Update**:&#xD;&#xA;&#xD;&#xA;I have outlined some basic performance tests for each of these 6 methods over 1000 runs. `getElementsByTagName` is the fastest but it does a half-assed job, as it does not select all elements, but only one particular type of tag ( i think `p`) and blindly assumes that its firstChild is a text element. It might be little flawed but its there for demonstration purpose and comparing its performance to `TreeWalker`. [Run the tests yourselves on jsfiddle][4] to see the results.&#xD;&#xA;&#xD;&#xA; 1. Using a TreeWalker&#xD;&#xA; 2. Custom Iterative Traversal&#xD;&#xA; 3. Custom Recursive Traversal&#xD;&#xA; 4. Xpath query&#xD;&#xA; 5. querySelectorAll&#xD;&#xA; 6. getElementsByTagName&#xD;&#xA;&#xD;&#xA;Let's assume for a moment that there is a method that allows you to get all `Text` nodes natively. You would still have to traverse each resulting text node and call `node.nodeValue` to get the actual text as you would do with any DOM Node. So the issue of performance is not with iterating through text nodes, but iterating through all nodes that are not text and checking their type. I would argue (based on the results) that `TreeWalker` performs just as fast as `getElementsByTagName`, if not faster (even with getElementsByTagName playing handicapped).&#xD;&#xA;&#xD;&#xA;<pre>&#xD;&#xA;Ran each test 1000 times.&#xD;&#xA;&#xD;&#xA;Method                  Total ms        Average ms&#xD;&#xA;--------------------------------------------------&#xD;&#xA;document.TreeWalker          816             0.816&#xD;&#xA;Iterative Traverser         2518             2.518&#xD;&#xA;Recursive Traverser        21556            21.556&#xD;&#xA;XPath query                 5087             5.087&#xD;&#xA;querySelectorAll            5352             5.352&#xD;&#xA;getElementsByTagName         660              0.66&#xD;&#xA;</pre>&#xD;&#xA;&#xD;&#xA;<hr />&#xD;&#xA;&#xD;&#xA;Source for each method:&#xD;&#xA;&#xD;&#xA;**TreeWalker**&#xD;&#xA;&#xD;&#xA;    function nativeTreeWalker() {&#xD;&#xA;        var walker = document.createTreeWalker(&#xD;&#xA;            document.body, &#xD;&#xA;            NodeFilter.SHOW_TEXT, &#xD;&#xA;            null, &#xD;&#xA;            false&#xD;&#xA;        );&#xD;&#xA;        &#xD;&#xA;        var node;&#xD;&#xA;        var textNodes = [];&#xD;&#xA;    &#xD;&#xA;        while(node = walker.nextNode()) {&#xD;&#xA;            textNodes.push(node.nodeValue);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Recursive Tree Traversal**&#xD;&#xA;&#xD;&#xA;    function customRecursiveTreeWalker() {&#xD;&#xA;        var result = [];&#xD;&#xA;    &#xD;&#xA;        (function findTextNodes(current) {&#xD;&#xA;            for(var i = 0; i < current.childNodes.length; i++) {&#xD;&#xA;                var child = current.childNodes[i];&#xD;&#xA;                if(child.nodeType == 3) {&#xD;&#xA;                    result.push(child.nodeValue);&#xD;&#xA;                }&#xD;&#xA;                else {&#xD;&#xA;                    findTextNodes(child);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        })(document.body);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Iterative Tree Traversal**&#xD;&#xA;&#xD;&#xA;    function customIterativeTreeWalker() {&#xD;&#xA;        var result = [];&#xD;&#xA;        var root = document.body;&#xD;&#xA;        &#xD;&#xA;        var node = root.childNodes[0];&#xD;&#xA;        while(node != null) {&#xD;&#xA;            if(node.nodeType == 3) { /* Fixed a bug here. Thanks @theazureshadow */&#xD;&#xA;                result.push(node.nodeValue);&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            if(node.hasChildNodes()) {&#xD;&#xA;                node = node.firstChild;&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                while(node.nextSibling == null && node != root) {&#xD;&#xA;                    node = node.parentNode;&#xD;&#xA;                }&#xD;&#xA;                node = node.nextSibling;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**querySelectorAll**&#xD;&#xA;&#xD;&#xA;    function nativeSelector() {&#xD;&#xA;        var elements = document.querySelectorAll(""body *"");&#xD;&#xA;        var results = [];&#xD;&#xA;        var child;&#xD;&#xA;        for(var i = 0; i < elements.length; i++) {&#xD;&#xA;            child = elements[i].childNodes[0];&#xD;&#xA;            if(elements[i].hasChildNodes() && child.nodeType == 3) {&#xD;&#xA;                results.push(child.nodeValue);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**getElementsByTagName** (handicap)&#xD;&#xA;&#xD;&#xA;    function getElementsByTagName() {&#xD;&#xA;        var elements = document.getElementsByTagName(""p"");&#xD;&#xA;        var results = [];&#xD;&#xA;        for(var i = 0; i < elements.length; i++) {&#xD;&#xA;            results.push(elements[i].childNodes[0].nodeValue);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**XPath**&#xD;&#xA;&#xD;&#xA;    function xpathSelector() {&#xD;&#xA;        var xpathResult = document.evaluate(&#xD;&#xA;            ""//*/text()"", &#xD;&#xA;            document, &#xD;&#xA;            null, &#xD;&#xA;            XPathResult.ORDERED_NODE_ITERATOR_TYPE, &#xD;&#xA;            null&#xD;&#xA;        );&#xD;&#xA;        &#xD;&#xA;        var results = [], res;&#xD;&#xA;        while(res = xpathResult.iterateNext()) {&#xD;&#xA;            results.push(res.nodeValue);  /* Fixed a bug here. Thanks @theazureshadow */&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Also, you might find this discussion helpful - http://bytes.com/topic/javascript/answers/153239-how-do-i-get-elements-text-node&#xD;&#xA;&#xD;&#xA;  [1]: https://developer.mozilla.org/en/nodeType&#xD;&#xA;  [2]: http://jsfiddle.net/NnxAG/&#xD;&#xA;  [3]: http://jsfiddle.net/p6f4v/&#xD;&#xA;  [4]: http://jsfiddle.net/zaqtg/1/&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;Fixed few bugs
26392083;2579869;165737;5;3ad9c13e-707b-4f7a-9ef9-dff375d8adce;2012-07-06 03:19:03.0;"**Update**:&#xD;&#xA;&#xD;&#xA;I have outlined some basic performance tests for each of these 6 methods over 1000 runs. `getElementsByTagName` is the fastest but it does a half-assed job, as it does not select all elements, but only one particular type of tag ( i think `p`) and blindly assumes that its firstChild is a text element. It might be little flawed but its there for demonstration purpose and comparing its performance to `TreeWalker`. [Run the tests yourselves on jsfiddle][4] to see the results.&#xD;&#xA;&#xD;&#xA; 1. Using a TreeWalker&#xD;&#xA; 2. Custom Iterative Traversal&#xD;&#xA; 3. Custom Recursive Traversal&#xD;&#xA; 4. Xpath query&#xD;&#xA; 5. querySelectorAll&#xD;&#xA; 6. getElementsByTagName&#xD;&#xA;&#xD;&#xA;Let's assume for a moment that there is a method that allows you to get all `Text` nodes natively. You would still have to traverse each resulting text node and call `node.nodeValue` to get the actual text as you would do with any DOM Node. So the issue of performance is not with iterating through text nodes, but iterating through all nodes that are not text and checking their type. I would argue (based on the results) that `TreeWalker` performs just as fast as `getElementsByTagName`, if not faster (even with getElementsByTagName playing handicapped).&#xD;&#xA;&#xD;&#xA;<pre>&#xD;&#xA;Ran each test 1000 times.&#xD;&#xA;&#xD;&#xA;Method                  Total ms        Average ms&#xD;&#xA;--------------------------------------------------&#xD;&#xA;document.TreeWalker	         301            0.301&#xD;&#xA;Iterative Traverser          769            0.769&#xD;&#xA;Recursive Traverser         7352            7.352&#xD;&#xA;XPath query                 1849            1.849&#xD;&#xA;querySelectorAll            1725            1.725&#xD;&#xA;getElementsByTagName         212            0.212&#xD;&#xA;</pre>&#xD;&#xA;&#xD;&#xA;<hr />&#xD;&#xA;&#xD;&#xA;Source for each method:&#xD;&#xA;&#xD;&#xA;**TreeWalker**&#xD;&#xA;&#xD;&#xA;    function nativeTreeWalker() {&#xD;&#xA;        var walker = document.createTreeWalker(&#xD;&#xA;            document.body, &#xD;&#xA;            NodeFilter.SHOW_TEXT, &#xD;&#xA;            null, &#xD;&#xA;            false&#xD;&#xA;        );&#xD;&#xA;        &#xD;&#xA;        var node;&#xD;&#xA;        var textNodes = [];&#xD;&#xA;    &#xD;&#xA;        while(node = walker.nextNode()) {&#xD;&#xA;            textNodes.push(node.nodeValue);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Recursive Tree Traversal**&#xD;&#xA;&#xD;&#xA;    function customRecursiveTreeWalker() {&#xD;&#xA;        var result = [];&#xD;&#xA;    &#xD;&#xA;        (function findTextNodes(current) {&#xD;&#xA;            for(var i = 0; i < current.childNodes.length; i++) {&#xD;&#xA;                var child = current.childNodes[i];&#xD;&#xA;                if(child.nodeType == 3) {&#xD;&#xA;                    result.push(child.nodeValue);&#xD;&#xA;                }&#xD;&#xA;                else {&#xD;&#xA;                    findTextNodes(child);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        })(document.body);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Iterative Tree Traversal**&#xD;&#xA;&#xD;&#xA;    function customIterativeTreeWalker() {&#xD;&#xA;        var result = [];&#xD;&#xA;        var root = document.body;&#xD;&#xA;        &#xD;&#xA;        var node = root.childNodes[0];&#xD;&#xA;        while(node != null) {&#xD;&#xA;            if(node.nodeType == 3) { /* Fixed a bug here. Thanks @theazureshadow */&#xD;&#xA;                result.push(node.nodeValue);&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            if(node.hasChildNodes()) {&#xD;&#xA;                node = node.firstChild;&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                while(node.nextSibling == null && node != root) {&#xD;&#xA;                    node = node.parentNode;&#xD;&#xA;                }&#xD;&#xA;                node = node.nextSibling;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**querySelectorAll**&#xD;&#xA;&#xD;&#xA;    function nativeSelector() {&#xD;&#xA;        var elements = document.querySelectorAll(""body *"");&#xD;&#xA;        var results = [];&#xD;&#xA;        var child;&#xD;&#xA;        for(var i = 0; i < elements.length; i++) {&#xD;&#xA;            child = elements[i].childNodes[0];&#xD;&#xA;            if(elements[i].hasChildNodes() && child.nodeType == 3) {&#xD;&#xA;                results.push(child.nodeValue);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**getElementsByTagName** (handicap)&#xD;&#xA;&#xD;&#xA;    function getElementsByTagName() {&#xD;&#xA;        var elements = document.getElementsByTagName(""p"");&#xD;&#xA;        var results = [];&#xD;&#xA;        for(var i = 0; i < elements.length; i++) {&#xD;&#xA;            results.push(elements[i].childNodes[0].nodeValue);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**XPath**&#xD;&#xA;&#xD;&#xA;    function xpathSelector() {&#xD;&#xA;        var xpathResult = document.evaluate(&#xD;&#xA;            ""//*/text()"", &#xD;&#xA;            document, &#xD;&#xA;            null, &#xD;&#xA;            XPathResult.ORDERED_NODE_ITERATOR_TYPE, &#xD;&#xA;            null&#xD;&#xA;        );&#xD;&#xA;        &#xD;&#xA;        var results = [], res;&#xD;&#xA;        while(res = xpathResult.iterateNext()) {&#xD;&#xA;            results.push(res.nodeValue);  /* Fixed a bug here. Thanks @theazureshadow */&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Also, you might find this discussion helpful - http://bytes.com/topic/javascript/answers/153239-how-do-i-get-elements-text-node&#xD;&#xA;&#xD;&#xA;  [1]: https://developer.mozilla.org/en/nodeType&#xD;&#xA;  [2]: http://jsfiddle.net/NnxAG/&#xD;&#xA;  [3]: http://jsfiddle.net/p6f4v/&#xD;&#xA;  [4]: http://jsfiddle.net/zaqtg/10/&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;Updated test results.
26432745;2579869;165737;5;73f42dde-2548-4388-8b92-02511c7645ef;2012-07-07 00:19:46.0;"**Update**:&#xD;&#xA;&#xD;&#xA;I have outlined some basic performance tests for each of these 6 methods over 1000 runs. `getElementsByTagName` is the fastest but it does a half-assed job, as it does not select all elements, but only one particular type of tag ( i think `p`) and blindly assumes that its firstChild is a text element. It might be little flawed but its there for demonstration purpose and comparing its performance to `TreeWalker`. [Run the tests yourselves on jsfiddle][4] to see the results.&#xD;&#xA;&#xD;&#xA; 1. Using a TreeWalker&#xD;&#xA; 2. Custom Iterative Traversal&#xD;&#xA; 3. Custom Recursive Traversal&#xD;&#xA; 4. Xpath query&#xD;&#xA; 5. querySelectorAll&#xD;&#xA; 6. getElementsByTagName&#xD;&#xA;&#xD;&#xA;Let's assume for a moment that there is a method that allows you to get all `Text` nodes natively. You would still have to traverse each resulting text node and call `node.nodeValue` to get the actual text as you would do with any DOM Node. So the issue of performance is not with iterating through text nodes, but iterating through all nodes that are not text and checking their type. I would argue (based on the results) that `TreeWalker` performs just as fast as `getElementsByTagName`, if not faster (even with getElementsByTagName playing handicapped).&#xD;&#xA;&#xD;&#xA;<pre>&#xD;&#xA;Ran each test 1000 times.&#xD;&#xA;&#xD;&#xA;Method                  Total ms        Average ms&#xD;&#xA;--------------------------------------------------&#xD;&#xA;document.TreeWalker	         301            0.301&#xD;&#xA;Iterative Traverser          769            0.769&#xD;&#xA;Recursive Traverser         7352            7.352&#xD;&#xA;XPath query                 1849            1.849&#xD;&#xA;querySelectorAll            1725            1.725&#xD;&#xA;getElementsByTagName         212            0.212&#xD;&#xA;</pre>&#xD;&#xA;&#xD;&#xA;<hr />&#xD;&#xA;&#xD;&#xA;Source for each method:&#xD;&#xA;&#xD;&#xA;**TreeWalker**&#xD;&#xA;&#xD;&#xA;    function nativeTreeWalker() {&#xD;&#xA;        var walker = document.createTreeWalker(&#xD;&#xA;            document.body, &#xD;&#xA;            NodeFilter.SHOW_TEXT, &#xD;&#xA;            null, &#xD;&#xA;            false&#xD;&#xA;        );&#xD;&#xA;        &#xD;&#xA;        var node;&#xD;&#xA;        var textNodes = [];&#xD;&#xA;    &#xD;&#xA;        while(node = walker.nextNode()) {&#xD;&#xA;            textNodes.push(node.nodeValue);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Recursive Tree Traversal**&#xD;&#xA;&#xD;&#xA;    function customRecursiveTreeWalker() {&#xD;&#xA;        var result = [];&#xD;&#xA;    &#xD;&#xA;        (function findTextNodes(current) {&#xD;&#xA;            for(var i = 0; i < current.childNodes.length; i++) {&#xD;&#xA;                var child = current.childNodes[i];&#xD;&#xA;                if(child.nodeType == 3) {&#xD;&#xA;                    result.push(child.nodeValue);&#xD;&#xA;                }&#xD;&#xA;                else {&#xD;&#xA;                    findTextNodes(child);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        })(document.body);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Iterative Tree Traversal**&#xD;&#xA;&#xD;&#xA;    function customIterativeTreeWalker() {&#xD;&#xA;        var result = [];&#xD;&#xA;        var root = document.body;&#xD;&#xA;        &#xD;&#xA;        var node = root.childNodes[0];&#xD;&#xA;        while(node != null) {&#xD;&#xA;            if(node.nodeType == 3) { /* Fixed a bug here. Thanks @theazureshadow */&#xD;&#xA;                result.push(node.nodeValue);&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            if(node.hasChildNodes()) {&#xD;&#xA;                node = node.firstChild;&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                while(node.nextSibling == null && node != root) {&#xD;&#xA;                    node = node.parentNode;&#xD;&#xA;                }&#xD;&#xA;                node = node.nextSibling;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**querySelectorAll**&#xD;&#xA;&#xD;&#xA;    function nativeSelector() {&#xD;&#xA;        var elements = document.querySelectorAll(""body, body *""); /* Fixed a bug here. Thanks @theazureshadow */&#xD;&#xA;        var results = [];&#xD;&#xA;        var child;&#xD;&#xA;        for(var i = 0; i < elements.length; i++) {&#xD;&#xA;            child = elements[i].childNodes[0];&#xD;&#xA;            if(elements[i].hasChildNodes() && child.nodeType == 3) {&#xD;&#xA;                results.push(child.nodeValue);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**getElementsByTagName** (handicap)&#xD;&#xA;&#xD;&#xA;    function getElementsByTagName() {&#xD;&#xA;        var elements = document.getElementsByTagName(""p"");&#xD;&#xA;        var results = [];&#xD;&#xA;        for(var i = 0; i < elements.length; i++) {&#xD;&#xA;            results.push(elements[i].childNodes[0].nodeValue);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**XPath**&#xD;&#xA;&#xD;&#xA;    function xpathSelector() {&#xD;&#xA;        var xpathResult = document.evaluate(&#xD;&#xA;            ""//*/text()"", &#xD;&#xA;            document, &#xD;&#xA;            null, &#xD;&#xA;            XPathResult.ORDERED_NODE_ITERATOR_TYPE, &#xD;&#xA;            null&#xD;&#xA;        );&#xD;&#xA;        &#xD;&#xA;        var results = [], res;&#xD;&#xA;        while(res = xpathResult.iterateNext()) {&#xD;&#xA;            results.push(res.nodeValue);  /* Fixed a bug here. Thanks @theazureshadow */&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Also, you might find this discussion helpful - http://bytes.com/topic/javascript/answers/153239-how-do-i-get-elements-text-node&#xD;&#xA;&#xD;&#xA;  [1]: https://developer.mozilla.org/en/nodeType&#xD;&#xA;  [2]: http://jsfiddle.net/NnxAG/&#xD;&#xA;  [3]: http://jsfiddle.net/p6f4v/&#xD;&#xA;  [4]: http://jsfiddle.net/zaqtg/10/&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;"added 6 characters in body; added 47 characters in body"
