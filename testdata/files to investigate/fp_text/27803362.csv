Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
81041588;27803362;980550;2;f297b933-0da3-4897-a364-5e7323a3c44d;2015-01-06 16:52:53.0;"The original could be refactored a little to avoid the exponentiation each time:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;    &#xD;&#xA;    binary_number(Bits, N) :-&#xD;&#xA;            reverse(Bits, RBits),&#xD;&#xA;            binary_number(N, RBits, []).&#xD;&#xA;    &#xD;&#xA;    binary_number(0, [0|T], T).&#xD;&#xA;    binary_number(1, [1|T], T).&#xD;&#xA;    binary_number(N, [B|Bits], T) :-&#xD;&#xA;            B in 0..1,&#xD;&#xA;            N #= N1 * 2 + B,&#xD;&#xA;            binary_number(N1, Bits, T).&#xD;&#xA;&#xD;&#xA;Or, equivalently, as a DCG:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    bd(0) --> [0].&#xD;&#xA;    bd(1) --> [1].&#xD;&#xA;    bd(N) --> {B in 0..1}, [B], {N #= N1*2 + B}, bd(N1).&#xD;&#xA;&#xD;&#xA;    binary_decimal(Bits, N) :-&#xD;&#xA;        reverse(Bits, RBits),&#xD;&#xA;        phrase(bd(N), RBits).&#xD;&#xA;";;
81042229;27803362;980550;5;ba89dd8a-9602-49b9-931c-621e7122ee93;2015-01-06 17:02:22.0;"In the original, `binary_number([], _, N, N).`, the `_` means you don't care what the value of the variable is. If you used, `binary_number([], X, N, N).` (not caring what `X` is), Prolog would issue a singleton variable warning.&#xD;&#xA;&#xD;&#xA;The original implementation could be refactored a little to avoid the exponentiation each time:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;    &#xD;&#xA;    binary_number(Bits, N) :-&#xD;&#xA;            reverse(Bits, RBits),&#xD;&#xA;            binary_number(N, RBits, []).&#xD;&#xA;    &#xD;&#xA;    binary_number(0, [0|T], T).&#xD;&#xA;    binary_number(1, [1|T], T).&#xD;&#xA;    binary_number(N, [B|Bits], T) :-&#xD;&#xA;            B in 0..1,&#xD;&#xA;            N #= N1 * 2 + B,&#xD;&#xA;            binary_number(N1, Bits, T).&#xD;&#xA;&#xD;&#xA;Or, equivalently, as a DCG:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    bd(0) --> [0].&#xD;&#xA;    bd(1) --> [1].&#xD;&#xA;    bd(N) --> {B in 0..1}, [B], {N #= N1*2 + B}, bd(N1).&#xD;&#xA;&#xD;&#xA;    binary_decimal(Bits, N) :-&#xD;&#xA;        reverse(Bits, RBits),&#xD;&#xA;        phrase(bd(N), RBits).&#xD;&#xA;";;added 248 characters in body
81051337;27803362;980550;5;1817b88e-88e4-4114-adfa-a8032c62437a;2015-01-06 19:40:51.0;"As explained in the comments, `use_module(library(clpfd))` causes Prolog to use the library for *Constraint Logic Programming over Finite Domains*. You can also find lots of good info on it via Google search of ""prolog clpfd"".&#xD;&#xA;&#xD;&#xA;In the original, `binary_number([], _, N, N).`, the `_` means you don't care what the value of the variable is. If you used, `binary_number([], X, N, N).` (not caring what `X` is), Prolog would issue a singleton variable warning.&#xD;&#xA;&#xD;&#xA;The original implementation could be refactored a little to avoid the exponentiation each time:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;    &#xD;&#xA;    binary_number(Bits, N) :-&#xD;&#xA;            reverse(Bits, RBits),&#xD;&#xA;            binary_number(N, RBits, []).&#xD;&#xA;    &#xD;&#xA;    binary_number(0, [0|T], T).&#xD;&#xA;    binary_number(1, [1|T], T).&#xD;&#xA;    binary_number(N, [B|Bits], T) :-&#xD;&#xA;            B in 0..1,&#xD;&#xA;            N #= N1 * 2 + B,&#xD;&#xA;            binary_number(N1, Bits, T).&#xD;&#xA;&#xD;&#xA;Or, equivalently, as a DCG:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    bd(0) --> [0].&#xD;&#xA;    bd(1) --> [1].&#xD;&#xA;    bd(N) --> {B in 0..1}, [B], {N #= N1*2 + B}, bd(N1).&#xD;&#xA;&#xD;&#xA;    binary_decimal(Bits, N) :-&#xD;&#xA;        reverse(Bits, RBits),&#xD;&#xA;        phrase(bd(N), RBits).&#xD;&#xA;";;added 230 characters in body
81051999;27803362;980550;5;745de6a7-0c3b-4944-a449-81ffda57ec45;2015-01-06 19:50:29.0;"In the original, `binary_number([], _, N, N).`, the `_` means you don't care what the value of the variable is. If you used, `binary_number([], X, N, N).` (not caring what `X` is), Prolog would issue a singleton variable warning.&#xD;&#xA;&#xD;&#xA;As explained in the comments, `use_module(library(clpfd))` causes Prolog to use the library for *Constraint Logic Programming over Finite Domains*. You can also find lots of good info on it via Google search of ""prolog clpfd"".&#xD;&#xA;&#xD;&#xA;Normally, in Prolog, arithmetic expressions of comparison require that the expressions be fully instantiated:&#xD;&#xA;&#xD;&#xA;    X + Y =:= Z + 2.  % Requires X, Y, and Z to be instantiated&#xD;&#xA;&#xD;&#xA;This would require that all `X`, `Y`, and `Z` be assigned values, and Prolog would evaluate and do the comparison and yield true or false. Likewise, for assignment, the `is/2` predicate requires that the right hand side expression be fully evaluable with specific variables all instantiated:&#xD;&#xA;&#xD;&#xA;    Z is X + Y.  % Requires X and Y to be instantiated&#xD;&#xA;&#xD;&#xA;Using CLPFD you can have Prolog ""explore"" solutions for you. And you can further specify what domain you'd like to restrict the variables to. So, you can say `X + Y #= Z + 2` and Prolog can enumerate possible solutions in `X`, `Y`, and `Z`.&#xD;&#xA;&#xD;&#xA;As an aside, the original implementation could be refactored a little to avoid the exponentiation each time:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;    &#xD;&#xA;    binary_number(Bits, N) :-&#xD;&#xA;            reverse(Bits, RBits),&#xD;&#xA;            binary_number(N, RBits, []).&#xD;&#xA;    &#xD;&#xA;    binary_number(0, [0|T], T).&#xD;&#xA;    binary_number(1, [1|T], T).&#xD;&#xA;    binary_number(N, [B|Bits], T) :-&#xD;&#xA;            B in 0..1,           % Choose values of B from 0, 1.&#xD;&#xA;            N #= N1 * 2 + B,     % Constrain N, N1 and B to satisfy N = N1*2 + B&#xD;&#xA;            binary_number(N1, Bits, T).&#xD;&#xA;&#xD;&#xA;Or, equivalently, as a DCG:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    bd(0) --> [0].&#xD;&#xA;    bd(1) --> [1].&#xD;&#xA;    bd(N) --> {B in 0..1}, [B], {N #= N1*2 + B}, bd(N1).&#xD;&#xA;&#xD;&#xA;    binary_decimal(Bits, N) :-&#xD;&#xA;        reverse(Bits, RBits),&#xD;&#xA;        phrase(bd(N), RBits).&#xD;&#xA;";;added 772 characters in body
81059155;27803362;980550;5;04e061ba-61a8-4a9e-b923-c1c3f55f7319;2015-01-06 22:09:48.0;"In the original, `binary_number([], _, N, N).`, the `_` means you don't care what the value of the variable is. If you used, `binary_number([], X, N, N).` (not caring what `X` is), Prolog would issue a singleton variable warning. Also, what this predicate clause says is that when the first argument is `[]` (the empty list), then the 3rd and 4th arguments are unified.&#xD;&#xA;&#xD;&#xA;As explained in the comments, `use_module(library(clpfd))` causes Prolog to use the library for *Constraint Logic Programming over Finite Domains*. You can also find lots of good info on it via Google search of ""prolog clpfd"".&#xD;&#xA;&#xD;&#xA;Normally, in Prolog, arithmetic expressions of comparison require that the expressions be fully instantiated:&#xD;&#xA;&#xD;&#xA;    X + Y =:= Z + 2.  % Requires X, Y, and Z to be instantiated&#xD;&#xA;&#xD;&#xA;Prolog would evaluate and do the comparison and yield true or false. It would throw an error if any of these variables were not instantiated. Likewise, for assignment, the `is/2` predicate requires that the right hand side expression be fully evaluable with specific variables all instantiated:&#xD;&#xA;&#xD;&#xA;    Z is X + Y.  % Requires X and Y to be instantiated&#xD;&#xA;&#xD;&#xA;Using CLPFD you can have Prolog ""explore"" solutions for you. And you can further specify what domain you'd like to restrict the variables to. So, you can say `X + Y #= Z + 2` and Prolog can enumerate possible solutions in `X`, `Y`, and `Z`.&#xD;&#xA;&#xD;&#xA;As an aside, the original implementation could be refactored a little to avoid the exponentiation each time:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;    &#xD;&#xA;    binary_number(Bits, N) :-&#xD;&#xA;            reverse(Bits, RBits),&#xD;&#xA;            binary_number(N, RBits, []).&#xD;&#xA;    &#xD;&#xA;    binary_number(0, [0|T], T).&#xD;&#xA;    binary_number(1, [1|T], T).&#xD;&#xA;    binary_number(N, [B|Bits], T) :-&#xD;&#xA;            B in 0..1,           % Choose values of B from 0, 1.&#xD;&#xA;            N #= N1 * 2 + B,     % Constrain N, N1 and B to satisfy N = N1*2 + B&#xD;&#xA;            binary_number(N1, Bits, T).&#xD;&#xA;&#xD;&#xA;Or, equivalently, as a DCG:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    bd(0) --> [0].&#xD;&#xA;    bd(1) --> [1].&#xD;&#xA;    bd(N) --> {B in 0..1}, [B], {N #= N1*2 + B}, bd(N1).&#xD;&#xA;&#xD;&#xA;    binary_decimal(Bits, N) :-&#xD;&#xA;        reverse(Bits, RBits),&#xD;&#xA;        phrase(bd(N), RBits).&#xD;&#xA;";;added 3 characters in body
83747139;27803362;980550;5;d138a229-7241-4b77-8cea-78d937fdbc13;2015-02-13 20:12:43.0;"In the original, `binary_number([], _, N, N).`, the `_` means you don't care what the value of the variable is. If you used, `binary_number([], X, N, N).` (not caring what `X` is), Prolog would issue a singleton variable warning. Also, what this predicate clause says is that when the first argument is `[]` (the empty list), then the 3rd and 4th arguments are unified.&#xD;&#xA;&#xD;&#xA;As explained in the comments, `use_module(library(clpfd))` causes Prolog to use the library for *Constraint Logic Programming over Finite Domains*. You can also find lots of good info on it via Google search of ""prolog clpfd"".&#xD;&#xA;&#xD;&#xA;Normally, in Prolog, arithmetic expressions of comparison require that the expressions be fully instantiated:&#xD;&#xA;&#xD;&#xA;    X + Y =:= Z + 2.  % Requires X, Y, and Z to be instantiated&#xD;&#xA;&#xD;&#xA;Prolog would evaluate and do the comparison and yield true or false. It would throw an error if any of these variables were not instantiated. Likewise, for assignment, the `is/2` predicate requires that the right hand side expression be fully evaluable with specific variables all instantiated:&#xD;&#xA;&#xD;&#xA;    Z is X + Y.  % Requires X and Y to be instantiated&#xD;&#xA;&#xD;&#xA;Using CLPFD you can have Prolog ""explore"" solutions for you. And you can further specify what domain you'd like to restrict the variables to. So, you can say `X + Y #= Z + 2` and Prolog can enumerate possible solutions in `X`, `Y`, and `Z`.&#xD;&#xA;&#xD;&#xA;As an aside, the original implementation could be refactored a little to avoid the exponentiation each time:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;    &#xD;&#xA;    binary_number(Bits, N) :-&#xD;&#xA;            reverse(Bits, RBits),&#xD;&#xA;            binary_number(N, RBits, []).&#xD;&#xA;    &#xD;&#xA;    binary_number(0, [0|T], T).&#xD;&#xA;    binary_number(1, [1|T], T).&#xD;&#xA;    binary_number(N, [B|Bits], T) :-&#xD;&#xA;            B in 0..1,           % Choose values of B from 0, 1.&#xD;&#xA;            N #= N1 * 2 + B,     % Constrain N, N1 and B to satisfy N = N1*2 + B&#xD;&#xA;            binary_number(N1, Bits, T).&#xD;&#xA;&#xD;&#xA;Or, as a DCG:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    bd(A, A) --> [].&#xD;&#xA;    bd(A, X) --> [D], { D #< 2, A1 #= 2*A + D }, bd(A1, X).&#xD;&#xA;    &#xD;&#xA;    binary_number(B, D) :-&#xD;&#xA;        phrase(bd(0, D), B).&#xD;&#xA;&#xD;&#xA;Which can work both ways:&#xD;&#xA;&#xD;&#xA;    | ?- binary_number([1,0,1,0], N).&#xD;&#xA;    &#xD;&#xA;    N = 10 ? ;&#xD;&#xA;    &#xD;&#xA;    no&#xD;&#xA;    | ?- binary_number(B, 10).&#xD;&#xA;    &#xD;&#xA;    B = [1,0,1,0] ? ;&#xD;&#xA;    B = [0,1,0,1,0] ? ;&#xD;&#xA;    B = [0,0,1,0,1,0] ? ;&#xD;&#xA;    ...&#xD;&#xA;";;added 160 characters in body
83747616;27803362;980550;5;7b6eb76a-f7b6-49a0-85f3-0e883b2e1692;2015-02-13 20:21:08.0;"In the original, `binary_number([], _, N, N).`, the `_` means you don't care what the value of the variable is. If you used, `binary_number([], X, N, N).` (not caring what `X` is), Prolog would issue a singleton variable warning. Also, what this predicate clause says is that when the first argument is `[]` (the empty list), then the 3rd and 4th arguments are unified.&#xD;&#xA;&#xD;&#xA;As explained in the comments, `use_module(library(clpfd))` causes Prolog to use the library for *Constraint Logic Programming over Finite Domains*. You can also find lots of good info on it via Google search of ""prolog clpfd"".&#xD;&#xA;&#xD;&#xA;Normally, in Prolog, arithmetic expressions of comparison require that the expressions be fully instantiated:&#xD;&#xA;&#xD;&#xA;    X + Y =:= Z + 2.  % Requires X, Y, and Z to be instantiated&#xD;&#xA;&#xD;&#xA;Prolog would evaluate and do the comparison and yield true or false. It would throw an error if any of these variables were not instantiated. Likewise, for assignment, the `is/2` predicate requires that the right hand side expression be fully evaluable with specific variables all instantiated:&#xD;&#xA;&#xD;&#xA;    Z is X + Y.  % Requires X and Y to be instantiated&#xD;&#xA;&#xD;&#xA;Using CLPFD you can have Prolog ""explore"" solutions for you. And you can further specify what domain you'd like to restrict the variables to. So, you can say `X + Y #= Z + 2` and Prolog can enumerate possible solutions in `X`, `Y`, and `Z`.&#xD;&#xA;&#xD;&#xA;As an aside, the original implementation could be refactored a little to avoid the exponentiation each time and to eliminate the `reverse`:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;    &#xD;&#xA;    binary_number(Bin, Dec) :-&#xD;&#xA;        binary_number(Bin, 0, Dec).&#xD;&#xA;    &#xD;&#xA;    binary_number([], Dec, Dec).&#xD;&#xA;    binary_number([Bit|T], Acc, Dec) :-&#xD;&#xA;        Bit in 0..1,&#xD;&#xA;        Acc1 #= Acc * 2 + Bit,&#xD;&#xA;        binary_number(T, Acc1, Dec).&#xD;&#xA;&#xD;&#xA;Or, as a DCG:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    bd(A, A) --> [].&#xD;&#xA;    bd(A, X) --> [D], { D in 0..1, A1 #= 2*A + D }, bd(A1, X).&#xD;&#xA;    &#xD;&#xA;    binary_number(B, D) :-&#xD;&#xA;        phrase(bd(0, D), B).&#xD;&#xA;&#xD;&#xA;Which can work both ways:&#xD;&#xA;&#xD;&#xA;    | ?- binary_number([1,0,1,0], N).&#xD;&#xA;    &#xD;&#xA;    N = 10 ? ;&#xD;&#xA;    &#xD;&#xA;    no&#xD;&#xA;    | ?- binary_number(B, 10).&#xD;&#xA;    &#xD;&#xA;    B = [1,0,1,0] ? ;&#xD;&#xA;    B = [0,1,0,1,0] ? ;&#xD;&#xA;    B = [0,0,1,0,1,0] ? ;&#xD;&#xA;    ...&#xD;&#xA;";;added 160 characters in body
83789324;27803362;980550;5;2644ac5a-6299-47cc-95e0-1335b31736cf;2015-02-14 14:41:36.0;"In the original, `binary_number([], _, N, N).`, the `_` means you don't care what the value of the variable is. If you used, `binary_number([], X, N, N).` (not caring what `X` is), Prolog would issue a singleton variable warning. Also, what this predicate clause says is that when the first argument is `[]` (the empty list), then the 3rd and 4th arguments are unified.&#xD;&#xA;&#xD;&#xA;As explained in the comments, `use_module(library(clpfd))` causes Prolog to use the library for *Constraint Logic Programming over Finite Domains*. You can also find lots of good info on it via Google search of ""prolog clpfd"".&#xD;&#xA;&#xD;&#xA;Normally, in Prolog, arithmetic expressions of comparison require that the expressions be fully instantiated:&#xD;&#xA;&#xD;&#xA;    X + Y =:= Z + 2.  % Requires X, Y, and Z to be instantiated&#xD;&#xA;&#xD;&#xA;Prolog would evaluate and do the comparison and yield true or false. It would throw an error if any of these variables were not instantiated. Likewise, for assignment, the `is/2` predicate requires that the right hand side expression be fully evaluable with specific variables all instantiated:&#xD;&#xA;&#xD;&#xA;    Z is X + Y.  % Requires X and Y to be instantiated&#xD;&#xA;&#xD;&#xA;Using CLPFD you can have Prolog ""explore"" solutions for you. And you can further specify what domain you'd like to restrict the variables to. So, you can say `X + Y #= Z + 2` and Prolog can enumerate possible solutions in `X`, `Y`, and `Z`.&#xD;&#xA;&#xD;&#xA;As an aside, the original implementation could be refactored a little to avoid the exponentiation each time and to eliminate the `reverse`. The [solution was presented by @false][1]. Here is a slightly generalized version of that solution for any radix, `R` less than or equal to 10:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    radix_number(R, Ds, N) :-&#xD;&#xA;        integer(R), R > 1, R =< 10,&#xD;&#xA;        radix_number_min(R, Ds, 0, N, N).&#xD;&#xA;    &#xD;&#xA;    radix_number_min(_R, [], N,N, _M).&#xD;&#xA;    radix_number_min(R, [D|Ds], N0,N, M) :-&#xD;&#xA;        R1 is R-1,&#xD;&#xA;        D in 0..R1,&#xD;&#xA;        N1 #= B + 2*N0,&#xD;&#xA;        M #>= N1,&#xD;&#xA;        radix_number_min(R, Bs, N1,N, M).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Or, as a DCG:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    radix_number(_, A, A, _) --> [].&#xD;&#xA;    radix_number(R, A, X, M) -->&#xD;&#xA;        [D],&#xD;&#xA;        {   R1 is R-1,&#xD;&#xA;            D in 0..R1,&#xD;&#xA;            A1 #= A*R + D,&#xD;&#xA;            M #>= A1&#xD;&#xA;        },&#xD;&#xA;        radix_number(R, A1, X, M).&#xD;&#xA;&#xD;&#xA;    radix_number(R, N, Ds) :-&#xD;&#xA;        integer(R), R > 1, R =< 10,&#xD;&#xA;        phrase(radix_number(R, 0, N, N), Ds).&#xD;&#xA;&#xD;&#xA;Which can work both ways:&#xD;&#xA;&#xD;&#xA;    | ?- radix_number(2, N, [1,0,1,0]).&#xD;&#xA;    &#xD;&#xA;    N = 10 ? ;&#xD;&#xA;    &#xD;&#xA;    no&#xD;&#xA;    | ?- radix_number(2, 10, B).&#xD;&#xA;    &#xD;&#xA;    B = [1,0,1,0] ? ;&#xD;&#xA;    B = [0,1,0,1,0] ? ;&#xD;&#xA;    B = [0,0,1,0,1,0] ? ;&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/a/28442760/772868";;added 368 characters in body
83789654;27803362;980550;5;daaea269-3c32-40ee-968e-91682a91772b;2015-02-14 14:52:31.0;"In the original, `binary_number([], _, N, N).`, the `_` means you don't care what the value of the variable is. If you used, `binary_number([], X, N, N).` (not caring what `X` is), Prolog would issue a singleton variable warning. Also, what this predicate clause says is that when the first argument is `[]` (the empty list), then the 3rd and 4th arguments are unified.&#xD;&#xA;&#xD;&#xA;As explained in the comments, `use_module(library(clpfd))` causes Prolog to use the library for *Constraint Logic Programming over Finite Domains*. You can also find lots of good info on it via Google search of ""prolog clpfd"".&#xD;&#xA;&#xD;&#xA;Normally, in Prolog, arithmetic expressions of comparison require that the expressions be fully instantiated:&#xD;&#xA;&#xD;&#xA;    X + Y =:= Z + 2.  % Requires X, Y, and Z to be instantiated&#xD;&#xA;&#xD;&#xA;Prolog would evaluate and do the comparison and yield true or false. It would throw an error if any of these variables were not instantiated. Likewise, for assignment, the `is/2` predicate requires that the right hand side expression be fully evaluable with specific variables all instantiated:&#xD;&#xA;&#xD;&#xA;    Z is X + Y.  % Requires X and Y to be instantiated&#xD;&#xA;&#xD;&#xA;Using CLPFD you can have Prolog ""explore"" solutions for you. And you can further specify what domain you'd like to restrict the variables to. So, you can say `X + Y #= Z + 2` and Prolog can enumerate possible solutions in `X`, `Y`, and `Z`.&#xD;&#xA;&#xD;&#xA;As an aside, the original implementation could be refactored a little to avoid the exponentiation each time and to eliminate the `reverse`. The [solution was presented by @false][1]. Here is a slightly generalized version of that solution for any radix, `R` less than or equal to 10:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    radix_number(R, Ds, N) :-&#xD;&#xA;        integer(R), R > 1, R =< 10,&#xD;&#xA;        radix_number_min(R, Ds, 0, N, N).&#xD;&#xA;    &#xD;&#xA;    radix_number_min(_R, [], N,N, _M).&#xD;&#xA;    radix_number_min(R, [D|Ds], N0,N, M) :-&#xD;&#xA;        R1 is R-1,&#xD;&#xA;        D in 0..R1,&#xD;&#xA;        N1 #= B + R*N0,&#xD;&#xA;        M #>= N1,&#xD;&#xA;        radix_number_min(R, Bs, N1,N, M).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Or, as a DCG:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    radix_number(_, A, A, _) --> [].&#xD;&#xA;    radix_number(R, A, X, M) -->&#xD;&#xA;        [D],&#xD;&#xA;        {   R1 is R-1,&#xD;&#xA;            D in 0..R1,&#xD;&#xA;            A1 #= A*R + D,&#xD;&#xA;            M #>= A1&#xD;&#xA;        },&#xD;&#xA;        radix_number(R, A1, X, M).&#xD;&#xA;&#xD;&#xA;    radix_number(R, N, Ds) :-&#xD;&#xA;        integer(R), R > 1, R =< 10,&#xD;&#xA;        phrase(radix_number(R, 0, N, N), Ds).&#xD;&#xA;&#xD;&#xA;Which can work both ways:&#xD;&#xA;&#xD;&#xA;    | ?- radix_number(2, N, [1,0,1,0]).&#xD;&#xA;    &#xD;&#xA;    N = 10 ? ;&#xD;&#xA;    &#xD;&#xA;    no&#xD;&#xA;    | ?- radix_number(2, 10, B).&#xD;&#xA;    &#xD;&#xA;    B = [1,0,1,0] ? ;&#xD;&#xA;    B = [0,1,0,1,0] ? ;&#xD;&#xA;    B = [0,0,1,0,1,0] ? ;&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/a/28442760/772868";;edited body
83803291;27803362;980550;5;e912eb05-85c0-43ff-af0d-bb3707fdbcee;2015-02-14 21:07:54.0;"In the original, `binary_number([], _, N, N).`, the `_` means you don't care what the value of the variable is. If you used, `binary_number([], X, N, N).` (not caring what `X` is), Prolog would issue a singleton variable warning. Also, what this predicate clause says is that when the first argument is `[]` (the empty list), then the 3rd and 4th arguments are unified.&#xD;&#xA;&#xD;&#xA;As explained in the comments, `use_module(library(clpfd))` causes Prolog to use the library for *Constraint Logic Programming over Finite Domains*. You can also find lots of good info on it via Google search of ""prolog clpfd"".&#xD;&#xA;&#xD;&#xA;Normally, in Prolog, arithmetic expressions of comparison require that the expressions be fully instantiated:&#xD;&#xA;&#xD;&#xA;    X + Y =:= Z + 2.  % Requires X, Y, and Z to be instantiated&#xD;&#xA;&#xD;&#xA;Prolog would evaluate and do the comparison and yield true or false. It would throw an error if any of these variables were not instantiated. Likewise, for assignment, the `is/2` predicate requires that the right hand side expression be fully evaluable with specific variables all instantiated:&#xD;&#xA;&#xD;&#xA;    Z is X + Y.  % Requires X and Y to be instantiated&#xD;&#xA;&#xD;&#xA;Using CLPFD you can have Prolog ""explore"" solutions for you. And you can further specify what domain you'd like to restrict the variables to. So, you can say `X + Y #= Z + 2` and Prolog can enumerate possible solutions in `X`, `Y`, and `Z`.&#xD;&#xA;&#xD;&#xA;As an aside, the original implementation could be refactored a little to avoid the exponentiation each time and to eliminate the `reverse`:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    binary_number(Bin, N) :-&#xD;&#xA;        binary_number(Bin, 0, N).&#xD;&#xA;    &#xD;&#xA;    binary_number([], N, N).&#xD;&#xA;    binary_number([Bit|Bits], Acc, N) :-&#xD;&#xA;        Bit in 0..1,&#xD;&#xA;        Acc1 #= Acc*2 + Bit,&#xD;&#xA;        binary_number(Bits, Acc1, N).&#xD;&#xA;&#xD;&#xA;This works well for queries such as:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    | ?- binary_number([1,0,1,0], N).&#xD;&#xA;    &#xD;&#xA;    N = 10 ? ;&#xD;&#xA;    &#xD;&#xA;    no&#xD;&#xA;    | ?- binary_number(B, 10).&#xD;&#xA;    &#xD;&#xA;    B = [1,0,1,0] ? ;&#xD;&#xA;    B = [0,1,0,1,0] ? ;&#xD;&#xA;    B = [0,0,1,0,1,0] ? ;&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;But it has termination issues, as pointed out in the comments, for cases such as, `Bs = [1|_], N #=< 5, binary_number(Bs, N).` A [solution was presented by @false][1] which simply modifies the above helps solve those termination issues. I'll reiterate that solution here for convenience:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    binary_number(Bits, N) :-&#xD;&#xA;        binary_number_min(Bits, 0,N, N).&#xD;&#xA;    &#xD;&#xA;    binary_number_min([], N,N, _M).&#xD;&#xA;    binary_number_min([Bit|Bits], N0,N, M) :-&#xD;&#xA;        Bit in 0..1,&#xD;&#xA;        N1 #= N0*2 + Bit,&#xD;&#xA;        M #>= N1,&#xD;&#xA;        binary_number_min(Bits, N1,N, M).&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/a/28442760/772868&#xD;&#xA;";;deleted 35 characters in body
146992081;27803362;-1;5;87c4ec0c-99da-4f53-b7e8-558652684990;2017-05-23 12:07:34.0;"In the original, `binary_number([], _, N, N).`, the `_` means you don't care what the value of the variable is. If you used, `binary_number([], X, N, N).` (not caring what `X` is), Prolog would issue a singleton variable warning. Also, what this predicate clause says is that when the first argument is `[]` (the empty list), then the 3rd and 4th arguments are unified.&#xD;&#xA;&#xD;&#xA;As explained in the comments, `use_module(library(clpfd))` causes Prolog to use the library for *Constraint Logic Programming over Finite Domains*. You can also find lots of good info on it via Google search of ""prolog clpfd"".&#xD;&#xA;&#xD;&#xA;Normally, in Prolog, arithmetic expressions of comparison require that the expressions be fully instantiated:&#xD;&#xA;&#xD;&#xA;    X + Y =:= Z + 2.  % Requires X, Y, and Z to be instantiated&#xD;&#xA;&#xD;&#xA;Prolog would evaluate and do the comparison and yield true or false. It would throw an error if any of these variables were not instantiated. Likewise, for assignment, the `is/2` predicate requires that the right hand side expression be fully evaluable with specific variables all instantiated:&#xD;&#xA;&#xD;&#xA;    Z is X + Y.  % Requires X and Y to be instantiated&#xD;&#xA;&#xD;&#xA;Using CLPFD you can have Prolog ""explore"" solutions for you. And you can further specify what domain you'd like to restrict the variables to. So, you can say `X + Y #= Z + 2` and Prolog can enumerate possible solutions in `X`, `Y`, and `Z`.&#xD;&#xA;&#xD;&#xA;As an aside, the original implementation could be refactored a little to avoid the exponentiation each time and to eliminate the `reverse`:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    binary_number(Bin, N) :-&#xD;&#xA;        binary_number(Bin, 0, N).&#xD;&#xA;    &#xD;&#xA;    binary_number([], N, N).&#xD;&#xA;    binary_number([Bit|Bits], Acc, N) :-&#xD;&#xA;        Bit in 0..1,&#xD;&#xA;        Acc1 #= Acc*2 + Bit,&#xD;&#xA;        binary_number(Bits, Acc1, N).&#xD;&#xA;&#xD;&#xA;This works well for queries such as:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    | ?- binary_number([1,0,1,0], N).&#xD;&#xA;    &#xD;&#xA;    N = 10 ? ;&#xD;&#xA;    &#xD;&#xA;    no&#xD;&#xA;    | ?- binary_number(B, 10).&#xD;&#xA;    &#xD;&#xA;    B = [1,0,1,0] ? ;&#xD;&#xA;    B = [0,1,0,1,0] ? ;&#xD;&#xA;    B = [0,0,1,0,1,0] ? ;&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;But it has termination issues, as pointed out in the comments, for cases such as, `Bs = [1|_], N #=< 5, binary_number(Bs, N).` A [solution was presented by @false][1] which simply modifies the above helps solve those termination issues. I'll reiterate that solution here for convenience:&#xD;&#xA;&#xD;&#xA;    :- use_module(library(clpfd)).&#xD;&#xA;&#xD;&#xA;    binary_number(Bits, N) :-&#xD;&#xA;        binary_number_min(Bits, 0,N, N).&#xD;&#xA;    &#xD;&#xA;    binary_number_min([], N,N, _M).&#xD;&#xA;    binary_number_min([Bit|Bits], N0,N, M) :-&#xD;&#xA;        Bit in 0..1,&#xD;&#xA;        N1 #= N0*2 + Bit,&#xD;&#xA;        M #>= N1,&#xD;&#xA;        binary_number_min(Bits, N1,N, M).&#xD;&#xA;&#xD;&#xA;  [1]: https://stackoverflow.com/a/28442760/772868&#xD;&#xA;";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
