Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
104529461;33813930;1708801;2;0d3b950b-a1cf-4e9f-a2ed-9cdbc061f293;2015-11-19 20:38:35.0;"If we start from the draft C++14 standard section `7.1.5` *[dcl.constexpr]* we can find the requirements or a constexpr object declaration are:&#xD;&#xA;&#xD;&#xA;>A constexpr specifier used in an object declaration declares the object as const. Such an object shall have&#xD;&#xA;literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant expression (5.19).&#xD;&#xA;&#xD;&#xA;So is `f` is a literal type?&#xD;&#xA;&#xD;&#xA;Section `3.9` *[basic.types]* says:&#xD;&#xA;&#xD;&#xA;>A type is a literal type if it is:&#xD;&#xA;&#xD;&#xA;and covers classes in the following bullet:&#xD;&#xA;&#xD;&#xA;>- a class type (Clause 9) that has all of the following properties&#xD;&#xA;>&#xD;&#xA;>    - it has a trivial destructor,&#xD;&#xA;>    - it is an aggregate type (8.5.1) or has at least one constexpr constructor or constructor template&#xD;&#xA;that is not a copy or move constructor, and&#xD;&#xA;>    - all of its non-static data members and base classes are of non-volatile literal types.&#xD;&#xA;&#xD;&#xA;So we are okay on the first and third bullet. To cover the second bullet, does `f` have a constexpr constructor?&#xD;&#xA;&#xD;&#xA;As far as I can tell section `12.1` *[class.ctor]* says yes:&#xD;&#xA;&#xD;&#xA;>[...] If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5),&#xD;&#xA;the implicitly-defined default constructor is constexpr. [...]&#xD;&#xA;&#xD;&#xA;and it is initialized since it will be default-initialized. So `f` is a literal type and will be initialized covering the constexpr requirements.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;All this would seem to imply that gcc is correct but if we look at the following clang bug report: [""error: default initialization of an object of const type 'const Z' requires a user-provided default constructor"" even when no constructor needed](https://llvm.org/bugs/show_bug.cgi?id=23381). The case is slightly different in that is uses *const* as opposed to *constexpr* but the underlying issue is the same. So clang is basing their lack of support for this due to [defect report 253](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253) which does not currently have a proposed wording and it says (*emphasis mine*):&#xD;&#xA;&#xD;&#xA;>Paragraph 9 of 8.5 [dcl.init] says:&#xD;&#xA;> &#xD;&#xA;>> If no initializer is specified for an object, and the object is of&#xD;&#xA;> (possibly cv-qualified) non-POD class type (or array thereof), the&#xD;&#xA;> object shall be default-initialized; **if the object is of&#xD;&#xA;> const-qualified type, the underlying class type shall have a&#xD;&#xA;> user-declared default constructor**. Otherwise, **if no initializer is&#xD;&#xA;> specified for an object**, the object and its subobjects, if any, have&#xD;&#xA;> an indeterminate initial value; if the object or any of its subobjects&#xD;&#xA;> are of const-qualified type, **the program is ill-formed**.&#xD;&#xA;> &#xD;&#xA;>What if a const POD object has no non-static data members? This wording requires an empty initializer for such cases&#xD;&#xA;&#xD;&#xA;>[...]&#xD;&#xA;&#xD;&#xA;>Similar comments apply to a non-POD const object, all of whose non-static data members and base class subobjects have default constructors. Why should the class of such an object be required to have a user-declared default constructor?&#xD;&#xA;&#xD;&#xA;The defect report is still open but the last comment on it says:&#xD;&#xA;&#xD;&#xA;>If the implicit default constructor initializes all subobjects, no initializer should be required.&#xD;&#xA;&#xD;&#xA;and also notes:&#xD;&#xA;&#xD;&#xA;>This issue should be brought up again in light of constexpr constructors and non-static data member initializers. &#xD;&#xA;&#xD;&#xA;Indeed the defect report is still open but I wonder if it is even relevant anymore as far as I can tell by C++11 the problematic wording this defect report is based on no longer exists and in the draft C++14 standard section `8.5` now says:&#xD;&#xA;&#xD;&#xA;>If no initializer is specified for an object, the object is default-initialized. When storage for an object&#xD;&#xA;with automatic or dynamic storage duration is obtained, the object has an indeterminate value, and if&#xD;&#xA;no initialization is performed for the object, that object retains an indeterminate value until that value is&#xD;&#xA;replaced (5.17) [...]&#xD;&#xA;&#xD;&#xA;and I don't see any wording that contains a restriction requiring a user-defined default constructor nor initialization for a const object that existed pre C++11.&#xD;&#xA;&#xD;&#xA;It seems the best we can say is that pre C++11 clangs behavior is correct, although the declaration pre C++11 would be:&#xD;&#xA;&#xD;&#xA;    const f f1 ;&#xD;&#xA;&#xD;&#xA;In C++11 going forward the standard wording seems to support gccs behavior but we have an open defect report and until it is resolved this seems uncertain.";;
104533171;33813930;1708801;5;aa4ceecb-62eb-4418-a436-ac8fbb276c2f;2015-11-19 21:40:40.0;"If we start from the draft C++14 standard section `7.1.5` *[dcl.constexpr]* we can find the requirements or a constexpr object declaration are:&#xD;&#xA;&#xD;&#xA;>A constexpr specifier used in an object declaration declares the object as const. Such an object shall have&#xD;&#xA;literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant expression (5.19).&#xD;&#xA;&#xD;&#xA;So is `f` is a literal type?&#xD;&#xA;&#xD;&#xA;Section `3.9` *[basic.types]* says:&#xD;&#xA;&#xD;&#xA;>A type is a literal type if it is:&#xD;&#xA;&#xD;&#xA;and covers classes in the following bullet:&#xD;&#xA;&#xD;&#xA;>- a class type (Clause 9) that has all of the following properties&#xD;&#xA;>&#xD;&#xA;>    - it has a trivial destructor,&#xD;&#xA;>    - it is an aggregate type (8.5.1) or has at least one constexpr constructor or constructor template&#xD;&#xA;that is not a copy or move constructor, and&#xD;&#xA;>    - all of its non-static data members and base classes are of non-volatile literal types.&#xD;&#xA;&#xD;&#xA;So we are okay on the first and third bullet. To cover the second bullet, does `f` have a constexpr constructor?&#xD;&#xA;&#xD;&#xA;As far as I can tell section `12.1` *[class.ctor]* says yes:&#xD;&#xA;&#xD;&#xA;>[...] If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5),&#xD;&#xA;the implicitly-defined default constructor is constexpr. [...]&#xD;&#xA;&#xD;&#xA;But we are unfortunately required to have a user-provided constructor by section `8.5` which says:&#xD;&#xA;&#xD;&#xA;>If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type&#xD;&#xA;with a user-provided default constructor.&#xD;&#xA;&#xD;&#xA;So it looks like clang is correct here and if we look at the following clang bug report: [""error: default initialization of an object of const type 'const Z' requires a user-provided default constructor"" even when no constructor needed](https://llvm.org/bugs/show_bug.cgi?id=23381). So clang is basing their lack of support for this due to [defect report 253](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253) which does not currently have a proposed wording and it says (*emphasis mine*):&#xD;&#xA;&#xD;&#xA;>Paragraph 9 of 8.5 [dcl.init] says:&#xD;&#xA;> &#xD;&#xA;>> If no initializer is specified for an object, and the object is of&#xD;&#xA;> (possibly cv-qualified) non-POD class type (or array thereof), the&#xD;&#xA;> object shall be default-initialized; **if the object is of&#xD;&#xA;> const-qualified type, the underlying class type shall have a&#xD;&#xA;> user-declared default constructor**. Otherwise, **if no initializer is&#xD;&#xA;> specified for an object**, the object and its subobjects, if any, have&#xD;&#xA;> an indeterminate initial value; if the object or any of its subobjects&#xD;&#xA;> are of const-qualified type, **the program is ill-formed**.&#xD;&#xA;> &#xD;&#xA;>What if a const POD object has no non-static data members? This wording requires an empty initializer for such cases&#xD;&#xA;&#xD;&#xA;>[...]&#xD;&#xA;&#xD;&#xA;>Similar comments apply to a non-POD const object, all of whose non-static data members and base class subobjects have default constructors. Why should the class of such an object be required to have a user-declared default constructor?&#xD;&#xA;&#xD;&#xA;The defect report is still open but the last comment on it says:&#xD;&#xA;&#xD;&#xA;>If the implicit default constructor initializes all subobjects, no initializer should be required.&#xD;&#xA;&#xD;&#xA;and also notes:&#xD;&#xA;&#xD;&#xA;>This issue should be brought up again in light of constexpr constructors and non-static data member initializers. &#xD;&#xA;&#xD;&#xA;Although the defect report is still open, given the constexpr changes and non-static data member initializers it does not seem like a necessary restriction anymore.";;deleted 908 characters in body
104542544;33813930;1708801;5;f2198f7d-374b-4c7a-8a60-ddffd7180403;2015-11-20 01:02:36.0;"If we start from the draft C++14 standard section `7.1.5` *[dcl.constexpr]* we can find the requirements or a constexpr object declaration are:&#xD;&#xA;&#xD;&#xA;>A constexpr specifier used in an object declaration declares the object as const. Such an object shall have&#xD;&#xA;literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant expression (5.19).&#xD;&#xA;&#xD;&#xA;So is `f` is a literal type?&#xD;&#xA;&#xD;&#xA;Section `3.9` *[basic.types]* says:&#xD;&#xA;&#xD;&#xA;>A type is a literal type if it is:&#xD;&#xA;&#xD;&#xA;and covers classes in the following bullet:&#xD;&#xA;&#xD;&#xA;>- a class type (Clause 9) that has all of the following properties&#xD;&#xA;>&#xD;&#xA;>    - it has a trivial destructor,&#xD;&#xA;>    - it is an aggregate type (8.5.1) or has at least one constexpr constructor or constructor template&#xD;&#xA;that is not a copy or move constructor, and&#xD;&#xA;>    - all of its non-static data members and base classes are of non-volatile literal types.&#xD;&#xA;&#xD;&#xA;So we are okay on the first and third bullet. To cover the second bullet, does `f` have a constexpr constructor?&#xD;&#xA;&#xD;&#xA;As far as I can tell section `12.1` *[class.ctor]* says yes:&#xD;&#xA;&#xD;&#xA;>[...] If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5),&#xD;&#xA;the implicitly-defined default constructor is constexpr. [...]&#xD;&#xA;&#xD;&#xA;But we are unfortunately required to have a user-provided constructor by section `8.5` which says:&#xD;&#xA;&#xD;&#xA;>If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type&#xD;&#xA;with a user-provided default constructor.&#xD;&#xA;&#xD;&#xA;So it looks like clang is correct here and if we look at the following clang bug report: [""error: default initialization of an object of const type 'const Z' requires a user-provided default constructor"" even when no constructor needed](https://llvm.org/bugs/show_bug.cgi?id=23381). So clang is basing their lack of support for this due to [defect report 253](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253) which does not currently have a proposed wording and it says (*emphasis mine*):&#xD;&#xA;&#xD;&#xA;>Paragraph 9 of 8.5 [dcl.init] says:&#xD;&#xA;> &#xD;&#xA;>> If no initializer is specified for an object, and the object is of&#xD;&#xA;> (possibly cv-qualified) non-POD class type (or array thereof), the&#xD;&#xA;> object shall be default-initialized; **if the object is of&#xD;&#xA;> const-qualified type, the underlying class type shall have a&#xD;&#xA;> user-declared default constructor**. Otherwise, **if no initializer is&#xD;&#xA;> specified for an object**, the object and its subobjects, if any, have&#xD;&#xA;> an indeterminate initial value; if the object or any of its subobjects&#xD;&#xA;> are of const-qualified type, **the program is ill-formed**.&#xD;&#xA;> &#xD;&#xA;>What if a const POD object has no non-static data members? This wording requires an empty initializer for such cases&#xD;&#xA;&#xD;&#xA;>[...]&#xD;&#xA;&#xD;&#xA;>Similar comments apply to a non-POD const object, all of whose non-static data members and base class subobjects have default constructors. Why should the class of such an object be required to have a user-declared default constructor?&#xD;&#xA;&#xD;&#xA;The defect report is still open but the last comment on it says:&#xD;&#xA;&#xD;&#xA;>If the implicit default constructor initializes all subobjects, no initializer should be required.&#xD;&#xA;&#xD;&#xA;and also notes:&#xD;&#xA;&#xD;&#xA;>This issue should be brought up again in light of constexpr constructors and non-static data member initializers. &#xD;&#xA;&#xD;&#xA;Although the defect report is still open, given the constexpr changes and non-static data member initializers it does not seem like a necessary restriction anymore. Especially considering the following requirement on a constexpr constructor:&#xD;&#xA;&#xD;&#xA;>- every non-variant non-static data member and base class sub-object shall be initialized (12.6.2);";;added 181 characters in body
104548132;33813930;1708801;5;37bbd61f-59d5-41e9-b6ce-48e9c58a8351;2015-11-20 03:39:15.0;"If we start from the draft C++14 standard section `7.1.5` *[dcl.constexpr]* we can find the requirements or a constexpr object declaration are:&#xD;&#xA;&#xD;&#xA;>A constexpr specifier used in an object declaration declares the object as const. Such an object shall have&#xD;&#xA;literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant expression (5.19).&#xD;&#xA;&#xD;&#xA;So is `f` is a literal type?&#xD;&#xA;&#xD;&#xA;Section `3.9` *[basic.types]* says:&#xD;&#xA;&#xD;&#xA;>A type is a literal type if it is:&#xD;&#xA;&#xD;&#xA;and covers classes in the following bullet:&#xD;&#xA;&#xD;&#xA;>- a class type (Clause 9) that has all of the following properties&#xD;&#xA;>&#xD;&#xA;>    - it has a trivial destructor,&#xD;&#xA;>    - it is an aggregate type (8.5.1) or has at least one constexpr constructor or constructor template&#xD;&#xA;that is not a copy or move constructor, and&#xD;&#xA;>    - all of its non-static data members and base classes are of non-volatile literal types.&#xD;&#xA;&#xD;&#xA;So we are okay on the first and third bullet. To cover the second bullet, we could note that `f` is an *aggregate* but if we modify the example slightly, for example if `f` looked like this:&#xD;&#xA;&#xD;&#xA;    struct f {&#xD;&#xA;       private:&#xD;&#xA;          int x = 0 ;&#xD;&#xA;    } ;&#xD;&#xA;&#xD;&#xA;which would not be an aggregate in either C++11 or C++14 but the issue would still exist. Then we need to show it has a constexpr constructor. Does `f` have a constexpr constructor?&#xD;&#xA;&#xD;&#xA;As far as I can tell section `12.1` *[class.ctor]* says yes:&#xD;&#xA;&#xD;&#xA;>[...] If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5),&#xD;&#xA;the implicitly-defined default constructor is constexpr. [...]&#xD;&#xA;&#xD;&#xA;But we are unfortunately required to have a user-provided constructor by section `8.5` which says:&#xD;&#xA;&#xD;&#xA;>If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type&#xD;&#xA;with a user-provided default constructor.&#xD;&#xA;&#xD;&#xA;So it looks like clang is correct here and if we look at the following clang bug report: [""error: default initialization of an object of const type 'const Z' requires a user-provided default constructor"" even when no constructor needed](https://llvm.org/bugs/show_bug.cgi?id=23381). So clang is basing their lack of support for this due to [defect report 253](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253) which does not currently have a proposed wording and it says (*emphasis mine*):&#xD;&#xA;&#xD;&#xA;>Paragraph 9 of 8.5 [dcl.init] says:&#xD;&#xA;> &#xD;&#xA;>> If no initializer is specified for an object, and the object is of&#xD;&#xA;> (possibly cv-qualified) non-POD class type (or array thereof), the&#xD;&#xA;> object shall be default-initialized; **if the object is of&#xD;&#xA;> const-qualified type, the underlying class type shall have a&#xD;&#xA;> user-declared default constructor**. Otherwise, **if no initializer is&#xD;&#xA;> specified for an object**, the object and its subobjects, if any, have&#xD;&#xA;> an indeterminate initial value; if the object or any of its subobjects&#xD;&#xA;> are of const-qualified type, **the program is ill-formed**.&#xD;&#xA;> &#xD;&#xA;>What if a const POD object has no non-static data members? This wording requires an empty initializer for such cases&#xD;&#xA;&#xD;&#xA;>[...]&#xD;&#xA;&#xD;&#xA;>Similar comments apply to a non-POD const object, all of whose non-static data members and base class subobjects have default constructors. Why should the class of such an object be required to have a user-declared default constructor?&#xD;&#xA;&#xD;&#xA;The defect report is still open but the last comment on it says:&#xD;&#xA;&#xD;&#xA;>If the implicit default constructor initializes all subobjects, no initializer should be required.&#xD;&#xA;&#xD;&#xA;and also notes:&#xD;&#xA;&#xD;&#xA;>This issue should be brought up again in light of constexpr constructors and non-static data member initializers. &#xD;&#xA;&#xD;&#xA;Although the defect report is still open, given the constexpr changes and non-static data member initializers it does not seem like a necessary restriction anymore. Especially considering the following requirement on a constexpr constructor:&#xD;&#xA;&#xD;&#xA;>- every non-variant non-static data member and base class sub-object shall be initialized (12.6.2);";;added 330 characters in body
104589101;33813930;1708801;5;72b68ff7-fc93-4cff-905a-db7df8e8c761;2015-11-20 14:30:03.0;"If we start from the draft C++14 standard section `7.1.5` *[dcl.constexpr]* we can find the requirements for a constexpr object declaration are:&#xD;&#xA;&#xD;&#xA;>A constexpr specifier used in an object declaration declares the object as const. Such an object shall have&#xD;&#xA;literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant expression (5.19).&#xD;&#xA;&#xD;&#xA;So is `f` is a literal type?&#xD;&#xA;&#xD;&#xA;Section `3.9` *[basic.types]* says:&#xD;&#xA;&#xD;&#xA;>A type is a literal type if it is:&#xD;&#xA;&#xD;&#xA;and covers classes in the following bullet:&#xD;&#xA;&#xD;&#xA;>- a class type (Clause 9) that has all of the following properties&#xD;&#xA;>&#xD;&#xA;>    - it has a trivial destructor,&#xD;&#xA;>    - it is an aggregate type (8.5.1) or has at least one constexpr constructor or constructor template&#xD;&#xA;that is not a copy or move constructor, and&#xD;&#xA;>    - all of its non-static data members and base classes are of non-volatile literal types.&#xD;&#xA;&#xD;&#xA;So we are okay on the first and third bullet. To cover the second bullet, we could note that `f` is an *aggregate* but if we modify the example slightly, for example if `f` looked like this:&#xD;&#xA;&#xD;&#xA;    struct f {&#xD;&#xA;       private:&#xD;&#xA;          int x = 0 ;&#xD;&#xA;    } ;&#xD;&#xA;&#xD;&#xA;which would not be an aggregate in either C++11 or C++14 but the issue would still exist. Then we need to show it has a constexpr constructor. Does `f` have a constexpr constructor?&#xD;&#xA;&#xD;&#xA;As far as I can tell section `12.1` *[class.ctor]* says yes:&#xD;&#xA;&#xD;&#xA;>[...] If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5),&#xD;&#xA;the implicitly-defined default constructor is constexpr. [...]&#xD;&#xA;&#xD;&#xA;But we are unfortunately required to have a user-provided constructor by section `8.5` which says:&#xD;&#xA;&#xD;&#xA;>If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type&#xD;&#xA;with a user-provided default constructor.&#xD;&#xA;&#xD;&#xA;So it looks like clang is correct here and if we look at the following clang bug report: [""error: default initialization of an object of const type 'const Z' requires a user-provided default constructor"" even when no constructor needed](https://llvm.org/bugs/show_bug.cgi?id=23381). So clang is basing their lack of support for this due to [defect report 253](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253) which does not currently have a proposed wording and it says (*emphasis mine*):&#xD;&#xA;&#xD;&#xA;>Paragraph 9 of 8.5 [dcl.init] says:&#xD;&#xA;> &#xD;&#xA;>> If no initializer is specified for an object, and the object is of&#xD;&#xA;> (possibly cv-qualified) non-POD class type (or array thereof), the&#xD;&#xA;> object shall be default-initialized; **if the object is of&#xD;&#xA;> const-qualified type, the underlying class type shall have a&#xD;&#xA;> user-declared default constructor**. Otherwise, **if no initializer is&#xD;&#xA;> specified for an object**, the object and its subobjects, if any, have&#xD;&#xA;> an indeterminate initial value; if the object or any of its subobjects&#xD;&#xA;> are of const-qualified type, **the program is ill-formed**.&#xD;&#xA;> &#xD;&#xA;>What if a const POD object has no non-static data members? This wording requires an empty initializer for such cases&#xD;&#xA;&#xD;&#xA;>[...]&#xD;&#xA;&#xD;&#xA;>Similar comments apply to a non-POD const object, all of whose non-static data members and base class subobjects have default constructors. Why should the class of such an object be required to have a user-declared default constructor?&#xD;&#xA;&#xD;&#xA;The defect report is still open but the last comment on it says:&#xD;&#xA;&#xD;&#xA;>If the implicit default constructor initializes all subobjects, no initializer should be required.&#xD;&#xA;&#xD;&#xA;and also notes:&#xD;&#xA;&#xD;&#xA;>This issue should be brought up again in light of constexpr constructors and non-static data member initializers. &#xD;&#xA;&#xD;&#xA;Although the defect report is still open, given the constexpr changes and non-static data member initializers it does not seem like a necessary restriction anymore. Especially considering the following requirement on a constexpr constructor:&#xD;&#xA;&#xD;&#xA;>- every non-variant non-static data member and base class sub-object shall be initialized (12.6.2);";;added 1 character in body
104606135;33813930;1708801;5;b84709a5-1163-4deb-8a04-4ab73f622dd0;2015-11-20 18:28:19.0;"If we start from the draft C++14 standard section `7.1.5` *[dcl.constexpr]* we can find the requirements for a constexpr object declaration are:&#xD;&#xA;&#xD;&#xA;>A constexpr specifier used in an object declaration declares the object as const. Such an object shall have&#xD;&#xA;literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant expression (5.19).&#xD;&#xA;&#xD;&#xA;So is `f` is a literal type?&#xD;&#xA;&#xD;&#xA;Section `3.9` *[basic.types]* says:&#xD;&#xA;&#xD;&#xA;>A type is a literal type if it is:&#xD;&#xA;&#xD;&#xA;and covers classes in the following bullet:&#xD;&#xA;&#xD;&#xA;>- a class type (Clause 9) that has all of the following properties&#xD;&#xA;>&#xD;&#xA;>    - it has a trivial destructor,&#xD;&#xA;>    - it is an aggregate type (8.5.1) or has at least one constexpr constructor or constructor template&#xD;&#xA;that is not a copy or move constructor, and&#xD;&#xA;>    - all of its non-static data members and base classes are of non-volatile literal types.&#xD;&#xA;&#xD;&#xA;So we are okay on the first and third bullet. To cover the second bullet, we could note that `f` is an *aggregate* but if we modify the example slightly, for example if `f` looked like this:&#xD;&#xA;&#xD;&#xA;    struct f {&#xD;&#xA;       private:&#xD;&#xA;          int x = 0 ;&#xD;&#xA;    } ;&#xD;&#xA;&#xD;&#xA;which would not be an aggregate in either C++11 or C++14 but the issue would still exist. Then we need to show it has a constexpr constructor. Does `f` have a constexpr constructor?&#xD;&#xA;&#xD;&#xA;As far as I can tell section `12.1` *[class.ctor]* says yes:&#xD;&#xA;&#xD;&#xA;>[...] If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5),&#xD;&#xA;the implicitly-defined default constructor is constexpr. [...]&#xD;&#xA;&#xD;&#xA;But we are unfortunately required to have a user-provided constructor by section `8.5` which says:&#xD;&#xA;&#xD;&#xA;>If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type&#xD;&#xA;with a user-provided default constructor.&#xD;&#xA;&#xD;&#xA;So it looks like clang is correct here and if we look at the following clang bug report: [""error: default initialization of an object of const type 'const Z' requires a user-provided default constructor"" even when no constructor needed](https://llvm.org/bugs/show_bug.cgi?id=23381). So clang is basing their lack of support for this due to [defect report 253](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253) which does not currently have a proposed wording and it says (*emphasis mine*):&#xD;&#xA;&#xD;&#xA;>Paragraph 9 of 8.5 [dcl.init] says:&#xD;&#xA;> &#xD;&#xA;>> If no initializer is specified for an object, and the object is of&#xD;&#xA;> (possibly cv-qualified) non-POD class type (or array thereof), the&#xD;&#xA;> object shall be default-initialized; **if the object is of&#xD;&#xA;> const-qualified type, the underlying class type shall have a&#xD;&#xA;> user-declared default constructor**. Otherwise, **if no initializer is&#xD;&#xA;> specified for an object**, the object and its subobjects, if any, have&#xD;&#xA;> an indeterminate initial value; if the object or any of its subobjects&#xD;&#xA;> are of const-qualified type, **the program is ill-formed**.&#xD;&#xA;> &#xD;&#xA;>What if a const POD object has no non-static data members? This wording requires an empty initializer for such cases&#xD;&#xA;&#xD;&#xA;>[...]&#xD;&#xA;&#xD;&#xA;>Similar comments apply to a non-POD const object, all of whose non-static data members and base class subobjects have default constructors. Why should the class of such an object be required to have a user-declared default constructor?&#xD;&#xA;&#xD;&#xA;The defect report is still open but the last comment on it says:&#xD;&#xA;&#xD;&#xA;>If the implicit default constructor initializes all subobjects, no initializer should be required.&#xD;&#xA;&#xD;&#xA;and also notes:&#xD;&#xA;&#xD;&#xA;>This issue should be brought up again in light of constexpr constructors and non-static data member initializers. &#xD;&#xA;&#xD;&#xA;Although the defect report is still open, given the constexpr changes and non-static data member initializers it does not seem like a necessary restriction anymore. Especially considering the following requirement on a constexpr constructor:&#xD;&#xA;&#xD;&#xA;>- every non-variant non-static data member and base class sub-object shall be initialized (12.6.2);&#xD;&#xA;&#xD;&#xA;Note the constraints on const qualified types moved around in section `8.5`, this was due to proposal [N2762: Not so Trivial Issues with Trivial](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2762.htm) which was pre C++11.";;added 237 characters in body
104609069;33813930;1708801;5;03efa8f3-7e69-40d6-b0f5-b4f8b31e7aca;2015-11-20 19:14:26.0;"If we start from the draft C++14 standard section `7.1.5` *[dcl.constexpr]* we can find the requirements for a constexpr object declaration are:&#xD;&#xA;&#xD;&#xA;>A constexpr specifier used in an object declaration declares the object as const. Such an object shall have&#xD;&#xA;literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant expression (5.19).&#xD;&#xA;&#xD;&#xA;So is `f` is a literal type?&#xD;&#xA;&#xD;&#xA;Section `3.9` *[basic.types]* says:&#xD;&#xA;&#xD;&#xA;>A type is a literal type if it is:&#xD;&#xA;&#xD;&#xA;and covers classes in the following bullet:&#xD;&#xA;&#xD;&#xA;>- a class type (Clause 9) that has all of the following properties&#xD;&#xA;>&#xD;&#xA;>    - it has a trivial destructor,&#xD;&#xA;>    - it is an aggregate type (8.5.1) or has at least one constexpr constructor or constructor template&#xD;&#xA;that is not a copy or move constructor, and&#xD;&#xA;>    - all of its non-static data members and base classes are of non-volatile literal types.&#xD;&#xA;&#xD;&#xA;So we are okay on the first and third bullet. To cover the second bullet, we could note that `f` is an *aggregate* but if we modify the example slightly, for example if `f` looked like this:&#xD;&#xA;&#xD;&#xA;    struct f {&#xD;&#xA;       private:&#xD;&#xA;          int x = 0 ;&#xD;&#xA;    } ;&#xD;&#xA;&#xD;&#xA;which would not be an aggregate in either C++11 or C++14 but the issue would still exist. Then we need to show it has a constexpr constructor. Does `f` have a constexpr constructor?&#xD;&#xA;&#xD;&#xA;As far as I can tell section `12.1` *[class.ctor]* says yes:&#xD;&#xA;&#xD;&#xA;>[...] If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5),&#xD;&#xA;the implicitly-defined default constructor is constexpr. [...]&#xD;&#xA;&#xD;&#xA;But we are unfortunately required to have a user-provided constructor by section `8.5` which says:&#xD;&#xA;&#xD;&#xA;>If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type&#xD;&#xA;with a user-provided default constructor.&#xD;&#xA;&#xD;&#xA;So it looks like clang is correct here and if we look at the following clang bug report: [""error: default initialization of an object of const type 'const Z' requires a user-provided default constructor"" even when no constructor needed](https://llvm.org/bugs/show_bug.cgi?id=23381). So clang is basing their lack of support for this due to [defect report 253](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253) which does not currently have a proposed wording and it says (*emphasis mine*):&#xD;&#xA;&#xD;&#xA;>Paragraph 9 of 8.5 [dcl.init] says:&#xD;&#xA;> &#xD;&#xA;>> If no initializer is specified for an object, and the object is of&#xD;&#xA;> (possibly cv-qualified) non-POD class type (or array thereof), the&#xD;&#xA;> object shall be default-initialized; **if the object is of&#xD;&#xA;> const-qualified type, the underlying class type shall have a&#xD;&#xA;> user-declared default constructor**. Otherwise, **if no initializer is&#xD;&#xA;> specified for an object**, the object and its subobjects, if any, have&#xD;&#xA;> an indeterminate initial value; if the object or any of its subobjects&#xD;&#xA;> are of const-qualified type, **the program is ill-formed**.&#xD;&#xA;> &#xD;&#xA;>What if a const POD object has no non-static data members? This wording requires an empty initializer for such cases&#xD;&#xA;&#xD;&#xA;>[...]&#xD;&#xA;&#xD;&#xA;>Similar comments apply to a non-POD const object, all of whose non-static data members and base class subobjects have default constructors. Why should the class of such an object be required to have a user-declared default constructor?&#xD;&#xA;&#xD;&#xA;The defect report is still open but the last comment on it says:&#xD;&#xA;&#xD;&#xA;>If the implicit default constructor initializes all subobjects, no initializer should be required.&#xD;&#xA;&#xD;&#xA;and also notes:&#xD;&#xA;&#xD;&#xA;>This issue should be brought up again in light of constexpr constructors and non-static data member initializers. &#xD;&#xA;&#xD;&#xA;Note the constraints on const qualified types moved around in section `8.5` since the defect report came about. This was due to proposal [N2762: Not so Trivial Issues with Trivial](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2762.htm) which was pre C++11.&#xD;&#xA;&#xD;&#xA;Although the defect report is still open, given the constexpr changes and non-static data member initializers it does not seem like a necessary restriction anymore. Especially considering the following requirement on a constexpr constructor:&#xD;&#xA;&#xD;&#xA;>- every non-variant non-static data member and base class sub-object shall be initialized (12.6.2);";;added 35 characters in body
