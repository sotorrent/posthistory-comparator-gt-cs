Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
32415255;13594962;383306;2;7b55d58e-2089-4250-b6b4-1ec30de077d5;2012-11-27 23:15:57.0;"I have the following `smart_ptr` class.&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    class smart_ptr&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        // ... removed other member functions for simplicity&#xD;&#xA;        T* get() { return ptr; }&#xD;&#xA;        template <typename... Args>&#xD;&#xA;        decltype(T::template operator ()(Args()...)) operator ()(Args... args) const&#xD;&#xA;        {&#xD;&#xA;            return (*get()).operator ()(args...);&#xD;&#xA;        }&#xD;&#xA;    private:&#xD;&#xA;        ptr;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;However, when I use the `smart_ptr` class for type T without an `operator ()`, it would fail to compile (and rightly so).&#xD;&#xA;&#xD;&#xA;What I wanted is to use `std::enable_if` to enable the member function only when T has `operator ()`. It got obscure and complex very fast when I got into doing it, as I was thinking of using SFINAE to detect if T has `operator ()` and then combine it with `std::enable_if` to get what I want. However, I got lost in creating SFINAE that is capable of detecting a variadic templated `operator ()`.&#xD;&#xA;&#xD;&#xA;Can anyone help? Or give another (perhaps simpler) solution?&#xD;&#xA;&#xD;&#xA;p.s. It has to work on GCC 4.5.3.&#xD;&#xA;";;
32415990;13594962;1147772;5;91d77e4b-1d7c-4850-9305-d6dd262c8b86;2012-11-27 23:39:54.0;"I have the following `smart_ptr` class.&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    class smart_ptr&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        // ... removed other member functions for simplicity&#xD;&#xA;        T* get() { return ptr; }&#xD;&#xA;&#xD;&#xA;        template <typename... Args>&#xD;&#xA;        decltype(T::template operator ()(Args()...)) operator ()(Args... args) const&#xD;&#xA;        {&#xD;&#xA;            return (*get()).operator ()(args...);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    private:&#xD;&#xA;        T* ptr;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;However, when I use the `smart_ptr` class for type T without an `operator ()`, it fails to compile (and rightly so).&#xD;&#xA;&#xD;&#xA;What I wanted is to use `std::enable_if` to enable the member function only when T has `operator ()`. It got obscure and complex very fast when I got into doing it, as I was thinking of using SFINAE to detect if T has `operator ()` and then combine it with `std::enable_if` to get what I want. However, I got lost in creating SFINAE that is capable of detecting a variadic templated `operator ()`.&#xD;&#xA;&#xD;&#xA;Can anyone help? Or give another (perhaps simpler) solution?&#xD;&#xA;&#xD;&#xA;p.s. It has to work on GCC 4.5.3.&#xD;&#xA;";;Added the type of the private member ptr. (probably forgotten).
32416252;13594962;383306;5;7191b820-0c41-495b-a5b9-4a4d6e9f96a2;2012-11-27 23:48:27.0;"I have the following `smart_ptr` class.&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    class smart_ptr&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        // ... removed other member functions for simplicity&#xD;&#xA;        T* get() { return ptr; }&#xD;&#xA;&#xD;&#xA;        template <typename... Args>&#xD;&#xA;        decltype(T::template operator ()(Args()...)) operator ()(Args... args) const&#xD;&#xA;        {&#xD;&#xA;            return (*get()).operator ()(args...);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    private:&#xD;&#xA;        T* ptr;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;However, when I use the `smart_ptr` class for type T without an `operator ()`, it fails to compile (and rightly so).&#xD;&#xA;&#xD;&#xA;What I wanted is to use `std::enable_if` to enable the member function only when T has `operator ()`. It got obscure and complex very fast when I got into doing it, as I was thinking of using SFINAE to detect if T has `operator ()` and then combine it with `std::enable_if` to get what I want. However, I got lost in creating SFINAE that is capable of detecting **a variadic templated `operator ()`**.&#xD;&#xA;&#xD;&#xA;Can anyone help? Or give another (perhaps simpler) solution?&#xD;&#xA;&#xD;&#xA;p.s. It has to work on GCC 4.5.3.&#xD;&#xA;&#xD;&#xA;";;added 6 characters in body
32416528;13594962;383306;5;915ef1c9-3235-4053-8eb3-c8f733207e2e;2012-11-27 23:58:45.0;"I have the following `smart_ptr` class.&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    class smart_ptr&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        // ... removed other member functions for simplicity&#xD;&#xA;        T* get() { return ptr; }&#xD;&#xA;&#xD;&#xA;        template <typename... Args>&#xD;&#xA;        decltype(T::template operator ()(Args()...)) operator ()(Args... args) const&#xD;&#xA;        {&#xD;&#xA;            return (*get()).operator ()(args...);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    private:&#xD;&#xA;        T* ptr;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;However, when I use the `smart_ptr` class for type T without an `operator ()`, it fails to compile (and rightly so).&#xD;&#xA;&#xD;&#xA;What I wanted is to use `std::enable_if` to enable the member function only when T has `operator ()`. It got obscure and complex very fast when I got into doing it, as I was thinking of using SFINAE to detect if T has `operator ()` and then combine it with `std::enable_if` to get what I want. However, I got lost in creating SFINAE that is capable of detecting **a variadic templated `operator ()`** (i.e. **NOT** a duplicate of http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence).&#xD;&#xA;&#xD;&#xA;Can anyone help? Or give another (perhaps simpler) solution?&#xD;&#xA;&#xD;&#xA;p.s. It has to work on GCC 4.5.3.&#xD;&#xA;";;"added 138 characters in body; added 4 characters in body"
32420009;13594962;-1;5;36b20364-73d5-41c7-8e43-7a0ccc8a5a41;2012-11-28 02:22:56.0;"> **Possible Duplicate:**  &#xA;> [Is it possible to write a C++ template to check for a function’s existence?](http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence)  &#xA;&#xA;<!-- End of automatically inserted text -->&#xA;&#xA;I have the following `smart_ptr` class.&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    class smart_ptr&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        // ... removed other member functions for simplicity&#xD;&#xA;        T* get() { return ptr; }&#xD;&#xA;&#xD;&#xA;        template <typename... Args>&#xD;&#xA;        decltype(T::template operator ()(Args()...)) operator ()(Args... args) const&#xD;&#xA;        {&#xD;&#xA;            return (*get()).operator ()(args...);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    private:&#xD;&#xA;        T* ptr;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;However, when I use the `smart_ptr` class for type T without an `operator ()`, it fails to compile (and rightly so).&#xD;&#xA;&#xD;&#xA;What I wanted is to use `std::enable_if` to enable the member function only when T has `operator ()`. It got obscure and complex very fast when I got into doing it, as I was thinking of using SFINAE to detect if T has `operator ()` and then combine it with `std::enable_if` to get what I want. However, I got lost in creating SFINAE that is capable of detecting **a variadic templated `operator ()`** (i.e. **NOT** a duplicate of http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence).&#xD;&#xA;&#xD;&#xA;Can anyone help? Or give another (perhaps simpler) solution?&#xD;&#xA;&#xD;&#xA;p.s. It has to work on GCC 4.5.3.&#xD;&#xA;";;insert duplicate link
32420292;13594962;383306;5;da5cbb3f-1edb-4cf4-8138-641215d05b33;2012-11-28 02:36:22.0;"> **Possible Duplicate:**  &#xD;&#xA;> [Is it possible to write a C++ template to check for a function’s existence?](http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence)  &#xD;&#xA;&#xD;&#xA;<!-- End of automatically inserted text -->&#xD;&#xA;EDIT: LOL!!! There are at least 5 stupid people in SO who thinks this question is a duplicate of the above!&#xD;&#xA;&#xD;&#xA;I have the following `smart_ptr` class.&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    class smart_ptr&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        // ... removed other member functions for simplicity&#xD;&#xA;        T* get() { return ptr; }&#xD;&#xA;&#xD;&#xA;        template <typename... Args>&#xD;&#xA;        decltype(T::template operator ()(Args()...)) operator ()(Args... args) const&#xD;&#xA;        {&#xD;&#xA;            return (*get()).operator ()(args...);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    private:&#xD;&#xA;        T* ptr;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;However, when I use the `smart_ptr` class for type T without an `operator ()`, it fails to compile (and rightly so).&#xD;&#xA;&#xD;&#xA;What I wanted is to use `std::enable_if` to enable the member function only when T has `operator ()`. It got obscure and complex very fast when I got into doing it, as I was thinking of using SFINAE to detect if T has `operator ()` and then combine it with `std::enable_if` to get what I want. However, I got lost in creating SFINAE that is capable of detecting **a variadic templated `operator ()`** (i.e. **NOT** a duplicate of http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence).&#xD;&#xA;&#xD;&#xA;Can anyone help? Or give another (perhaps simpler) solution?&#xD;&#xA;&#xD;&#xA;p.s. It has to work on GCC 4.5.3.&#xD;&#xA;";;added 114 characters in body
32423044;13594962;383306;5;e84aa931-de90-4513-91ca-27fea675e7df;2012-11-28 04:37:55.0;"> **Possible Duplicate:**  &#xD;&#xA;> [Is it possible to write a C++ template to check for a function’s existence?](http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence)  &#xD;&#xA;&#xD;&#xA;<!-- End of automatically inserted text -->&#xD;&#xA;EDIT: Can someone tell me how this is a duplicate of the above?&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;I have the following `smart_ptr` class.&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    class smart_ptr&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        // ... removed other member functions for simplicity&#xD;&#xA;        T* get() { return ptr; }&#xD;&#xA;&#xD;&#xA;        template <typename... Args>&#xD;&#xA;        decltype(T::template operator ()(Args()...)) operator ()(Args... args) const&#xD;&#xA;        {&#xD;&#xA;            return (*get()).operator ()(args...);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    private:&#xD;&#xA;        T* ptr;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;However, when I use the `smart_ptr` class for type T without an `operator ()`, it fails to compile (and rightly so).&#xD;&#xA;&#xD;&#xA;What I wanted is to use `std::enable_if` to enable the member function only when T has `operator ()`. It got obscure and complex very fast when I got into doing it, as I was thinking of using SFINAE to detect if T has `operator ()` and then combine it with `std::enable_if` to get what I want. However, I got lost in creating SFINAE that is capable of detecting **a variadic templated `operator ()`** (i.e. **NOT** a duplicate of http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence).&#xD;&#xA;&#xD;&#xA;Can anyone help? Or give another (perhaps simpler) solution?&#xD;&#xA;&#xD;&#xA;p.s. It has to work on GCC 4.5.3.&#xD;&#xA;";;what duplicate?
32423647;13594962;-1;5;a29f227d-6898-4f87-ab95-c5f84e551fdf;2012-11-28 04:59:01.0;"EDIT: Can someone tell me how this is a duplicate of the above?&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;I have the following `smart_ptr` class.&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    class smart_ptr&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        // ... removed other member functions for simplicity&#xD;&#xA;        T* get() { return ptr; }&#xD;&#xA;&#xD;&#xA;        template <typename... Args>&#xD;&#xA;        decltype(T::template operator ()(Args()...)) operator ()(Args... args) const&#xD;&#xA;        {&#xD;&#xA;            return (*get()).operator ()(args...);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    private:&#xD;&#xA;        T* ptr;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;However, when I use the `smart_ptr` class for type T without an `operator ()`, it fails to compile (and rightly so).&#xD;&#xA;&#xD;&#xA;What I wanted is to use `std::enable_if` to enable the member function only when T has `operator ()`. It got obscure and complex very fast when I got into doing it, as I was thinking of using SFINAE to detect if T has `operator ()` and then combine it with `std::enable_if` to get what I want. However, I got lost in creating SFINAE that is capable of detecting **a variadic templated `operator ()`** (i.e. **NOT** a duplicate of http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence).&#xD;&#xA;&#xD;&#xA;Can anyone help? Or give another (perhaps simpler) solution?&#xD;&#xA;&#xD;&#xA;p.s. It has to work on GCC 4.5.3.&#xD;&#xA;";;remove duplicate link
32424338;13594962;383306;5;ce3e3285-fe23-484a-859a-d059e66ad92d;2012-11-28 05:24:12.0;"I have the following `smart_ptr` class.&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    class smart_ptr&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        // ... removed other member functions for simplicity&#xD;&#xA;        T* get() { return ptr; }&#xD;&#xA;&#xD;&#xA;        template <typename... Args>&#xD;&#xA;        decltype(T::template operator ()(Args()...)) operator ()(Args... args) const&#xD;&#xA;        {&#xD;&#xA;            return (*get()).operator ()(args...);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    private:&#xD;&#xA;        T* ptr;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;However, when I use the `smart_ptr` class for type T without an `operator ()`, it fails to compile (and rightly so).&#xD;&#xA;&#xD;&#xA;What I wanted is to use `std::enable_if` to enable the member function only when T has `operator ()`. It got obscure and complex very fast when I got into doing it, as I was thinking of using SFINAE to detect if T has `operator ()` and then combine it with `std::enable_if` to get what I want. However, I got lost in creating SFINAE that is capable of detecting **a variadic templated `operator ()`** (i.e. **NOT** a duplicate of http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence).&#xD;&#xA;&#xD;&#xA;Can anyone help? Or give another (perhaps simpler) solution?&#xD;&#xA;&#xD;&#xA;p.s. It has to work on GCC 4.5.3.&#xD;&#xA;";;deleted 72 characters in body
32424800;13594962;383306;5;13cc015d-1ea1-4916-8809-c8c8e3aeba3d;2012-11-28 05:40:21.0;"I have the following `smart_ptr` class.&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    class smart_ptr&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        // ... removed other member functions for simplicity&#xD;&#xA;        T* get() { return ptr; }&#xD;&#xA;&#xD;&#xA;        template <typename... Args>&#xD;&#xA;        decltype(T::template operator ()(Args()...)) operator ()(Args... args) const&#xD;&#xA;        {&#xD;&#xA;            return (*get()).operator ()(args...);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    private:&#xD;&#xA;        T* ptr;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;However, when I use the `smart_ptr` class for type T without an `operator ()`, it fails to compile (and rightly so).&#xD;&#xA;&#xD;&#xA;What I wanted is to use `std::enable_if` to enable the member function only when T has `operator ()`. It got obscure and complex very fast when I got into doing it, as I was thinking of using SFINAE to detect if T has `operator ()` and then combine it with `std::enable_if` to get what I want. However, I got lost in creating SFINAE that is capable of detecting **a variadic templated `operator ()`** (i.e. **NOT** a duplicate of http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence).&#xD;&#xA;&#xD;&#xA;Can anyone help? Or give another (perhaps simpler) solution?&#xD;&#xA;&#xD;&#xA;p.s. It has to work on GCC 4.5.3.&#xD;&#xA;&#xD;&#xA;EDIT: For the sake of completeness, I've answered my own question with a working solution for GCC 4.5.3.";;added 106 characters in body
146912305;13594962;-1;5;613de8cb-20e0-4fca-8da7-7991f14bd37b;2017-05-23 12:04:37.0;"I have the following `smart_ptr` class.&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    class smart_ptr&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        // ... removed other member functions for simplicity&#xD;&#xA;        T* get() { return ptr; }&#xD;&#xA;&#xD;&#xA;        template <typename... Args>&#xD;&#xA;        decltype(T::template operator ()(Args()...)) operator ()(Args... args) const&#xD;&#xA;        {&#xD;&#xA;            return (*get()).operator ()(args...);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    private:&#xD;&#xA;        T* ptr;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;However, when I use the `smart_ptr` class for type T without an `operator ()`, it fails to compile (and rightly so).&#xD;&#xA;&#xD;&#xA;What I wanted is to use `std::enable_if` to enable the member function only when T has `operator ()`. It got obscure and complex very fast when I got into doing it, as I was thinking of using SFINAE to detect if T has `operator ()` and then combine it with `std::enable_if` to get what I want. However, I got lost in creating SFINAE that is capable of detecting **a variadic templated `operator ()`** (i.e. **NOT** a duplicate of https://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence).&#xD;&#xA;&#xD;&#xA;Can anyone help? Or give another (perhaps simpler) solution?&#xD;&#xA;&#xD;&#xA;p.s. It has to work on GCC 4.5.3.&#xD;&#xA;&#xD;&#xA;EDIT: For the sake of completeness, I've answered my own question with a working solution for GCC 4.5.3.";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
