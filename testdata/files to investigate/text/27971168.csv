Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
81683869;27971168;1013719;2;81a86a64-3682-42e1-a9be-8b68af708b26;2015-01-15 19:12:51.0;"This can be done but shouldn't.  You can get the effect out using universal references and templates, but you want to constrain the type to `MyBigType` and things that are implicitly convertible to `MyBigType`.  With some tmp tricks, you can do this:&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;     public:&#xD;&#xA;        template <typename T, typename  = typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type>&#xD;&#xA;        void f(T&& a, int id);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;The first typename will match against the actual type of the parameter, the second is to disallow incompatible types.  I'll take it apart piece by piece&#xD;&#xA;&#xD;&#xA;    std::is_convertible<T, MyBigType>::value&#xD;&#xA;This compile time expression will evaluate to `true` if `T` can be converted implicitly to a `MyBigType`.  For example, if `MyBigType` were a `std::string` and T were a `char*` the expression would be true, but if T were an `int` it would be false.";;
81684271;27971168;1013719;5;94f3899c-da2c-4478-b6db-7b9ff26f263f;2015-01-15 19:17:54.0;"Herb Sutter talks about something similar in [a cppcon talk][1]&#xD;&#xA;&#xD;&#xA;This can be done but shouldn't.  You can get the effect out using universal references and templates, but you want to constrain the type to `MyBigType` and things that are implicitly convertible to `MyBigType`.  With some tmp tricks, you can do this:&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;     public:&#xD;&#xA;        template <typename T, typename  = typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type>&#xD;&#xA;        void f(T&& a, int id);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;The first typename will match against the actual type of the parameter, the second is to disallow incompatible types.  I'll take it apart piece by piece&#xD;&#xA;&#xD;&#xA;    std::is_convertible<T, MyBigType>::value&#xD;&#xA;This compile time expression will evaluate to `true` if `T` can be converted implicitly to a `MyBigType`.  For example, if `MyBigType` were a `std::string` and T were a `char*` the expression would be true, but if T were an `int` it would be false.&#xD;&#xA;&#xD;&#xA;    typename std::enable_if<..., void>::type // where the ... is the above&#xD;&#xA;&#xD;&#xA;this expression will result in `void` in the case that the `is_convertible` expression is true.  When it's false, the expression will be malformed, so the template will be thrown out.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Inside the body of the function you'll need to use perfect forwarding, if you are planning on copy assigning or move assigning, the body would be something like&#xD;&#xA;&#xD;&#xA;    {&#xD;&#xA;        this->a_ = std::forward<T>(a);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  [1]: http://www.youtube.com/watch?v=xnqTKD8uD64#t=1h15m";;added 265 characters in body
81684815;27971168;1013719;5;a7ca4a2e-85ef-4124-9796-504ab82ff993;2015-01-15 19:26:09.0;"Herb Sutter talks about something similar in [a cppcon talk][1]&#xD;&#xA;&#xD;&#xA;This can be done but shouldn't.  You can get the effect out using universal references and templates, but you want to constrain the type to `MyBigType` and things that are implicitly convertible to `MyBigType`.  With some tmp tricks, you can do this:&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;     public:&#xD;&#xA;        template <typename T>&#xD;&#xA;        typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type&#xD;&#xA;        f(T&& a, int id);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;The only template parameter will match against the actual type of the parameter, the `enable_if` return type disallows incompatible types.  I'll take it apart piece by piece&#xD;&#xA;&#xD;&#xA;    std::is_convertible<T, MyBigType>::value&#xD;&#xA;This compile time expression will evaluate to `true` if `T` can be converted implicitly to a `MyBigType`.  For example, if `MyBigType` were a `std::string` and T were a `char*` the expression would be true, but if T were an `int` it would be false.&#xD;&#xA;&#xD;&#xA;    typename std::enable_if<..., void>::type // where the ... is the above&#xD;&#xA;&#xD;&#xA;this expression will result in `void` in the case that the `is_convertible` expression is true.  When it's false, the expression will be malformed, so the template will be thrown out.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Inside the body of the function you'll need to use perfect forwarding, if you are planning on copy assigning or move assigning, the body would be something like&#xD;&#xA;&#xD;&#xA;    {&#xD;&#xA;        this->a_ = std::forward<T>(a);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's a [coliru live example][2] with a `using MyBigType = std::string`&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.youtube.com/watch?v=xnqTKD8uD64#t=1h15m&#xD;&#xA;  [2]: http://coliru.stacked-crooked.com/a/4e0eb90091fdc692";;deleted 9 characters in body
81685444;27971168;1013719;5;292eec34-9e25-4304-8ee1-5d8c3a9dd60a;2015-01-15 19:35:25.0;"Herb Sutter talks about something similar in [a cppcon talk][1]&#xD;&#xA;&#xD;&#xA;This can be done but shouldn't.  You can get the effect out using universal references and templates, but you want to constrain the type to `MyBigType` and things that are implicitly convertible to `MyBigType`.  With some tmp tricks, you can do this:&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;     public:&#xD;&#xA;        template <typename T>&#xD;&#xA;        typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type&#xD;&#xA;        f(T&& a, int id);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;The only template parameter will match against the actual type of the parameter, the `enable_if` return type disallows incompatible types.  I'll take it apart piece by piece&#xD;&#xA;&#xD;&#xA;    std::is_convertible<T, MyBigType>::value&#xD;&#xA;This compile time expression will evaluate to `true` if `T` can be converted implicitly to a `MyBigType`.  For example, if `MyBigType` were a `std::string` and T were a `char*` the expression would be true, but if T were an `int` it would be false.&#xD;&#xA;&#xD;&#xA;    typename std::enable_if<..., void>::type // where the ... is the above&#xD;&#xA;&#xD;&#xA;this expression will result in `void` in the case that the `is_convertible` expression is true.  When it's false, the expression will be malformed, so the template will be thrown out.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Inside the body of the function you'll need to use perfect forwarding, if you are planning on copy assigning or move assigning, the body would be something like&#xD;&#xA;&#xD;&#xA;    {&#xD;&#xA;        this->a_ = std::forward<T>(a);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's a [coliru live example][2] with a `using MyBigType = std::string`.  As Herb says, this function can't be virtual and must be implemented in the header.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.youtube.com/watch?v=xnqTKD8uD64#t=1h15m&#xD;&#xA;  [2]: http://coliru.stacked-crooked.com/a/4e0eb90091fdc692";;added 86 characters in body
81686211;27971168;1013719;5;b04bf561-d91a-4cbc-b800-83451a9212bd;2015-01-15 19:47:37.0;"Herb Sutter talks about something similar in [a cppcon talk][1]&#xD;&#xA;&#xD;&#xA;This can be done but shouldn't.  You can get the effect out using universal references and templates, but you want to constrain the type to `MyBigType` and things that are implicitly convertible to `MyBigType`.  With some tmp tricks, you can do this:&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;     public:&#xD;&#xA;        template <typename T>&#xD;&#xA;        typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type&#xD;&#xA;        f(T&& a, int id);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;The only template parameter will match against the actual type of the parameter, the `enable_if` return type disallows incompatible types.  I'll take it apart piece by piece&#xD;&#xA;&#xD;&#xA;    std::is_convertible<T, MyBigType>::value&#xD;&#xA;This compile time expression will evaluate to `true` if `T` can be converted implicitly to a `MyBigType`.  For example, if `MyBigType` were a `std::string` and T were a `char*` the expression would be true, but if T were an `int` it would be false.&#xD;&#xA;&#xD;&#xA;    typename std::enable_if<..., void>::type // where the ... is the above&#xD;&#xA;&#xD;&#xA;this expression will result in `void` in the case that the `is_convertible` expression is true.  When it's false, the expression will be malformed, so the template will be thrown out.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Inside the body of the function you'll need to use perfect forwarding, if you are planning on copy assigning or move assigning, the body would be something like&#xD;&#xA;&#xD;&#xA;    {&#xD;&#xA;        this->a_ = std::forward<T>(a);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's a [coliru live example][2] with a `using MyBigType = std::string`.  As Herb says, this function can't be virtual and must be implemented in the header.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;The slightly slower option is to take the argument by value.  If you do&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;      public:&#xD;&#xA;        void f(MyBigType a, int id) {&#xD;&#xA;            this->a_ = std::move(a); // move assignment&#xD;&#xA;        } &#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;In the case where `f` is passed an lvalue, it will copy construct `a` from its argument, then move assign it into `this->a_`.  In the case that `f` is passed an rvalue, it will move construct `a` from the argument and then move assign.  A live example of this behavior is [here][3].  Note that I use `-fno-elide-constructors`, without that flag, the rvalue cases elides the move construction and only the move assignment takes place.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.youtube.com/watch?v=xnqTKD8uD64#t=1h15m&#xD;&#xA;  [2]: http://coliru.stacked-crooked.com/a/4e0eb90091fdc692&#xD;&#xA;  [3]: http://coliru.stacked-crooked.com/a/8c912ecb313ec8e4";;added 743 characters in body
81686743;27971168;1013719;5;897b624f-302c-4d2a-ab57-37c48bdad0ba;2015-01-15 19:57:10.0;"Herb Sutter talks about something similar in [a cppcon talk][1]&#xD;&#xA;&#xD;&#xA;This can be done but probably shouldn't.  You can get the effect out using universal references and templates, but you want to constrain the type to `MyBigType` and things that are implicitly convertible to `MyBigType`.  With some tmp tricks, you can do this:&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;     public:&#xD;&#xA;        template <typename T>&#xD;&#xA;        typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type&#xD;&#xA;        f(T&& a, int id);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;The only template parameter will match against the actual type of the parameter, the `enable_if` return type disallows incompatible types.  I'll take it apart piece by piece&#xD;&#xA;&#xD;&#xA;    std::is_convertible<T, MyBigType>::value&#xD;&#xA;This compile time expression will evaluate to `true` if `T` can be converted implicitly to a `MyBigType`.  For example, if `MyBigType` were a `std::string` and T were a `char*` the expression would be true, but if T were an `int` it would be false.&#xD;&#xA;&#xD;&#xA;    typename std::enable_if<..., void>::type // where the ... is the above&#xD;&#xA;&#xD;&#xA;this expression will result in `void` in the case that the `is_convertible` expression is true.  When it's false, the expression will be malformed, so the template will be thrown out.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Inside the body of the function you'll need to use perfect forwarding, if you are planning on copy assigning or move assigning, the body would be something like&#xD;&#xA;&#xD;&#xA;    {&#xD;&#xA;        this->a_ = std::forward<T>(a);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's a [coliru live example][2] with a `using MyBigType = std::string`.  As Herb says, this function can't be virtual and must be implemented in the header.  The error messages you get from calling with a wrong type will be pretty rough compared to the non-templated overloads.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Thanks to [Barry][3]'s comment for this suggestion, to reduce repetition, it's probably a good idea to create a template alias for the SFINAE mechanism.  If you declare in your class &#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    using EnableIfIsMyBigType = typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type;&#xD;&#xA;&#xD;&#xA;then you could reduce the declarations to&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    EnableIfIsMyBigType<T>&#xD;&#xA;    f(T&& a, int id);&#xD;&#xA;&#xD;&#xA;However, this assumes all of your overloads have a `void` return type.  If the return type differs you could use a two-argument alias instead&#xD;&#xA;&#xD;&#xA;    template <typename T, typename R>&#xD;&#xA;    using EnableIfIsMyBigType = typename std::enable_if<std::is_convertible<T, MyBigType>::value,R>::type;&#xD;&#xA;&#xD;&#xA;Then declare with the return type specified&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    EnableIfIsMyBigType<T, void> // void is the return type&#xD;&#xA;    f(T&& a, int id);&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The slightly slower option is to take the argument by value.  If you do&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;      public:&#xD;&#xA;        void f(MyBigType a, int id) {&#xD;&#xA;            this->a_ = std::move(a); // move assignment&#xD;&#xA;        } &#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;In the case where `f` is passed an lvalue, it will copy construct `a` from its argument, then move assign it into `this->a_`.  In the case that `f` is passed an rvalue, it will move construct `a` from the argument and then move assign.  A live example of this behavior is [here][4].  Note that I use `-fno-elide-constructors`, without that flag, the rvalue cases elides the move construction and only the move assignment takes place.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.youtube.com/watch?v=xnqTKD8uD64#t=1h15m&#xD;&#xA;  [2]: http://coliru.stacked-crooked.com/a/4e0eb90091fdc692&#xD;&#xA;  [3]: http://stackoverflow.com/users/2069064/barry&#xD;&#xA;  [4]: http://coliru.stacked-crooked.com/a/8c912ecb313ec8e4";;added 743 characters in body
81694096;27971168;1013719;5;90f7fdc6-ecde-4111-ae0c-6e8a1c862136;2015-01-15 22:06:58.0;"Herb Sutter talks about something similar in [a cppcon talk][1]&#xD;&#xA;&#xD;&#xA;This can be done but probably shouldn't.  You can get the effect out using universal references and templates, but you want to constrain the type to `MyBigType` and things that are implicitly convertible to `MyBigType`.  With some tmp tricks, you can do this:&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;     public:&#xD;&#xA;        template <typename T>&#xD;&#xA;        typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type&#xD;&#xA;        f(T&& a, int id);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;The only template parameter will match against the actual type of the parameter, the `enable_if` return type disallows incompatible types.  I'll take it apart piece by piece&#xD;&#xA;&#xD;&#xA;    std::is_convertible<T, MyBigType>::value&#xD;&#xA;This compile time expression will evaluate to `true` if `T` can be converted implicitly to a `MyBigType`.  For example, if `MyBigType` were a `std::string` and T were a `char*` the expression would be true, but if T were an `int` it would be false.&#xD;&#xA;&#xD;&#xA;    typename std::enable_if<..., void>::type // where the ... is the above&#xD;&#xA;&#xD;&#xA;this expression will result in `void` in the case that the `is_convertible` expression is true.  When it's false, the expression will be malformed, so the template will be thrown out.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Inside the body of the function you'll need to use perfect forwarding, if you are planning on copy assigning or move assigning, the body would be something like&#xD;&#xA;&#xD;&#xA;    {&#xD;&#xA;        this->a_ = std::forward<T>(a);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's a [coliru live example][2] with a `using MyBigType = std::string`.  As Herb says, this function can't be virtual and must be implemented in the header.  The error messages you get from calling with a wrong type will be pretty rough compared to the non-templated overloads.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Thanks to [Barry][3]'s comment for this suggestion, to reduce repetition, it's probably a good idea to create a template alias for the SFINAE mechanism.  If you declare in your class &#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    using EnableIfIsMyBigType = typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type;&#xD;&#xA;&#xD;&#xA;then you could reduce the declarations to&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    EnableIfIsMyBigType<T>&#xD;&#xA;    f(T&& a, int id);&#xD;&#xA;&#xD;&#xA;However, this assumes all of your overloads have a `void` return type.  If the return type differs you could use a two-argument alias instead&#xD;&#xA;&#xD;&#xA;    template <typename T, typename R>&#xD;&#xA;    using EnableIfIsMyBigType = typename std::enable_if<std::is_convertible<T, MyBigType>::value,R>::type;&#xD;&#xA;&#xD;&#xA;Then declare with the return type specified&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    EnableIfIsMyBigType<T, void> // void is the return type&#xD;&#xA;    f(T&& a, int id);&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The slightly slower option is to take the argument by value.  If you do&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;      public:&#xD;&#xA;        void f(MyBigType a, int id) {&#xD;&#xA;            this->a_ = std::move(a); // move assignment&#xD;&#xA;        } &#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;In the case where `f` is passed an lvalue, it will copy construct `a` from its argument, then move assign it into `this->a_`.  In the case that `f` is passed an rvalue, it will move construct `a` from the argument and then move assign.  A live example of this behavior is [here][4].  Note that I use `-fno-elide-constructors`, without that flag, the rvalue cases elides the move construction and only the move assignment takes place.&#xD;&#xA;&#xD;&#xA;If the object is expensive to move (`std::array` for example) this approach will be noticeably slower than the super-optimized first version.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.youtube.com/watch?v=xnqTKD8uD64#t=1h10m58s&#xD;&#xA;  [2]: http://coliru.stacked-crooked.com/a/4e0eb90091fdc692&#xD;&#xA;  [3]: http://stackoverflow.com/users/2069064/barry&#xD;&#xA;  [4]: http://coliru.stacked-crooked.com/a/8c912ecb313ec8e4";;added 148 characters in body
81705443;27971168;1013719;5;2cdb8054-3b6d-46f1-8bb0-a037a37cd6ec;2015-01-16 03:09:58.0;"Herb Sutter talks about something similar in [a cppcon talk][1]&#xD;&#xA;&#xD;&#xA;This can be done but probably shouldn't.  You can get the effect out using universal references and templates, but you want to constrain the type to `MyBigType` and things that are implicitly convertible to `MyBigType`.  With some tmp tricks, you can do this:&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;      public:&#xD;&#xA;        template <typename T>&#xD;&#xA;        typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type&#xD;&#xA;        f(T&& a, int id);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;The only template parameter will match against the actual type of the parameter, the `enable_if` return type disallows incompatible types.  I'll take it apart piece by piece&#xD;&#xA;&#xD;&#xA;    std::is_convertible<T, MyBigType>::value&#xD;&#xA;This compile time expression will evaluate to `true` if `T` can be converted implicitly to a `MyBigType`.  For example, if `MyBigType` were a `std::string` and T were a `char*` the expression would be true, but if T were an `int` it would be false.&#xD;&#xA;&#xD;&#xA;    typename std::enable_if<..., void>::type // where the ... is the above&#xD;&#xA;&#xD;&#xA;this expression will result in `void` in the case that the `is_convertible` expression is true.  When it's false, the expression will be malformed, so the template will be thrown out.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Inside the body of the function you'll need to use perfect forwarding, if you are planning on copy assigning or move assigning, the body would be something like&#xD;&#xA;&#xD;&#xA;    {&#xD;&#xA;        this->a_ = std::forward<T>(a);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's a [coliru live example][2] with a `using MyBigType = std::string`.  As Herb says, this function can't be virtual and must be implemented in the header.  The error messages you get from calling with a wrong type will be pretty rough compared to the non-templated overloads.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Thanks to [Barry][3]'s comment for this suggestion, to reduce repetition, it's probably a good idea to create a template alias for the SFINAE mechanism.  If you declare in your class &#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    using EnableIfIsMyBigType = typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type;&#xD;&#xA;&#xD;&#xA;then you could reduce the declarations to&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    EnableIfIsMyBigType<T>&#xD;&#xA;    f(T&& a, int id);&#xD;&#xA;&#xD;&#xA;However, this assumes all of your overloads have a `void` return type.  If the return type differs you could use a two-argument alias instead&#xD;&#xA;&#xD;&#xA;    template <typename T, typename R>&#xD;&#xA;    using EnableIfIsMyBigType = typename std::enable_if<std::is_convertible<T, MyBigType>::value,R>::type;&#xD;&#xA;&#xD;&#xA;Then declare with the return type specified&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    EnableIfIsMyBigType<T, void> // void is the return type&#xD;&#xA;    f(T&& a, int id);&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The slightly slower option is to take the argument by value.  If you do&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;      public:&#xD;&#xA;        void f(MyBigType a, int id) {&#xD;&#xA;            this->a_ = std::move(a); // move assignment&#xD;&#xA;        } &#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;In the case where `f` is passed an lvalue, it will copy construct `a` from its argument, then move assign it into `this->a_`.  In the case that `f` is passed an rvalue, it will move construct `a` from the argument and then move assign.  A live example of this behavior is [here][4].  Note that I use `-fno-elide-constructors`, without that flag, the rvalue cases elides the move construction and only the move assignment takes place.&#xD;&#xA;&#xD;&#xA;If the object is expensive to move (`std::array` for example) this approach will be noticeably slower than the super-optimized first version.  Also, consider watching [this part of Herb's talk][5] that [Chris Drew][6] links to in the comments to understand when it could be slower than using references.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.youtube.com/watch?v=xnqTKD8uD64#t=1h10m58s&#xD;&#xA;  [2]: http://coliru.stacked-crooked.com/a/4e0eb90091fdc692&#xD;&#xA;  [3]: http://stackoverflow.com/users/2069064/barry&#xD;&#xA;  [4]: http://coliru.stacked-crooked.com/a/8c912ecb313ec8e4&#xD;&#xA;  [5]: https://www.youtube.com/watch?v=xnqTKD8uD64&t=1h03m44s&#xD;&#xA;  [6]: http://stackoverflow.com/users/3422652/chris-drew";;added 283 characters in body
82844686;27971168;1013719;5;3e7f8407-e08a-4242-9f48-2b3b2843a820;2015-02-02 01:05:48.0;"Herb Sutter talks about something similar in [a cppcon talk][1]&#xD;&#xA;&#xD;&#xA;This can be done but probably shouldn't.  You can get the effect out using universal references and templates, but you want to constrain the type to `MyBigType` and things that are implicitly convertible to `MyBigType`.  With some tmp tricks, you can do this:&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;      public:&#xD;&#xA;        template <typename T>&#xD;&#xA;        typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type&#xD;&#xA;        f(T&& a, int id);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;The only template parameter will match against the actual type of the parameter, the `enable_if` return type disallows incompatible types.  I'll take it apart piece by piece&#xD;&#xA;&#xD;&#xA;    std::is_convertible<T, MyBigType>::value&#xD;&#xA;This compile time expression will evaluate to `true` if `T` can be converted implicitly to a `MyBigType`.  For example, if `MyBigType` were a `std::string` and T were a `char*` the expression would be true, but if T were an `int` it would be false.&#xD;&#xA;&#xD;&#xA;    typename std::enable_if<..., void>::type // where the ... is the above&#xD;&#xA;&#xD;&#xA;this expression will result in `void` in the case that the `is_convertible` expression is true.  When it's false, the expression will be malformed, so the template will be thrown out.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Inside the body of the function you'll need to use perfect forwarding, if you are planning on copy assigning or move assigning, the body would be something like&#xD;&#xA;&#xD;&#xA;    {&#xD;&#xA;        this->a_ = std::forward<T>(a);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's a [coliru live example][2] with a `using MyBigType = std::string`.  As Herb says, this function can't be virtual and must be implemented in the header.  The error messages you get from calling with a wrong type will be pretty rough compared to the non-templated overloads.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Thanks to [Barry][3]'s comment for this suggestion, to reduce repetition, it's probably a good idea to create a template alias for the SFINAE mechanism.  If you declare in your class &#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    using EnableIfIsMyBigType = typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type;&#xD;&#xA;&#xD;&#xA;then you could reduce the declarations to&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    EnableIfIsMyBigType<T>&#xD;&#xA;    f(T&& a, int id);&#xD;&#xA;&#xD;&#xA;However, this assumes all of your overloads have a `void` return type.  If the return type differs you could use a two-argument alias instead&#xD;&#xA;&#xD;&#xA;    template <typename T, typename R>&#xD;&#xA;    using EnableIfIsMyBigType = typename std::enable_if<std::is_convertible<T, MyBigType>::value,R>::type;&#xD;&#xA;&#xD;&#xA;Then declare with the return type specified&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    EnableIfIsMyBigType<T, void> // void is the return type&#xD;&#xA;    f(T&& a, int id);&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The slightly slower option is to take the argument by value.  If you do&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;      public:&#xD;&#xA;        void f(MyBigType a, int id) {&#xD;&#xA;            this->a_ = std::move(a); // move assignment&#xD;&#xA;        } &#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;In the case where `f` is passed an lvalue, it will copy construct `a` from its argument, then move assign it into `this->a_`.  In the case that `f` is passed an rvalue, it will move construct `a` from the argument and then move assign.  A live example of this behavior is [here][4].  Note that I use `-fno-elide-constructors`, without that flag, the rvalue cases elides the move construction and only the move assignment takes place.&#xD;&#xA;&#xD;&#xA;If the object is expensive to move (`std::array` for example) this approach will be noticeably slower than the super-optimized first version.  Also, consider watching [this part of Herb's talk][5] that [Chris Drew][6] links to in the comments to understand when it could be slower than using references. If you have a copy of [Effective Modern C++ by Scott Meyers][7], he discusses the ups and downs in item 41.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.youtube.com/watch?v=xnqTKD8uD64#t=1h10m58s&#xD;&#xA;  [2]: http://coliru.stacked-crooked.com/a/4e0eb90091fdc692&#xD;&#xA;  [3]: http://stackoverflow.com/users/2069064/barry&#xD;&#xA;  [4]: http://coliru.stacked-crooked.com/a/8c912ecb313ec8e4&#xD;&#xA;  [5]: https://www.youtube.com/watch?v=xnqTKD8uD64&t=1h03m44s&#xD;&#xA;  [6]: http://stackoverflow.com/users/3422652/chris-drew&#xD;&#xA;  [7]: http://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996";;added 178 characters in body
146594725;27971168;-1;5;df87f134-2585-412a-b7e1-9ebb62429e8d;2017-05-23 11:52:56.0;"Herb Sutter talks about something similar in [a cppcon talk][1]&#xD;&#xA;&#xD;&#xA;This can be done but probably shouldn't.  You can get the effect out using universal references and templates, but you want to constrain the type to `MyBigType` and things that are implicitly convertible to `MyBigType`.  With some tmp tricks, you can do this:&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;      public:&#xD;&#xA;        template <typename T>&#xD;&#xA;        typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type&#xD;&#xA;        f(T&& a, int id);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;The only template parameter will match against the actual type of the parameter, the `enable_if` return type disallows incompatible types.  I'll take it apart piece by piece&#xD;&#xA;&#xD;&#xA;    std::is_convertible<T, MyBigType>::value&#xD;&#xA;This compile time expression will evaluate to `true` if `T` can be converted implicitly to a `MyBigType`.  For example, if `MyBigType` were a `std::string` and T were a `char*` the expression would be true, but if T were an `int` it would be false.&#xD;&#xA;&#xD;&#xA;    typename std::enable_if<..., void>::type // where the ... is the above&#xD;&#xA;&#xD;&#xA;this expression will result in `void` in the case that the `is_convertible` expression is true.  When it's false, the expression will be malformed, so the template will be thrown out.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Inside the body of the function you'll need to use perfect forwarding, if you are planning on copy assigning or move assigning, the body would be something like&#xD;&#xA;&#xD;&#xA;    {&#xD;&#xA;        this->a_ = std::forward<T>(a);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's a [coliru live example][2] with a `using MyBigType = std::string`.  As Herb says, this function can't be virtual and must be implemented in the header.  The error messages you get from calling with a wrong type will be pretty rough compared to the non-templated overloads.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Thanks to [Barry][3]'s comment for this suggestion, to reduce repetition, it's probably a good idea to create a template alias for the SFINAE mechanism.  If you declare in your class &#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    using EnableIfIsMyBigType = typename std::enable_if<std::is_convertible<T, MyBigType>::value, void>::type;&#xD;&#xA;&#xD;&#xA;then you could reduce the declarations to&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    EnableIfIsMyBigType<T>&#xD;&#xA;    f(T&& a, int id);&#xD;&#xA;&#xD;&#xA;However, this assumes all of your overloads have a `void` return type.  If the return type differs you could use a two-argument alias instead&#xD;&#xA;&#xD;&#xA;    template <typename T, typename R>&#xD;&#xA;    using EnableIfIsMyBigType = typename std::enable_if<std::is_convertible<T, MyBigType>::value,R>::type;&#xD;&#xA;&#xD;&#xA;Then declare with the return type specified&#xD;&#xA;&#xD;&#xA;    template <typename T>&#xD;&#xA;    EnableIfIsMyBigType<T, void> // void is the return type&#xD;&#xA;    f(T&& a, int id);&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The slightly slower option is to take the argument by value.  If you do&#xD;&#xA;&#xD;&#xA;    class MyClass {&#xD;&#xA;      public:&#xD;&#xA;        void f(MyBigType a, int id) {&#xD;&#xA;            this->a_ = std::move(a); // move assignment&#xD;&#xA;        } &#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;In the case where `f` is passed an lvalue, it will copy construct `a` from its argument, then move assign it into `this->a_`.  In the case that `f` is passed an rvalue, it will move construct `a` from the argument and then move assign.  A live example of this behavior is [here][4].  Note that I use `-fno-elide-constructors`, without that flag, the rvalue cases elides the move construction and only the move assignment takes place.&#xD;&#xA;&#xD;&#xA;If the object is expensive to move (`std::array` for example) this approach will be noticeably slower than the super-optimized first version.  Also, consider watching [this part of Herb's talk][5] that [Chris Drew][6] links to in the comments to understand when it could be slower than using references. If you have a copy of [Effective Modern C++ by Scott Meyers][7], he discusses the ups and downs in item 41.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.youtube.com/watch?v=xnqTKD8uD64#t=1h10m58s&#xD;&#xA;  [2]: http://coliru.stacked-crooked.com/a/4e0eb90091fdc692&#xD;&#xA;  [3]: https://stackoverflow.com/users/2069064/barry&#xD;&#xA;  [4]: http://coliru.stacked-crooked.com/a/8c912ecb313ec8e4&#xD;&#xA;  [5]: https://www.youtube.com/watch?v=xnqTKD8uD64&t=1h03m44s&#xD;&#xA;  [6]: https://stackoverflow.com/users/3422652/chris-drew&#xD;&#xA;  [7]: http://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
