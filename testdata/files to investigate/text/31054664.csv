Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
93671675;31054664;1870803;2;2df976af-e482-48c5-8a07-5ff30451511e;2015-06-25 15:30:14.0;"You have `HttpResponseException`, same as you have with `WebAPI`.&#xD;&#xA;&#xD;&#xA;The source can be found [here](https://github.com/aspnet/Mvc/blob/e0b8532735997c439e11fff68dd342d5af59f05f/src/Microsoft.AspNet.Mvc.WebApiCompatShim/HttpResponseException.cs)";;
93691202;31054664;1870803;5;016d6cc8-e282-4276-bbcb-b90acf3e060f;2015-06-25 20:06:14.0;"After a [brief talk with @davidfowl][1], it seems that ASP.NET 5 has no such notion of `HttpException` or `HttpResponseException` that ""magically"" turn to response messages. &#xD;&#xA;&#xD;&#xA;What you can do, is [hook into the ASP.NET 5 pipeline via MiddleWare][2], and create one that handles the exceptions for you.&#xD;&#xA;&#xD;&#xA;Here is an example from the [source code][3] of their error handler middleware which will set the response status code to 500 in case of an exception further up the pipeline:&#xD;&#xA;&#xD;&#xA;    public class ErrorHandlerMiddleware&#xD;&#xA;    {&#xD;&#xA;        private readonly RequestDelegate _next;&#xD;&#xA;        private readonly ErrorHandlerOptions _options;&#xD;&#xA;        private readonly ILogger _logger;&#xD;&#xA;&#xD;&#xA;        public ErrorHandlerMiddleware(RequestDelegate next, ILoggerFactory loggerFactory, ErrorHandlerOptions options)&#xD;&#xA;        {&#xD;&#xA;            _next = next;&#xD;&#xA;            _options = options;&#xD;&#xA;            _logger = loggerFactory.CreateLogger<ErrorHandlerMiddleware>();&#xD;&#xA;            if (_options.ErrorHandler == null)&#xD;&#xA;            {&#xD;&#xA;                _options.ErrorHandler = _next;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public async Task Invoke(HttpContext context)&#xD;&#xA;        {&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                await _next(context);&#xD;&#xA;            }&#xD;&#xA;            catch (Exception ex)&#xD;&#xA;            {&#xD;&#xA;                _logger.LogError(""An unhandled exception has occurred: "" + ex.Message, ex);&#xD;&#xA;                // We can't do anything if the response has already started, just abort.&#xD;&#xA;                if (context.Response.HasStarted)&#xD;&#xA;                {&#xD;&#xA;                    _logger.LogWarning(""The response has already started, the error handler will not be executed."");&#xD;&#xA;                    throw;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                PathString originalPath = context.Request.Path;&#xD;&#xA;                if (_options.ErrorHandlingPath.HasValue)&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = _options.ErrorHandlingPath;&#xD;&#xA;                }&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    var errorHandlerFeature = new ErrorHandlerFeature()&#xD;&#xA;                    {&#xD;&#xA;                        Error = ex,&#xD;&#xA;                    };&#xD;&#xA;                    context.SetFeature<IErrorHandlerFeature>(errorHandlerFeature);&#xD;&#xA;                    context.Response.StatusCode = 500;&#xD;&#xA;                    context.Response.Headers.Clear();&#xD;&#xA;                    // TODO: Try clearing any buffered data. The buffering feature/middleware has not been designed yet.&#xD;&#xA;                    await _options.ErrorHandler(context);&#xD;&#xA;                    // TODO: Optional re-throw? We'll re-throw the original exception by default if the error handler throws.&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;                catch (Exception ex2)&#xD;&#xA;                {&#xD;&#xA;                    // Suppress secondary exceptions, re-throw the original.&#xD;&#xA;                    _logger.LogError(""An exception was thrown attempting to execute the error handler."", ex2);&#xD;&#xA;                }&#xD;&#xA;                finally&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = originalPath;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                throw; // Re-throw the original if we couldn't handle it&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://twitter.com/YuvalItzchakov/status/614094855367581696&#xD;&#xA;  [2]: http://www.mikesdotnetting.com/Article/269/asp-net-5-middleware-or-where-has-my-httpmodule-gone&#xD;&#xA;  [3]: https://github.com/aspnet/Diagnostics/blob/dev/src/Microsoft.AspNet.Diagnostics/ErrorHandlerMiddleware.cs";;added 2996 characters in body
93691599;31054664;1870803;5;c5f5541e-f929-4c11-a600-e5750557bc4a;2015-06-25 20:12:21.0;"After a [brief chat with @davidfowl][1], it seems that ASP.NET 5 has no such notion of `HttpException` or `HttpResponseException` that ""magically"" turn to response messages. &#xD;&#xA;&#xD;&#xA;What you can do, is [hook into the ASP.NET 5 pipeline via MiddleWare][2], and create one that handles the exceptions for you.&#xD;&#xA;&#xD;&#xA;Here is an example from the [source code][3] of their error handler middleware which will set the response status code to 500 in case of an exception further up the pipeline:&#xD;&#xA;&#xD;&#xA;    public class ErrorHandlerMiddleware&#xD;&#xA;    {&#xD;&#xA;        private readonly RequestDelegate _next;&#xD;&#xA;        private readonly ErrorHandlerOptions _options;&#xD;&#xA;        private readonly ILogger _logger;&#xD;&#xA;&#xD;&#xA;        public ErrorHandlerMiddleware(RequestDelegate next, ILoggerFactory loggerFactory, ErrorHandlerOptions options)&#xD;&#xA;        {&#xD;&#xA;            _next = next;&#xD;&#xA;            _options = options;&#xD;&#xA;            _logger = loggerFactory.CreateLogger<ErrorHandlerMiddleware>();&#xD;&#xA;            if (_options.ErrorHandler == null)&#xD;&#xA;            {&#xD;&#xA;                _options.ErrorHandler = _next;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public async Task Invoke(HttpContext context)&#xD;&#xA;        {&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                await _next(context);&#xD;&#xA;            }&#xD;&#xA;            catch (Exception ex)&#xD;&#xA;            {&#xD;&#xA;                _logger.LogError(""An unhandled exception has occurred: "" + ex.Message, ex);&#xD;&#xA;                // We can't do anything if the response has already started, just abort.&#xD;&#xA;                if (context.Response.HasStarted)&#xD;&#xA;                {&#xD;&#xA;                    _logger.LogWarning(""The response has already started, the error handler will not be executed."");&#xD;&#xA;                    throw;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                PathString originalPath = context.Request.Path;&#xD;&#xA;                if (_options.ErrorHandlingPath.HasValue)&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = _options.ErrorHandlingPath;&#xD;&#xA;                }&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    var errorHandlerFeature = new ErrorHandlerFeature()&#xD;&#xA;                    {&#xD;&#xA;                        Error = ex,&#xD;&#xA;                    };&#xD;&#xA;                    context.SetFeature<IErrorHandlerFeature>(errorHandlerFeature);&#xD;&#xA;                    context.Response.StatusCode = 500;&#xD;&#xA;                    context.Response.Headers.Clear();&#xD;&#xA;                    // TODO: Try clearing any buffered data. The buffering feature/middleware has not been designed yet.&#xD;&#xA;                    await _options.ErrorHandler(context);&#xD;&#xA;                    // TODO: Optional re-throw? We'll re-throw the original exception by default if the error handler throws.&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;                catch (Exception ex2)&#xD;&#xA;                {&#xD;&#xA;                    // Suppress secondary exceptions, re-throw the original.&#xD;&#xA;                    _logger.LogError(""An exception was thrown attempting to execute the error handler."", ex2);&#xD;&#xA;                }&#xD;&#xA;                finally&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = originalPath;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                throw; // Re-throw the original if we couldn't handle it&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;And you need to register it with `StartUp.cs`:&#xD;&#xA;&#xD;&#xA;    public class Startup&#xD;&#xA;    {&#xD;&#xA;        public void Configure(IApplicationBuilder app, &#xD;&#xA;                              IHostingEnvironment env, &#xD;&#xA;                              ILoggerFactory loggerfactory)&#xD;&#xA;        {&#xD;&#xA;           app.UseMiddleWare<ExceptionHandlerMiddleware>&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  [1]: https://twitter.com/YuvalItzchakov/status/614094855367581696&#xD;&#xA;  [2]: http://www.mikesdotnetting.com/Article/269/asp-net-5-middleware-or-where-has-my-httpmodule-gone&#xD;&#xA;  [3]: https://github.com/aspnet/Diagnostics/blob/dev/src/Microsoft.AspNet.Diagnostics/ErrorHandlerMiddleware.cs";;edited body
93725182;31054664;1870803;5;f9d2b9dc-36b0-4ef2-aacf-1e9bb0209937;2015-06-26 08:42:10.0;"After a [brief chat with @davidfowl][1], it seems that ASP.NET 5 has no such notion of `HttpException` or `HttpResponseException` that ""magically"" turn to response messages. &#xD;&#xA;&#xD;&#xA;What you can do, is [hook into the ASP.NET 5 pipeline via MiddleWare][2], and create one that handles the exceptions for you.&#xD;&#xA;&#xD;&#xA;Here is an example from the [source code][3] of their error handler middleware which will set the response status code to 500 in case of an exception further up the pipeline:&#xD;&#xA;&#xD;&#xA;    public class ErrorHandlerMiddleware&#xD;&#xA;    {&#xD;&#xA;        private readonly RequestDelegate _next;&#xD;&#xA;        private readonly ErrorHandlerOptions _options;&#xD;&#xA;        private readonly ILogger _logger;&#xD;&#xA;&#xD;&#xA;        public ErrorHandlerMiddleware(RequestDelegate next, &#xD;&#xA;                                      ILoggerFactory loggerFactory,&#xD;&#xA;                                      ErrorHandlerOptions options)&#xD;&#xA;        {&#xD;&#xA;            _next = next;&#xD;&#xA;            _options = options;&#xD;&#xA;            _logger = loggerFactory.CreateLogger<ErrorHandlerMiddleware>();&#xD;&#xA;            if (_options.ErrorHandler == null)&#xD;&#xA;            {&#xD;&#xA;                _options.ErrorHandler = _next;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public async Task Invoke(HttpContext context)&#xD;&#xA;        {&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                await _next(context);&#xD;&#xA;            }&#xD;&#xA;            catch (Exception ex)&#xD;&#xA;            {&#xD;&#xA;                _logger.LogError(""An unhandled exception has occurred: "" + ex.Message, ex);&#xD;&#xA;                // We can't do anything if the response has already started, just abort.&#xD;&#xA;                if (context.Response.HasStarted)&#xD;&#xA;                {&#xD;&#xA;                    _logger.LogWarning(""The response has already started, the error handler will not be executed."");&#xD;&#xA;                    throw;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                PathString originalPath = context.Request.Path;&#xD;&#xA;                if (_options.ErrorHandlingPath.HasValue)&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = _options.ErrorHandlingPath;&#xD;&#xA;                }&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    var errorHandlerFeature = new ErrorHandlerFeature()&#xD;&#xA;                    {&#xD;&#xA;                        Error = ex,&#xD;&#xA;                    };&#xD;&#xA;                    context.SetFeature<IErrorHandlerFeature>(errorHandlerFeature);&#xD;&#xA;                    context.Response.StatusCode = 500;&#xD;&#xA;                    context.Response.Headers.Clear();&#xD;&#xA;                    // TODO: Try clearing any buffered data. The buffering feature/middleware has not been designed yet.&#xD;&#xA;                    await _options.ErrorHandler(context);&#xD;&#xA;                    // TODO: Optional re-throw? We'll re-throw the original exception by default if the error handler throws.&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;                catch (Exception ex2)&#xD;&#xA;                {&#xD;&#xA;                    // Suppress secondary exceptions, re-throw the original.&#xD;&#xA;                    _logger.LogError(""An exception was thrown attempting to execute the error handler."", ex2);&#xD;&#xA;                }&#xD;&#xA;                finally&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = originalPath;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                throw; // Re-throw the original if we couldn't handle it&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;And you need to register it with `StartUp.cs`:&#xD;&#xA;&#xD;&#xA;    public class Startup&#xD;&#xA;    {&#xD;&#xA;        public void Configure(IApplicationBuilder app, &#xD;&#xA;                              IHostingEnvironment env, &#xD;&#xA;                              ILoggerFactory loggerfactory)&#xD;&#xA;        {&#xD;&#xA;           app.UseMiddleWare<ExceptionHandlerMiddleware>&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  [1]: https://twitter.com/YuvalItzchakov/status/614094855367581696&#xD;&#xA;  [2]: http://www.mikesdotnetting.com/Article/269/asp-net-5-middleware-or-where-has-my-httpmodule-gone&#xD;&#xA;  [3]: https://github.com/aspnet/Diagnostics/blob/dev/src/Microsoft.AspNet.Diagnostics/ErrorHandlerMiddleware.cs";;added 79 characters in body
93725281;31054664;1870803;5;51225042-2eb6-4157-9773-8652338e1925;2015-06-26 08:43:33.0;"After a [brief chat with @davidfowl][1], it seems that ASP.NET 5 has no such notion of `HttpException` or `HttpResponseException` that ""magically"" turn to response messages. &#xD;&#xA;&#xD;&#xA;What you can do, is [hook into the ASP.NET 5 pipeline via MiddleWare][2], and create one that handles the exceptions for you.&#xD;&#xA;&#xD;&#xA;Here is an example from the [source code][3] of their error handler middleware which will set the response status code to 500 in case of an exception further up the pipeline:&#xD;&#xA;&#xD;&#xA;    public class ErrorHandlerMiddleware&#xD;&#xA;    {&#xD;&#xA;        private readonly RequestDelegate _next;&#xD;&#xA;        private readonly ErrorHandlerOptions _options;&#xD;&#xA;        private readonly ILogger _logger;&#xD;&#xA;&#xD;&#xA;        public ErrorHandlerMiddleware(RequestDelegate next, &#xD;&#xA;                                      ILoggerFactory loggerFactory,&#xD;&#xA;                                      ErrorHandlerOptions options)&#xD;&#xA;        {&#xD;&#xA;            _next = next;&#xD;&#xA;            _options = options;&#xD;&#xA;            _logger = loggerFactory.CreateLogger<ErrorHandlerMiddleware>();&#xD;&#xA;            if (_options.ErrorHandler == null)&#xD;&#xA;            {&#xD;&#xA;                _options.ErrorHandler = _next;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public async Task Invoke(HttpContext context)&#xD;&#xA;        {&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                await _next(context);&#xD;&#xA;            }&#xD;&#xA;            catch (Exception ex)&#xD;&#xA;            {&#xD;&#xA;                _logger.LogError(""An unhandled exception has occurred: "" + ex.Message, ex);&#xD;&#xA;            &#xD;&#xA;                if (context.Response.HasStarted)&#xD;&#xA;                {&#xD;&#xA;                    _logger.LogWarning(""The response has already started, &#xD;&#xA;                                        the error handler will not be executed."");&#xD;&#xA;                    throw;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                PathString originalPath = context.Request.Path;&#xD;&#xA;                if (_options.ErrorHandlingPath.HasValue)&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = _options.ErrorHandlingPath;&#xD;&#xA;                }&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    var errorHandlerFeature = new ErrorHandlerFeature()&#xD;&#xA;                    {&#xD;&#xA;                        Error = ex,&#xD;&#xA;                    };&#xD;&#xA;                    context.SetFeature<IErrorHandlerFeature>(errorHandlerFeature);&#xD;&#xA;                    context.Response.StatusCode = 500;&#xD;&#xA;                    context.Response.Headers.Clear();&#xD;&#xA;&#xD;&#xA;                    await _options.ErrorHandler(context);&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;                catch (Exception ex2)&#xD;&#xA;                {&#xD;&#xA;                    _logger.LogError(""An exception was thrown attempting&#xD;&#xA;                                      to execute the error handler."", ex2);&#xD;&#xA;                }&#xD;&#xA;                finally&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = originalPath;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                throw; // Re-throw the original if we couldn't handle it&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;And you need to register it with `StartUp.cs`:&#xD;&#xA;&#xD;&#xA;    public class Startup&#xD;&#xA;    {&#xD;&#xA;        public void Configure(IApplicationBuilder app, &#xD;&#xA;                              IHostingEnvironment env, &#xD;&#xA;                              ILoggerFactory loggerfactory)&#xD;&#xA;        {&#xD;&#xA;           app.UseMiddleWare<ExceptionHandlerMiddleware>&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  [1]: https://twitter.com/YuvalItzchakov/status/614094855367581696&#xD;&#xA;  [2]: http://www.mikesdotnetting.com/Article/269/asp-net-5-middleware-or-where-has-my-httpmodule-gone&#xD;&#xA;  [3]: https://github.com/aspnet/Diagnostics/blob/dev/src/Microsoft.AspNet.Diagnostics/ErrorHandlerMiddleware.cs";;added 79 characters in body
94326109;31054664;1870803;5;c3796beb-ccec-4a39-a555-090d35ce72b2;2015-07-04 10:12:04.0;"After a [brief chat with @davidfowl][1], it seems that ASP.NET 5 has no such notion of `HttpException` or `HttpResponseException` that ""magically"" turn to response messages. &#xD;&#xA;&#xD;&#xA;What you can do, is [hook into the ASP.NET 5 pipeline via MiddleWare][2], and create one that handles the exceptions for you.&#xD;&#xA;&#xD;&#xA;Here is an example from the [source code][3] of their error handler middleware which will set the response status code to 500 in case of an exception further up the pipeline:&#xD;&#xA;&#xD;&#xA;    public class ErrorHandlerMiddleware&#xD;&#xA;    {&#xD;&#xA;        private readonly RequestDelegate _next;&#xD;&#xA;        private readonly ErrorHandlerOptions _options;&#xD;&#xA;        private readonly ILogger _logger;&#xD;&#xA;&#xD;&#xA;        public ErrorHandlerMiddleware(RequestDelegate next, &#xD;&#xA;                                      ILoggerFactory loggerFactory,&#xD;&#xA;                                      ErrorHandlerOptions options)&#xD;&#xA;        {&#xD;&#xA;            _next = next;&#xD;&#xA;            _options = options;&#xD;&#xA;            _logger = loggerFactory.CreateLogger<ErrorHandlerMiddleware>();&#xD;&#xA;            if (_options.ErrorHandler == null)&#xD;&#xA;            {&#xD;&#xA;                _options.ErrorHandler = _next;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public async Task Invoke(HttpContext context)&#xD;&#xA;        {&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                await _next(context);&#xD;&#xA;            }&#xD;&#xA;            catch (Exception ex)&#xD;&#xA;            {&#xD;&#xA;                _logger.LogError(""An unhandled exception has occurred: "" + ex.Message, ex);&#xD;&#xA;            &#xD;&#xA;                if (context.Response.HasStarted)&#xD;&#xA;                {&#xD;&#xA;                    _logger.LogWarning(""The response has already started, &#xD;&#xA;                                        the error handler will not be executed."");&#xD;&#xA;                    throw;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                PathString originalPath = context.Request.Path;&#xD;&#xA;                if (_options.ErrorHandlingPath.HasValue)&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = _options.ErrorHandlingPath;&#xD;&#xA;                }&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    var errorHandlerFeature = new ErrorHandlerFeature()&#xD;&#xA;                    {&#xD;&#xA;                        Error = ex,&#xD;&#xA;                    };&#xD;&#xA;                    context.SetFeature<IErrorHandlerFeature>(errorHandlerFeature);&#xD;&#xA;                    context.Response.StatusCode = 500;&#xD;&#xA;                    context.Response.Headers.Clear();&#xD;&#xA;&#xD;&#xA;                    await _options.ErrorHandler(context);&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;                catch (Exception ex2)&#xD;&#xA;                {&#xD;&#xA;                    _logger.LogError(""An exception was thrown attempting&#xD;&#xA;                                      to execute the error handler."", ex2);&#xD;&#xA;                }&#xD;&#xA;                finally&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = originalPath;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                throw; // Re-throw the original if we couldn't handle it&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;And you need to register it with `StartUp.cs`:&#xD;&#xA;&#xD;&#xA;    public class Startup&#xD;&#xA;    {&#xD;&#xA;        public void Configure(IApplicationBuilder app, &#xD;&#xA;                              IHostingEnvironment env, &#xD;&#xA;                              ILoggerFactory loggerfactory)&#xD;&#xA;        {&#xD;&#xA;           app.UseMiddleWare<ExceptionHandlerMiddleware>();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  [1]: https://twitter.com/YuvalItzchakov/status/614094855367581696&#xD;&#xA;  [2]: http://www.mikesdotnetting.com/Article/269/asp-net-5-middleware-or-where-has-my-httpmodule-gone&#xD;&#xA;  [3]: https://github.com/aspnet/Diagnostics/blob/dev/src/Microsoft.AspNet.Diagnostics/ErrorHandlerMiddleware.cs";;added 3 characters in body
99686681;31054664;1405038;5;8f87d1bc-e63d-4a61-96bd-ac5c8bbeb2d0;2015-09-15 14:17:42.0;"After a [brief chat with @davidfowl][1], it seems that ASP.NET 5 has no such notion of `HttpException` or `HttpResponseException` that ""magically"" turn to response messages. &#xD;&#xA;&#xD;&#xA;What you can do, is [hook into the ASP.NET 5 pipeline via MiddleWare][2], and create one that handles the exceptions for you.&#xD;&#xA;&#xD;&#xA;Here is an example from the [source code][3] of their error handler middleware which will set the response status code to 500 in case of an exception further up the pipeline:&#xD;&#xA;&#xD;&#xA;    public class ErrorHandlerMiddleware&#xD;&#xA;    {&#xD;&#xA;        private readonly RequestDelegate _next;&#xD;&#xA;        private readonly ErrorHandlerOptions _options;&#xD;&#xA;        private readonly ILogger _logger;&#xD;&#xA;&#xD;&#xA;        public ErrorHandlerMiddleware(RequestDelegate next, &#xD;&#xA;                                      ILoggerFactory loggerFactory,&#xD;&#xA;                                      ErrorHandlerOptions options)&#xD;&#xA;        {&#xD;&#xA;            _next = next;&#xD;&#xA;            _options = options;&#xD;&#xA;            _logger = loggerFactory.CreateLogger<ErrorHandlerMiddleware>();&#xD;&#xA;            if (_options.ErrorHandler == null)&#xD;&#xA;            {&#xD;&#xA;                _options.ErrorHandler = _next;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public async Task Invoke(HttpContext context)&#xD;&#xA;        {&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                await _next(context);&#xD;&#xA;            }&#xD;&#xA;            catch (Exception ex)&#xD;&#xA;            {&#xD;&#xA;                _logger.LogError(""An unhandled exception has occurred: "" + ex.Message, ex);&#xD;&#xA;            &#xD;&#xA;                if (context.Response.HasStarted)&#xD;&#xA;                {&#xD;&#xA;                    _logger.LogWarning(""The response has already started, &#xD;&#xA;                                        the error handler will not be executed."");&#xD;&#xA;                    throw;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                PathString originalPath = context.Request.Path;&#xD;&#xA;                if (_options.ErrorHandlingPath.HasValue)&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = _options.ErrorHandlingPath;&#xD;&#xA;                }&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    var errorHandlerFeature = new ErrorHandlerFeature()&#xD;&#xA;                    {&#xD;&#xA;                        Error = ex,&#xD;&#xA;                    };&#xD;&#xA;                    context.SetFeature<IErrorHandlerFeature>(errorHandlerFeature);&#xD;&#xA;                    context.Response.StatusCode = 500;&#xD;&#xA;                    context.Response.Headers.Clear();&#xD;&#xA;&#xD;&#xA;                    await _options.ErrorHandler(context);&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;                catch (Exception ex2)&#xD;&#xA;                {&#xD;&#xA;                    _logger.LogError(""An exception was thrown attempting&#xD;&#xA;                                      to execute the error handler."", ex2);&#xD;&#xA;                }&#xD;&#xA;                finally&#xD;&#xA;                {&#xD;&#xA;                    context.Request.Path = originalPath;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                throw; // Re-throw the original if we couldn't handle it&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;And you need to register it with `StartUp.cs`:&#xD;&#xA;&#xD;&#xA;    public class Startup&#xD;&#xA;    {&#xD;&#xA;        public void Configure(IApplicationBuilder app, &#xD;&#xA;                              IHostingEnvironment env, &#xD;&#xA;                              ILoggerFactory loggerfactory)&#xD;&#xA;        {&#xD;&#xA;           app.UseMiddleWare<ExceptionHandlerMiddleware>();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  [1]: https://twitter.com/YuvalItzchakov/status/614094855367581696&#xD;&#xA;  [2]: http://www.mikesdotnetting.com/Article/269/asp-net-5-middleware-or-where-has-my-httpmodule-gone&#xD;&#xA;  [3]: https://github.com/aspnet/Diagnostics/blob/dev/src/Microsoft.AspNet.Diagnostics/ExceptionHandler/ExceptionHandlerMiddleware.cs";;updated outdated link to github
