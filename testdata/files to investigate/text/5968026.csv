Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
12893295;5968026;505088;2;00035520-da71-49bc-9930-c2b5baf62381;2011-05-11 17:10:55.0;"It's easiest to do this recursively, something like this:&#xD;&#xA;&#xD;&#xA;    procedure WalkChildren(Node: TTreeNode; List: TList<TTreeNode>);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      List.Add(Node);&#xD;&#xA;      for i := 0 to Node.Count-1 do begin&#xD;&#xA;        WalkChildren(Node.Items[i], List);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;Call it like this:&#xD;&#xA;&#xD;&#xA;    List := TList<TTreeNode>.Create;&#xD;&#xA;    WalkChildren(Root, List);&#xD;&#xA;&#xD;&#xA;The version above includes `Root` in the list. If you want to exclude it you can do it like so:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    procedure WalkChildren(Node: TTreeNode; List: TList<TTreeNode>);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      for i := 0 to Node.Count-1 do begin&#xD;&#xA;        List.Add(Node.Items[i]);&#xD;&#xA;        WalkChildren(Node.Items[i], List);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;";;
12893436;5968026;505088;5;6f18f064-edbb-4383-aacc-80bfffe92b4a;2011-05-11 17:17:16.0;"It's easiest to do this recursively, something like this:&#xD;&#xA;&#xD;&#xA;    procedure WalkChildren(Node: TTreeNode; List: TList<TTreeNode>);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      List.Add(Node);&#xD;&#xA;      for i := 0 to Node.Count-1 do begin&#xD;&#xA;        WalkChildren(Node.Items[i], List);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;Call it like this:&#xD;&#xA;&#xD;&#xA;    List := TList<TTreeNode>.Create;&#xD;&#xA;    WalkChildren(Root, List);&#xD;&#xA;&#xD;&#xA;The version above includes `Root` in the list. If you want to exclude it you can do it like so:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    procedure WalkChildren(Node: TTreeNode; List: TList<TTreeNode>);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      for i := 0 to Node.Count-1 do begin&#xD;&#xA;        List.Add(Node.Items[i]);&#xD;&#xA;        WalkChildren(Node.Items[i], List);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;This example adds to a list but you can replace that action with one of your choosing. The point of the above examples is to show how to walk a tree.";;added 153 characters in body
12895108;5968026;505088;5;e844b798-2b03-4701-b69d-bf3c54333af2;2011-05-11 18:26:49.0;"It's easiest to do this recursively, something like this:&#xD;&#xA;&#xD;&#xA;    procedure WalkChildren(Node: TTreeNode; List: TList<TTreeNode>);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      List.Add(Node);&#xD;&#xA;      for i := 0 to Node.Count-1 do begin&#xD;&#xA;        WalkChildren(Node[i], List);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;Call it like this:&#xD;&#xA;&#xD;&#xA;    List := TList<TTreeNode>.Create;&#xD;&#xA;    WalkChildren(Root, List);&#xD;&#xA;&#xD;&#xA;The version above includes `Root` in the list. If you want to exclude it you can do it like so:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    procedure WalkChildren(Node: TTreeNode; List: TList<TTreeNode>);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      for i := 0 to Node.Count-1 do begin&#xD;&#xA;        List.Add(Node[i]);&#xD;&#xA;        WalkChildren(Node[i], List);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;This example adds to a list but you can replace that action with one of your choosing. The point of the above examples is to show how to walk a tree.";;deleted 18 characters in body
12895251;5968026;505088;5;8aecf69a-d8a0-4c3a-b4b8-b958a705ca04;2011-05-11 18:32:05.0;"It's easiest to do this recursively, something like this:&#xD;&#xA;&#xD;&#xA;    procedure WalkChildren(Node: TTreeNode; List: TList<TTreeNode>);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      List.Add(Node);&#xD;&#xA;      for i := 0 to Node.Count-1 do begin&#xD;&#xA;        WalkChildren(Node[i], List);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;Call it like this:&#xD;&#xA;&#xD;&#xA;    List := TList<TTreeNode>.Create;&#xD;&#xA;    WalkChildren(Root, List);&#xD;&#xA;&#xD;&#xA;This example adds to a list but you can replace that action with one of your choosing. The point of the above examples is to show how to walk a tree.&#xD;&#xA;&#xD;&#xA;Now that we can walk one tree, it's time to walk two trees in tandem.&#xD;&#xA;&#xD;&#xA;    procedure TransferSubTree(Src, DestParent: TTreeNode; Dest: TTreeNodes);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      DestParent := Dest.AddChild(DestParent, Src.Text);&#xD;&#xA;      for i := 0 to Src.Count-1 do begin&#xD;&#xA;        TransferSubTree(Src[i], DestParent, Dest);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;You can call it like so:&#xD;&#xA;&#xD;&#xA;    TransferSubTree(SrcTree.Selected, nil, DestTree.Items);";;"added 112 characters in body; edited body"
12895777;5968026;505088;5;30a8f54c-6203-4360-9a56-cea4b5b92f6d;2011-05-11 18:51:18.0;"It's easiest to do this recursively, something like this:&#xD;&#xA;&#xD;&#xA;    procedure WalkChildren(Node: TTreeNode; List: TList<TTreeNode>);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      List.Add(Node);&#xD;&#xA;      for i := 0 to Node.Count-1 do begin&#xD;&#xA;        WalkChildren(Node[i], List);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;Call it like this:&#xD;&#xA;&#xD;&#xA;    List := TList<TTreeNode>.Create;&#xD;&#xA;    WalkChildren(Root, List);&#xD;&#xA;&#xD;&#xA;This example adds to a list but you can replace that action with one of your choosing. The point of the above examples is to show how to walk a tree.&#xD;&#xA;&#xD;&#xA;Now that we can walk one tree, it's time to walk two trees in tandem.&#xD;&#xA;&#xD;&#xA;    procedure CopySubTree(Src, DestParent: TTreeNode; Dest: TTreeNodes);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      DestParent := Dest.AddChild(DestParent, Src.Text);&#xD;&#xA;      for i := 0 to Src.Count-1 do begin&#xD;&#xA;        CopySubTree(Src[i], DestParent, Dest);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;You can call it like so:&#xD;&#xA;&#xD;&#xA;    CopySubTree(SrcTree.Selected, nil, DestTree.Items);";;deleted 12 characters in body
12896430;5968026;505088;5;491121b8-5a4b-4184-a998-b9563dd7e109;2011-05-11 19:19:16.0;"It's easiest to do this recursively, something like this:&#xD;&#xA;&#xD;&#xA;    procedure WalkChildren(Node: TTreeNode; List: TList<TTreeNode>);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      List.Add(Node);&#xD;&#xA;      for i := 0 to Node.Count-1 do begin&#xD;&#xA;        WalkChildren(Node[i], List);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;Call it like this:&#xD;&#xA;&#xD;&#xA;    List := TList<TTreeNode>.Create;&#xD;&#xA;    WalkChildren(Root, List);&#xD;&#xA;&#xD;&#xA;This example adds to a list but you can replace that action with one of your choosing.&#xD;&#xA;&#xD;&#xA;Now that we can walk one tree, it's time to walk two trees in tandem.&#xD;&#xA;&#xD;&#xA;    procedure CopySubTree(Src, DestParent: TTreeNode; Dest: TTreeNodes);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      DestParent := Dest.AddChild(DestParent, Src.Text);&#xD;&#xA;      for i := 0 to Src.Count-1 do begin&#xD;&#xA;        CopySubTree(Src[i], DestParent, Dest);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;You can call it like so:&#xD;&#xA;&#xD;&#xA;    CopySubTree(SrcTree.Selected, nil, DestTree.Items);";;deleted 63 characters in body
12899664;5968026;505088;5;91a62153-f3c7-4ede-8b5d-755dbd62ed58;2011-05-11 21:28:34.0;"It's easiest to do this recursively, something like this:&#xD;&#xA;&#xD;&#xA;    procedure WalkChildren(Node: TTreeNode; List: TList<TTreeNode>);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;    begin&#xD;&#xA;      List.Add(Node);&#xD;&#xA;      for i := 0 to Node.Count-1 do begin&#xD;&#xA;        WalkChildren(Node[i], List);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;Call it like this:&#xD;&#xA;&#xD;&#xA;    List := TList<TTreeNode>.Create;&#xD;&#xA;    WalkChildren(Root, List);&#xD;&#xA;&#xD;&#xA;This example adds to a list but you can replace that action with one of your choosing.&#xD;&#xA;&#xD;&#xA;Now that we can walk one tree, it's time to walk two trees in tandem.&#xD;&#xA;&#xD;&#xA;    procedure CopySubTree(Src, DestParent: TTreeNode; DestNodes: TTreeNodes);&#xD;&#xA;    var&#xD;&#xA;      i: Integer;&#xD;&#xA;      Dest: TTreeNode;&#xD;&#xA;    begin&#xD;&#xA;      Dest := DestNodes.AddChild(DestParent, Src.Text);&#xD;&#xA;      //copy other parameters from Src to Dest as you please&#xD;&#xA;      for i := 0 to Src.Count-1 do begin&#xD;&#xA;        CopySubTree(Src[i], Dest, DestNodes);&#xD;&#xA;      end;&#xD;&#xA;    end;&#xD;&#xA;&#xD;&#xA;You can call it like so:&#xD;&#xA;&#xD;&#xA;    CopySubTree(SrcTree.Selected, nil, DestTree.Items);";;added 89 characters in body
